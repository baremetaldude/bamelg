//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//
// Reference: https://github.com/aklomp/base64
//

using System.IO;
using System.Runtime;

namespace System.Text {
	public struct Base64 {
		private static CString EncodeTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

		public static int GetDecodedLength( int encodedLength ) {
			if( encodedLength < 0 ) return 0;

			return encodedLength / 4 * 3;
		}

		public static int GetEncodedLength( int decodedLength ) {
			if( decodedLength < 0 ) return 0;

			return ( decodedLength + 2 ) / 3 * 4;
		}

		public static int Encode( byte* destination, int destinationLength, void* source, int sourceLength ) {
			if( destinationLength < GetEncodedLength( sourceLength ) )
				return -1;

			var encoder = new Encoder();
			var charsWritten = encoder.Process( destination, destinationLength, source, sourceLength );
			var charsFooter = encoder.Finish( destination + charsWritten );

			return charsWritten + charsFooter;
		}

		public static int Encode( char* destination, int destinationLength, void* source, int sourceLength ) {
			if( destinationLength < GetEncodedLength( sourceLength ) )
				return -1;

			var encoder = new Encoder();
			var charsWritten = encoder.Process( destination, destinationLength, source, sourceLength );
			var charsFooter = encoder.Finish( destination + charsWritten );

			return charsWritten + charsFooter;
		}

		public static int Encode( uint* destination, int destinationLength, void* source, int sourceLength ) {
			if( destinationLength < GetEncodedLength( sourceLength ) )
				return -1;

			var encoder = new Encoder();
			var charsWritten = encoder.Process( destination, destinationLength, source, sourceLength );
			var charsFooter = encoder.Finish( destination + charsWritten );

			return charsWritten + charsFooter;
		}

		public static yield<MemorySegment<byte>> StreamEncode( byte* destination, int destinationLength, void* source, int sourceLength ) {
			if( destinationLength < 4 ) yield break;

			var maxSourceFetch = GetDecodedLength( destinationLength );

			while( sourceLength > 0 ) {
				var charsToConvert = Math.Min( sourceLength, maxSourceFetch );

				var charsWritten = Encode( destination, destinationLength, source, charsToConvert );
				yield return new MemorySegment<byte>( ( byte* ) destination, ( uint ) charsWritten );

				source = ( byte* ) source + charsToConvert;
				if( checkwrap( sourceLength -= charsToConvert ) ) break;
			}
		}

		public static yield<MemorySegment<char>> StreamEncode( char* destination, int destinationLength, void* source, int sourceLength ) {
			if( destinationLength < 4 ) yield break;

			var maxSourceFetch = destinationLength / 4 * 3;

			while( sourceLength > 0 ) {
				var charsToConvert = Math.Min( sourceLength, maxSourceFetch );

				var charsWritten = Encode( destination, destinationLength, source, charsToConvert );
				yield return new MemorySegment<char>( ( char* ) destination, ( uint ) charsWritten );

				source = ( byte* ) source + charsToConvert;
				if( checkwrap( sourceLength -= charsToConvert ) ) break;
			}
		}

		public static yield<MemorySegment<uint>> StreamEncode( uint* destination, int destinationLength, void* source, int sourceLength ) {
			if( destinationLength < 4 ) yield break;

			var maxSourceFetch = destinationLength / 4 * 3;

			while( sourceLength > 0 ) {
				var charsToConvert = Math.Min( sourceLength, maxSourceFetch );

				var charsWritten = Encode( destination, destinationLength, source, charsToConvert );
				yield return new MemorySegment<uint>( ( uint* ) destination, ( uint ) charsWritten );

				source = ( byte* ) source + charsToConvert;
				if( checkwrap( sourceLength -= charsToConvert ) ) break;
			}
		}

		public static int Encode( StringBuilder builder, void* source, int sourceLength ) {
			var destinationLength = GetEncodedLength( sourceLength );
			var destination = builder.ProvideAppendLocation( destinationLength );

			var encoder = new Encoder();
			var charsWritten = encoder.Process( destination, destinationLength, source, sourceLength );
			var charsFooter = encoder.Finish( destination + charsWritten );

			return charsWritten + charsFooter;
		}

		public static int Encode( StringBuilder builder, CStringSpan& text ) { return Encode( builder, text.Location, ( int ) text.Length ); }
		public static int Encode( StringBuilder builder, CUtf8StringSpan& text ) { return Encode( builder, text.Location, ( int ) text.ByteLength ); }

		public static int Encode( ITextWriter writer, void* memory, int length ) {
			if( length == 0 ) return 0;
			int charsWritten = 0;

			using( var page = System.Runtime.Memory.CachedPages.PopScoped() ) {
				var buffer = ( char* ) page.Value;
				var bufferLength = ( int ) System.Runtime.Memory.DefaultPageSize / sizeof( *buffer );

				foreach( var segment in StreamEncode( buffer, bufferLength, memory, length ) ) {
					writer.Write( new CUtf16StringSpan( segment.Start, ( uint ) segment.Count ) );
					charsWritten += ( int ) segment.Count;
				}
			}

			return charsWritten;
		}

		public static int Encode( ITextWriter writer, CStringSpan& text ) { return Encode( writer, text.Location, ( int ) text.Length ); }
		public static int Encode( ITextWriter writer, CUtf8StringSpan& text ) { return Encode( writer, text.Location, ( int ) text.ByteLength ); }

		public static int Encode( ITextWriter writer, IStream reader, int bufferSize = BufferedStream.DefaultBufferSize ) {
			if( reader == null ) return 0;
			int charsWritten = 0;

			StreamingBufferInfo* readBuffer;
			var readStream = reader.GetBufferedReadStream( readBuffer, bufferSize );

			using( var page = Memory.CachedPages.PopScoped() ) {
				var writeBuffer = ( char* ) page.Value;
				var writeBufferLength = ( int ) System.Runtime.Memory.DefaultPageSize / sizeof( *writeBuffer );

				var maxSourceFetch = GetDecodedLength( writeBufferLength );

				for( ; ; ) {
					if( readBuffer->AvailableToRead < readBuffer->Capacity / 2 ) readStream.Flush( FlushKind.Read );
					if( readBuffer->AvailableToRead == 0 ) break;

					var toRead = Math.Min( maxSourceFetch, readBuffer->AvailableToRead );
					var written = Encode( writeBuffer, writeBufferLength, readBuffer->ReadBufferStart, toRead );
					writer.Write( new CUtf16StringSpan( writeBuffer, ( uint ) written ) );
					readBuffer->OnReadPerformed( toRead );

					charsWritten += written;
				}
			}

			return charsWritten;
		}

		public static int Encode( IStream destination, void* memory, int length, int bufferSize = BufferedStream.DefaultBufferSize ) {
			if( length == 0 ) return 0;
			int charsWritten = 0;

			StreamingBufferInfo* writeBuffer;
			var writeStream = destination.GetBufferedWriteStream( writeBuffer, bufferSize );

			var sourceMemory = ( byte* ) memory;
			var maxSourceFetch = GetDecodedLength( writeBuffer->AvailableToWrite );
			while( length > 0 ) {
				var toRead = Math.Min( length, maxSourceFetch );

				var written = Encode( writeBuffer->WriteBufferStart, writeBuffer->AvailableToWrite, sourceMemory, toRead );
				writeBuffer->OnWritePerformed( charsWritten );
				writeStream.Flush( FlushKind.Write );

				sourceMemory += toRead;
				length -= toRead;
				charsWritten += written;
			}

			return charsWritten;
		}

		public static void Encode( IStream destination, IStream source, int bufferSize = BufferedStream.DefaultBufferSize ) {
			if( !Assert.IsTrue( source != null ) ) return;
			if( !Assert.IsTrue( destination != null ) ) return;

			StreamingBufferInfo* readBuffer;
			var readStream = source.GetBufferedReadStream( readBuffer, GetDecodedLength( bufferSize ) );

			StreamingBufferInfo* writeBuffer;
			var writeStream = destination.GetBufferedWriteStream( writeBuffer, bufferSize );

			for( ; ; ) {
				if( readBuffer->AvailableToRead < readBuffer->Capacity / 2 ) readStream.Flush( FlushKind.Read );
				if( readBuffer->AvailableToRead == 0 ) break;

				var maxToRead = GetDecodedLength( writeBuffer->AvailableToWrite );
				var toRead = Math.Min( maxToRead, readBuffer->AvailableToRead );

				var charsWritten = Encode( writeBuffer->WriteBufferStart, writeBuffer->AvailableToWrite, readBuffer->ReadBufferStart, toRead );
				readBuffer->OnReadPerformed( toRead );
				writeBuffer->OnWritePerformed( charsWritten );

				writeStream.Flush( FlushKind.Write );
			}
		}

		public static SbcsString EncodeToSbcsString( void* source, int sourceLength ) {
			var destinationLength = GetEncodedLength( sourceLength );

			var result = new SbcsString.Builder( ( uint ) destinationLength );
			var destination = result.GetChars();

			var encoder = new Encoder();
			var charsWritten = encoder.Process( destination, destinationLength, source, sourceLength );
			var charsFooter = encoder.Finish( destination + charsWritten );

			return result.Detach();
		}

		public static SbcsString EncodeToSbcsString( CStringSpan& text ) { return EncodeToSbcsString( text.Location, ( int ) text.Length ); }
		public static SbcsString EncodeToSbcsString( CUtf8StringSpan& text ) { return EncodeToSbcsString( text.Location, ( int ) text.ByteLength ); }

		public static Utf8String EncodeToUtf8String( void* source, int sourceLength ) {
			var destinationLength = GetEncodedLength( sourceLength );

			var result = new Utf8String.Builder( ( uint ) destinationLength );
			var destination = result.GetChars();

			var encoder = new Encoder();
			var charsWritten = encoder.Process( destination, destinationLength, source, sourceLength );
			var charsFooter = encoder.Finish( destination + charsWritten );

			return result.Detach();
		}

		public static Utf8String EncodeToUtf8String( CStringSpan& text ) { return EncodeToUtf8String( text.Location, ( int ) text.Length ); }
		public static Utf8String EncodeToUtf8String( CUtf8StringSpan& text ) { return EncodeToUtf8String( text.Location, ( int ) text.ByteLength ); }

		public static Utf16String EncodeToUtf16String( void* source, int sourceLength ) {
			var destinationLength = GetEncodedLength( sourceLength );

			var result = new Utf16String.Builder( ( uint ) destinationLength );
			var destination = result.GetChars();

			var encoder = new Encoder();
			var charsWritten = encoder.Process( destination, destinationLength, source, sourceLength );
			var charsFooter = encoder.Finish( destination + charsWritten );

			return result.Detach();
		}

		public static Utf16String EncodeToUtf16String( CStringSpan& text ) { return EncodeToUtf16String( text.Location, ( int ) text.Length ); }
		public static Utf16String EncodeToUtf16String( CUtf8StringSpan& text ) { return EncodeToUtf16String( text.Location, ( int ) text.ByteLength ); }

		public static Utf32String EncodeToUtf32String( void* source, int sourceLength ) {
			var destinationLength = GetEncodedLength( sourceLength );

			var result = new Utf32String.Builder( ( uint ) destinationLength );
			var destination = result.GetChars();

			var encoder = new Encoder();
			var charsWritten = encoder.Process( destination, destinationLength, source, sourceLength );
			var charsFooter = encoder.Finish( destination + charsWritten );

			return result.Detach();
		}

		public static Utf16String EncodeToUtf32String( CStringSpan& text ) { return EncodeToUtf16String( text.Location, ( int ) text.Length ); }
		public static Utf16String EncodeToUtf32String( CUtf8StringSpan& text ) { return EncodeToUtf16String( text.Location, ( int ) text.ByteLength ); }

		public struct Encoder {
			private int _bytes;
			private byte _carry;

			public Encoder() {
				ResetState();
			}

			private void ResetState() {
				_bytes = 0;
				_carry = 0;
			}

			/// \return number of characters written
			public int Process( byte* destination, int destinationLength, void* source, int sourceLength ) {
				var src = ( byte* ) source;
				var out = destination;

				int written = 0;
				var bytes = _bytes;
				var carry = _carry;

				switch( _bytes ) {
					case 0: break;
					case 1: goto carry1;
					case 2: goto carry2;
				}

				for( ; ; ) {
					{
						var writePackStart = out;

						switch( System.Runtime.CompilerServices.CompilerInfo.MemoryToRegisterTransferWidth ) {
							case 4:
								while( sourceLength >= 4 ) {
									uint str = unaligned( *( uint_bigendian* ) src );

									*out++ = EncodeTable[cast<byte>( str >> 26 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 20 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 14 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 8 ) & 0x3F];

									src += 3;
									sourceLength -= 3;
								}

								break;

							case 8:
								while( sourceLength >= 8 ) {
									ulong str = unaligned( *( ulong_bigendian* ) src );

									*out++ = EncodeTable[cast<byte>( str >> 58 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 52 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 46 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 40 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 34 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 28 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 22 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 16 ) & 0x3F];

									src += 6;
									sourceLength -= 6;
								}

								break;
						}

						written += ( int )( out - writePackStart );
					}

					if( sourceLength-- == 0 ) break;

					*out++ = EncodeTable[*src >> 2];
					carry = ( *src++ << 4 ) & 0x30;
					bytes++;
					written += 1;

				carry1:
					if( sourceLength-- == 0 ) break;

					*out++ = EncodeTable[carry | ( *src >> 4 )];
					carry = ( *src++ << 2 ) & 0x3C;
					bytes++;
					written += 1;

				carry2:
					if( sourceLength-- == 0 ) break;

					*out++ = EncodeTable[carry | ( *src >> 6 )];
					*out++ = EncodeTable[*src++ & 0x3F];
					bytes = 0;
					written += 2;
				}

				_bytes = bytes;
				_carry = carry;

				return written;
			}

			/// \return number of characters written
			public int Process( char* destination, int destinationLength, void* source, int sourceLength ) {
				var src = ( byte* ) source;
				var out = destination;

				int written = 0;
				var bytes = _bytes;
				var carry = _carry;

				switch( _bytes ) {
					case 0: break;
					case 1: goto carry1;
					case 2: goto carry2;
				}

				for( ; ; ) {
					{
						var writePackStart = out;

						switch( System.Runtime.CompilerServices.CompilerInfo.MemoryToRegisterTransferWidth ) {
							case 4:
								while( sourceLength >= 4 ) {
									uint str = unaligned( *( uint_bigendian* ) src );

									*out++ = ( char ) EncodeTable[cast<byte>( str >> 26 ) & 0x3F];
									*out++ = ( char ) EncodeTable[cast<byte>( str >> 20 ) & 0x3F];
									*out++ = ( char ) EncodeTable[cast<byte>( str >> 14 ) & 0x3F];
									*out++ = ( char ) EncodeTable[cast<byte>( str >> 8 ) & 0x3F];

									src += 3;
									sourceLength -= 3;
								}

								break;

							case 8:
								while( sourceLength >= 8 ) {
									ulong str = unaligned( *( ulong_bigendian* ) src );

									*out++ = ( char ) EncodeTable[cast<byte>( str >> 58 ) & 0x3F];
									*out++ = ( char ) EncodeTable[cast<byte>( str >> 52 ) & 0x3F];
									*out++ = ( char ) EncodeTable[cast<byte>( str >> 46 ) & 0x3F];
									*out++ = ( char ) EncodeTable[cast<byte>( str >> 40 ) & 0x3F];
									*out++ = ( char ) EncodeTable[cast<byte>( str >> 34 ) & 0x3F];
									*out++ = ( char ) EncodeTable[cast<byte>( str >> 28 ) & 0x3F];
									*out++ = ( char ) EncodeTable[cast<byte>( str >> 22 ) & 0x3F];
									*out++ = ( char ) EncodeTable[cast<byte>( str >> 16 ) & 0x3F];

									src += 6;
									sourceLength -= 6;
								}

								break;
						}

						written += ( int )( out - writePackStart );
					}

					if( sourceLength-- == 0 ) break;

					*out++ = ( char ) EncodeTable[*src >> 2];
					carry = ( *src++ << 4 ) & 0x30;
					bytes++;
					written += 1;

				carry1:
					if( sourceLength-- == 0 ) break;

					*out++ = ( char ) EncodeTable[carry | ( *src >> 4 )];
					carry = ( *src++ << 2 ) & 0x3C;
					bytes++;
					written += 1;

				carry2:
					if( sourceLength-- == 0 ) break;

					*out++ = ( char ) EncodeTable[carry | ( *src >> 6 )];
					*out++ = ( char ) EncodeTable[*src++ & 0x3F];
					bytes = 0;
					written += 2;
				}

				_bytes = bytes;
				_carry = carry;

				return written;
			}

			/// \return number of characters written
			public int Process( uint* destination, int destinationLength, void* source, int sourceLength ) {
				var src = ( byte* ) source;
				var out = destination;

				int written = 0;
				var bytes = _bytes;
				var carry = _carry;

				switch( bytes ) {
					case 0: break;
					case 1: goto carry1;
					case 2: goto carry2;
				}

				for( ; ; ) {
					{
						var writePackStart = out;

						switch( System.Runtime.CompilerServices.CompilerInfo.MemoryToRegisterTransferWidth ) {
							case 4:
								while( sourceLength >= 4 ) {
									uint str = unaligned( *( uint_bigendian* ) src );

									*out++ = EncodeTable[cast<byte>( str >> 26 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 20 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 14 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 8 ) & 0x3F];

									src += 3;
									sourceLength -= 3;
								}

								break;

							case 8:
								while( sourceLength >= 8 ) {
									ulong str = unaligned( *( ulong_bigendian* ) src );

									*out++ = EncodeTable[cast<byte>( str >> 58 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 52 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 46 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 40 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 34 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 28 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 22 ) & 0x3F];
									*out++ = EncodeTable[cast<byte>( str >> 16 ) & 0x3F];

									src += 6;
									sourceLength -= 6;
								}

								break;
						}

						written += ( int )( out - writePackStart );
					}

					if( sourceLength-- == 0 ) break;

					*out++ = EncodeTable[*src >> 2];
					carry = ( *src++ << 4 ) & 0x30;
					bytes++;
					written += 1;

				carry1:
					if( sourceLength-- == 0 ) break;

					*out++ = EncodeTable[carry | ( *src >> 4 )];
					carry = ( *src++ << 2 ) & 0x3C;
					bytes++;
					written += 1;

				carry2:
					if( sourceLength-- == 0 ) break;

					*out++ = EncodeTable[carry | ( *src >> 6 )];
					*out++ = EncodeTable[*src++ & 0x3F];
					bytes = 0;
					written += 2;
				}

				_bytes = bytes;
				_carry = carry;

				return written;
			}

			public int Finish( byte* destination ) {
				if( _bytes == 1 ) {
					*destination++ = EncodeTable[_carry];
					*destination++ = '=';
					*destination++ = '=';

					return 3;
				}

				if( _bytes == 2 ) {
					*destination++ = EncodeTable[_carry];
					*destination++ = '=';

					return 2;
				}

				return 0;
			}

			public int Finish( char* destination ) {
				if( _bytes == 1 ) {
					*destination++ = ( char ) EncodeTable[_carry];
					*destination++ = '=';
					*destination++ = '=';

					return 3;
				}

				if( _bytes == 2 ) {
					*destination++ = ( char ) EncodeTable[_carry];
					*destination++ = '=';

					return 2;
				}

				return 0;
			}

			public int Finish( uint* destination ) {
				if( _bytes == 1 ) {
					*destination++ = EncodeTable[_carry];
					*destination++ = '=';
					*destination++ = '=';

					return 3;
				}

				if( _bytes == 2 ) {
					*destination++ = EncodeTable[_carry];
					*destination++ = '=';

					return 2;
				}

				return 0;
			}
		}

		private static uint[256] le_table_dec_d0 = new uint[256] {
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x000000f8, 0xffffffff, 0xffffffff, 0xffffffff, 0x000000fc,
			0x000000d0, 0x000000d4, 0x000000d8, 0x000000dc, 0x000000e0, 0x000000e4,
			0x000000e8, 0x000000ec, 0x000000f0, 0x000000f4, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
			0x00000004, 0x00000008, 0x0000000c, 0x00000010, 0x00000014, 0x00000018,
			0x0000001c, 0x00000020, 0x00000024, 0x00000028, 0x0000002c, 0x00000030,
			0x00000034, 0x00000038, 0x0000003c, 0x00000040, 0x00000044, 0x00000048,
			0x0000004c, 0x00000050, 0x00000054, 0x00000058, 0x0000005c, 0x00000060,
			0x00000064, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x00000068, 0x0000006c, 0x00000070, 0x00000074, 0x00000078,
			0x0000007c, 0x00000080, 0x00000084, 0x00000088, 0x0000008c, 0x00000090,
			0x00000094, 0x00000098, 0x0000009c, 0x000000a0, 0x000000a4, 0x000000a8,
			0x000000ac, 0x000000b0, 0x000000b4, 0x000000b8, 0x000000bc, 0x000000c0,
			0x000000c4, 0x000000c8, 0x000000cc, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff
		};


		private static uint[256] le_table_dec_d1 = new uint[256] {
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x0000e003, 0xffffffff, 0xffffffff, 0xffffffff, 0x0000f003,
			0x00004003, 0x00005003, 0x00006003, 0x00007003, 0x00008003, 0x00009003,
			0x0000a003, 0x0000b003, 0x0000c003, 0x0000d003, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
			0x00001000, 0x00002000, 0x00003000, 0x00004000, 0x00005000, 0x00006000,
			0x00007000, 0x00008000, 0x00009000, 0x0000a000, 0x0000b000, 0x0000c000,
			0x0000d000, 0x0000e000, 0x0000f000, 0x00000001, 0x00001001, 0x00002001,
			0x00003001, 0x00004001, 0x00005001, 0x00006001, 0x00007001, 0x00008001,
			0x00009001, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x0000a001, 0x0000b001, 0x0000c001, 0x0000d001, 0x0000e001,
			0x0000f001, 0x00000002, 0x00001002, 0x00002002, 0x00003002, 0x00004002,
			0x00005002, 0x00006002, 0x00007002, 0x00008002, 0x00009002, 0x0000a002,
			0x0000b002, 0x0000c002, 0x0000d002, 0x0000e002, 0x0000f002, 0x00000003,
			0x00001003, 0x00002003, 0x00003003, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff
		};


		private static uint[256] le_table_dec_d2 = new uint[256] {
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x00800f00, 0xffffffff, 0xffffffff, 0xffffffff, 0x00c00f00,
			0x00000d00, 0x00400d00, 0x00800d00, 0x00c00d00, 0x00000e00, 0x00400e00,
			0x00800e00, 0x00c00e00, 0x00000f00, 0x00400f00, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
			0x00400000, 0x00800000, 0x00c00000, 0x00000100, 0x00400100, 0x00800100,
			0x00c00100, 0x00000200, 0x00400200, 0x00800200, 0x00c00200, 0x00000300,
			0x00400300, 0x00800300, 0x00c00300, 0x00000400, 0x00400400, 0x00800400,
			0x00c00400, 0x00000500, 0x00400500, 0x00800500, 0x00c00500, 0x00000600,
			0x00400600, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x00800600, 0x00c00600, 0x00000700, 0x00400700, 0x00800700,
			0x00c00700, 0x00000800, 0x00400800, 0x00800800, 0x00c00800, 0x00000900,
			0x00400900, 0x00800900, 0x00c00900, 0x00000a00, 0x00400a00, 0x00800a00,
			0x00c00a00, 0x00000b00, 0x00400b00, 0x00800b00, 0x00c00b00, 0x00000c00,
			0x00400c00, 0x00800c00, 0x00c00c00, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff
		};


		private static uint[256] le_table_dec_d3 = new uint[256] {
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x003e0000, 0xffffffff, 0xffffffff, 0xffffffff, 0x003f0000,
			0x00340000, 0x00350000, 0x00360000, 0x00370000, 0x00380000, 0x00390000,
			0x003a0000, 0x003b0000, 0x003c0000, 0x003d0000, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
			0x00010000, 0x00020000, 0x00030000, 0x00040000, 0x00050000, 0x00060000,
			0x00070000, 0x00080000, 0x00090000, 0x000a0000, 0x000b0000, 0x000c0000,
			0x000d0000, 0x000e0000, 0x000f0000, 0x00100000, 0x00110000, 0x00120000,
			0x00130000, 0x00140000, 0x00150000, 0x00160000, 0x00170000, 0x00180000,
			0x00190000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x001a0000, 0x001b0000, 0x001c0000, 0x001d0000, 0x001e0000,
			0x001f0000, 0x00200000, 0x00210000, 0x00220000, 0x00230000, 0x00240000,
			0x00250000, 0x00260000, 0x00270000, 0x00280000, 0x00290000, 0x002a0000,
			0x002b0000, 0x002c0000, 0x002d0000, 0x002e0000, 0x002f0000, 0x00300000,
			0x00310000, 0x00320000, 0x00330000, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff
		};


		private static uint[256] be_table_dec_d0 = new uint[256] {
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xf8000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xfc000000,
			0xd0000000, 0xd4000000, 0xd8000000, 0xdc000000, 0xe0000000, 0xe4000000,
			0xe8000000, 0xec000000, 0xf0000000, 0xf4000000, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
			0x04000000, 0x08000000, 0x0c000000, 0x10000000, 0x14000000, 0x18000000,
			0x1c000000, 0x20000000, 0x24000000, 0x28000000, 0x2c000000, 0x30000000,
			0x34000000, 0x38000000, 0x3c000000, 0x40000000, 0x44000000, 0x48000000,
			0x4c000000, 0x50000000, 0x54000000, 0x58000000, 0x5c000000, 0x60000000,
			0x64000000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x68000000, 0x6c000000, 0x70000000, 0x74000000, 0x78000000,
			0x7c000000, 0x80000000, 0x84000000, 0x88000000, 0x8c000000, 0x90000000,
			0x94000000, 0x98000000, 0x9c000000, 0xa0000000, 0xa4000000, 0xa8000000,
			0xac000000, 0xb0000000, 0xb4000000, 0xb8000000, 0xbc000000, 0xc0000000,
			0xc4000000, 0xc8000000, 0xcc000000, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff
		};


		private static uint[256] be_table_dec_d1 = new uint[256] {
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x03e00000, 0xffffffff, 0xffffffff, 0xffffffff, 0x03f00000,
			0x03400000, 0x03500000, 0x03600000, 0x03700000, 0x03800000, 0x03900000,
			0x03a00000, 0x03b00000, 0x03c00000, 0x03d00000, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
			0x00100000, 0x00200000, 0x00300000, 0x00400000, 0x00500000, 0x00600000,
			0x00700000, 0x00800000, 0x00900000, 0x00a00000, 0x00b00000, 0x00c00000,
			0x00d00000, 0x00e00000, 0x00f00000, 0x01000000, 0x01100000, 0x01200000,
			0x01300000, 0x01400000, 0x01500000, 0x01600000, 0x01700000, 0x01800000,
			0x01900000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x01a00000, 0x01b00000, 0x01c00000, 0x01d00000, 0x01e00000,
			0x01f00000, 0x02000000, 0x02100000, 0x02200000, 0x02300000, 0x02400000,
			0x02500000, 0x02600000, 0x02700000, 0x02800000, 0x02900000, 0x02a00000,
			0x02b00000, 0x02c00000, 0x02d00000, 0x02e00000, 0x02f00000, 0x03000000,
			0x03100000, 0x03200000, 0x03300000, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff
		};


		private static uint[256] be_table_dec_d2 = new uint[256] {
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x000f8000, 0xffffffff, 0xffffffff, 0xffffffff, 0x000fc000,
			0x000d0000, 0x000d4000, 0x000d8000, 0x000dc000, 0x000e0000, 0x000e4000,
			0x000e8000, 0x000ec000, 0x000f0000, 0x000f4000, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
			0x00004000, 0x00008000, 0x0000c000, 0x00010000, 0x00014000, 0x00018000,
			0x0001c000, 0x00020000, 0x00024000, 0x00028000, 0x0002c000, 0x00030000,
			0x00034000, 0x00038000, 0x0003c000, 0x00040000, 0x00044000, 0x00048000,
			0x0004c000, 0x00050000, 0x00054000, 0x00058000, 0x0005c000, 0x00060000,
			0x00064000, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x00068000, 0x0006c000, 0x00070000, 0x00074000, 0x00078000,
			0x0007c000, 0x00080000, 0x00084000, 0x00088000, 0x0008c000, 0x00090000,
			0x00094000, 0x00098000, 0x0009c000, 0x000a0000, 0x000a4000, 0x000a8000,
			0x000ac000, 0x000b0000, 0x000b4000, 0x000b8000, 0x000bc000, 0x000c0000,
			0x000c4000, 0x000c8000, 0x000cc000, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff
		};


		private static uint[256] be_table_dec_d3 = new uint[256] {
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x00003e00, 0xffffffff, 0xffffffff, 0xffffffff, 0x00003f00,
			0x00003400, 0x00003500, 0x00003600, 0x00003700, 0x00003800, 0x00003900,
			0x00003a00, 0x00003b00, 0x00003c00, 0x00003d00, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
			0x00000100, 0x00000200, 0x00000300, 0x00000400, 0x00000500, 0x00000600,
			0x00000700, 0x00000800, 0x00000900, 0x00000a00, 0x00000b00, 0x00000c00,
			0x00000d00, 0x00000e00, 0x00000f00, 0x00001000, 0x00001100, 0x00001200,
			0x00001300, 0x00001400, 0x00001500, 0x00001600, 0x00001700, 0x00001800,
			0x00001900, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0x00001a00, 0x00001b00, 0x00001c00, 0x00001d00, 0x00001e00,
			0x00001f00, 0x00002000, 0x00002100, 0x00002200, 0x00002300, 0x00002400,
			0x00002500, 0x00002600, 0x00002700, 0x00002800, 0x00002900, 0x00002a00,
			0x00002b00, 0x00002c00, 0x00002d00, 0x00002e00, 0x00002f00, 0x00003000,
			0x00003100, 0x00003200, 0x00003300, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
			0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff
		};

		private static byte[256] DecodeTable = new byte[256] {
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, //   0..15
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, //  16..31
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,  62, 255, 255, 255,  63, //  32..47
			 52,  53,  54,  55,  56,  57,  58,  59,  60,  61, 255, 255, 255, 254, 255, 255, //  48..63
			255,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14, //  64..79
			 15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25, 255, 255, 255, 255, 255, //  80..95
			255,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40, //  96..111
			 41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51, 255, 255, 255, 255, 255, // 112..127
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, // 128..143
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
		};

		public static bool Decode( void* destination, int destinationLength, byte* source, int sourceLength ) {
			var decodedLength = GetDecodedLength( sourceLength );

			if( sourceLength >= 2 ) {
				if( source[sourceLength - 1] == '=' ) {
					--decodedLength;
					if( source[sourceLength - 2] == '=' )
						--decodedLength;
				}
			}

			if( destinationLength < 4 ) return false;
			if( destinationLength < decodedLength )
				return false;

			var decoder = new Decoder();
			int charsReaden, charsWritten;
			return decoder.Process( destination, source, sourceLength, charsReaden, charsWritten );
		}

		public static bool Decode( void* destination, int destinationLength, SbcsString source ) { return Decode( destination, destinationLength, source.GetChars(), ( int ) source.Length ); }
		public static bool Decode( void* destination, int destinationLength, CString source ) { return Decode( destination, destinationLength, source.GetChars(), ( int ) source.Length ); }
		public static bool Decode( void* destination, int destinationLength, CStringSpan source ) { return Decode( destination, destinationLength, source.GetChars(), ( int ) source.Length ); }

		public static bool Decode( void* destination, int destinationLength, Utf8String source ) { return Decode( destination, destinationLength, source.GetChars(), ( int ) source.ByteLength ); }
		public static bool Decode( void* destination, int destinationLength, CUtf8String source ) { return Decode( destination, destinationLength, source.GetChars(), ( int ) source.ByteLength ); }
		public static bool Decode( void* destination, int destinationLength, CUtf8StringSpan source ) { return Decode( destination, destinationLength, source.GetChars(), ( int ) source.ByteLength ); }

		public static SbcsString DecodeToSbcsString( byte* source, int sourceLength ) {
			if( sourceLength < 1 ) return null;

			var destinationLength = GetDecodedLength( sourceLength );

			var result = new SbcsString.Builder( ( uint ) destinationLength );
			var destination = result.GetChars();

			var decoder = new Decoder();
			int charsReaden, charsWritten;
			if( !decoder.Process( destination, source, sourceLength, charsReaden, charsWritten ) )
				return null;

			return result.Detach();
		}

		public static SbcsString DecodeToSbcsString( SbcsString source ) { return DecodeToSbcsString( source.GetChars(), ( int ) source.Length ); }
		public static SbcsString DecodeToSbcsString( CString source ) { return DecodeToSbcsString( source.GetChars(), ( int ) source.Length ); }
		public static SbcsString DecodeToSbcsString( CStringSpan source ) { return DecodeToSbcsString( source.GetChars(), ( int ) source.Length ); }

		public static SbcsString DecodeToSbcsString( Utf8String source ) { return DecodeToSbcsString( source.GetChars(), ( int ) source.ByteLength ); }
		public static SbcsString DecodeToSbcsString( CUtf8String source ) { return DecodeToSbcsString( source.GetChars(), ( int ) source.ByteLength ); }
		public static SbcsString DecodeToSbcsString( CUtf8StringSpan source ) { return DecodeToSbcsString( source.GetChars(), ( int ) source.ByteLength ); }

		public static Utf8String DecodeToUtf8String( byte* source, int sourceLength ) {
			if( sourceLength < 1 ) return null;

			var destinationLength = GetDecodedLength( sourceLength );

			var result = new Utf8String.Builder( ( uint ) destinationLength );
			var destination = result.GetChars();

			var decoder = new Decoder();
			int charsReaden, charsWritten;
			if( !decoder.Process( destination, source, sourceLength, charsReaden, charsWritten ) )
				return null;

			return result.Detach();
		}

		public static Utf8String DecodeToUtf8String( SbcsString source ) { return DecodeToUtf8String( source.GetChars(), ( int ) source.Length ); }
		public static Utf8String DecodeToUtf8String( CString source ) { return DecodeToUtf8String( source.GetChars(), ( int ) source.Length ); }
		public static Utf8String DecodeToUtf8String( CStringSpan source ) { return DecodeToUtf8String( source.GetChars(), ( int ) source.Length ); }

		public static Utf8String DecodeToUtf8String( Utf8String source ) { return DecodeToUtf8String( source.GetChars(), ( int ) source.ByteLength ); }
		public static Utf8String DecodeToUtf8String( CUtf8String source ) { return DecodeToUtf8String( source.GetChars(), ( int ) source.ByteLength ); }
		public static Utf8String DecodeToUtf8String( CUtf8StringSpan source ) { return DecodeToUtf8String( source.GetChars(), ( int ) source.ByteLength ); }

		public static yield<MemorySegment<byte>> StreamDecode( void* destination, int destinationLength, byte* source, int sourceLength ) {
			if( destinationLength < 4 ) yield break;

			var maxSourceFetch = GetDecodedLength( destinationLength );
			var decoder = new Decoder();

			while( sourceLength > 0 ) {
				var charsToConvert = Math.Min( sourceLength, maxSourceFetch );

				int charsReaden, charsWritten;
				if( !decoder.Process( destination, source, charsToConvert, charsReaden, charsWritten ) ) break;
				if( charsWritten == 0 ) break;
				yield return new MemorySegment<byte>( ( byte* ) destination, ( uint ) charsWritten );

				source = ( byte* ) source + charsReaden;
				sourceLength -= charsReaden;
			}
		}

		private enum EofKind : byte {
			None,
			MarkerSeen,
			EOF,
		}

		public struct Decoder {
			private int _bytes;
			private byte _carry;
			private EofKind _eof;

			public Decoder() {
				ResetState();
			}

			private void ResetState() {
				_eof = EofKind.None;
				_bytes = 0;
				_carry = 0;
			}

			public bool Process( void* destination, byte* source, int sourceLength, int& readen, int& written ) {
				var status = false;
				byte* input = ( byte* ) source;
				byte* output = ( byte* ) destination;
				byte q;

				var bytes = _bytes;
				var carry = _carry;

				if( _eof != EofKind.None ) {
					readen = written = 0;

					if( sourceLength != 0 && _eof == EofKind.MarkerSeen ) {
						_bytes = 0;
						_eof = EofKind.EOF;
						return ( DecodeTable[*input++] == 254 ) && ( sourceLength == 1 );
					}

					return false;
				}

				switch( bytes ) {
					case 0: break;
					case 1: goto carry1;
					case 2: goto carry2;
					case 3: goto carry3;
				}

				for( ; ; ) {
					while( sourceLength > 4 ) {
						uint x;
						if( typeof( uint ) == typeof( uint_littleendian ) ) {
							x = le_table_dec_d0[input[0]] | le_table_dec_d1[input[1]] | le_table_dec_d2[input[2]] | le_table_dec_d3[input[3]];

							if( ( x & 0x80000000U ) != 0 ) break;
						}
						else {
							x = be_table_dec_d0[input[0]] | be_table_dec_d1[input[1]] | be_table_dec_d2[input[2]] | be_table_dec_d3[input[3]];

							if( ( x & 1U ) != 0 ) break;
						}

						if( System.Runtime.CompilerServices.CompilerInfo.FastUnalignedAccess ) {
							unaligned( *( uint* ) output ) = x;
						}
						else {
							var content = ( byte* ) &x;
							output[0] = content[0];
							output[1] = content[1];
							output[2] = content[2];
						}

						input += 4;
						output += 3;
						sourceLength -= 4;
					}

					if( sourceLength-- == 0 ) {
						status = true;
						break;
					}

					if( ( q = DecodeTable[*input++] ) >= 254 ) {
						_eof = EofKind.EOF;
						break;
					}
					carry = q << 2;
					bytes++;

				carry1:
					if( sourceLength-- == 0 ) {
						status = true;
						break;
					}

					if( ( q = DecodeTable[*input++] ) >= 254 ) {
						_eof = EofKind.EOF;
						break;
					}

					*output++ = carry | ( q >> 4 );
					carry = q << 4;
					bytes++;

				carry2:
					if( sourceLength-- == 0 ) {
						status = true;
						break;
					}

					if( ( q = DecodeTable[*input++] ) >= 254 ) {
						bytes++;
						if( q == 254 ) {
							if( sourceLength-- != 0 ) {
								bytes = 0;
								_eof = EofKind.EOF;
								q = DecodeTable[*input++];
								status = ( q == 254 ) && ( sourceLength == 0 );
								break;
							}
							else {
								_eof = EofKind.MarkerSeen;
								status = true;
								break;
							}
						}

						break;
					}

					*output++ = carry | ( q >> 2 );
					carry = q << 6;
					bytes++;

				carry3:
					if( sourceLength-- == 0 ) {
						status = true;
						break;
					}

					if( ( q = DecodeTable[*input++] ) >= 254 ) {
						bytes = 0;
						_eof = EofKind.EOF;
						status = ( q == 254 ) && ( sourceLength == 0 );
						break;
					}

					*output++ = carry | q;
					carry = 0;
					bytes = 0;
				}

				_bytes = bytes;
				_carry = carry;
				readen = ( int )( input - source );
				written = ( int )( output - ( byte* ) destination );

				return status;
			}
		}
	}
}