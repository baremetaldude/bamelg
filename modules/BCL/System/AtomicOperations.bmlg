//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System.Runtime;

namespace System {
	public static struct AtomicOperations {
		// @{ CompareExchange
		public extern static void* CompareExchange( void** value, void* comparand, void* newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );

		public extern static sbyte CompareExchange( sbyte* value, sbyte comparand, sbyte newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static short CompareExchange( short* value, short comparand, short newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static int CompareExchange( int* value, int comparand, int newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static long CompareExchange( long* value, long comparand, long newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );

		public extern static byte CompareExchange( byte* value, byte comparand, byte newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static ushort CompareExchange( ushort* value, ushort comparand, ushort newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static uint CompareExchange( uint* value, uint comparand, uint newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static ulong CompareExchange( ulong* value, ulong comparand, ulong newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );

		public extern static LittleEndianUInt128 CompareExchange( LittleEndianUInt128* value, LittleEndianUInt128 comparand, LittleEndianUInt128 newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		// @}

		// @{ 'TryCompareExchange' is equal to (CompareExchange(value,newValue,comparand) == comparand)
		public extern static bool TryCompareExchange( void** value, void* comparand, void* newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );

		public extern static bool TryCompareExchange( sbyte* value, sbyte comparand, sbyte newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static bool TryCompareExchange( short* value, short comparand, short newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static bool TryCompareExchange( int* value, int comparand, int newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static bool TryCompareExchange( long* value, long comparand, long newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );

		public extern static bool TryCompareExchange( byte* value, byte comparand, byte newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static bool TryCompareExchange( ushort* value, ushort comparand, ushort newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static bool TryCompareExchange( uint* value, uint comparand, uint newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		public extern static bool TryCompareExchange( ulong* value, ulong comparand, ulong newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );

		public extern static bool TryCompareExchange( LittleEndianUInt128* value, LittleEndianUInt128 comparand, LittleEndianUInt128 newValue, [EvaluateConstant] [StrictField] Memory.AtomicOrdering ordering = Memory.AtomicOrdering.SequentiallyConsistent, [EvaluateConstant] [StrictField] Memory.SynchronizationScope scope = Memory.SynchronizationScope.CrossThread );
		// @}

		// @{ Exchange: atomic( variable = anotherValue )
		public extern static void* Exchange( void** value, void* anotherValue );

		public extern static sbyte Exchange( sbyte* value, sbyte anotherValue );
		public extern static short Exchange( short* value, short anotherValue );
		public extern static int Exchange( int* value, int anotherValue );
		public extern static long Exchange( long* value, long anotherValue );

		public extern static byte Exchange( byte* value, byte anotherValue );
		public extern static ushort Exchange( ushort* value, ushort anotherValue );
		public extern static uint Exchange( uint* value, uint anotherValue );
		public extern static ulong Exchange( ulong* value, ulong anotherValue );
		// @}

		// @{ Add: atomic( variable += anotherValue )
		public extern static sbyte Add( sbyte* value, sbyte anotherValue );
		public extern static short Add( short* value, short anotherValue );
		public extern static int Add( int* value, int anotherValue );
		public extern static long Add( long* value, long anotherValue );

		public extern static byte Add( byte* value, byte anotherValue );
		public extern static ushort Add( ushort* value, ushort anotherValue );
		public extern static uint Add( uint* value, uint anotherValue );
		public extern static ulong Add( ulong* value, ulong anotherValue );
		// @}

		// @{ Sub: atomic( variable -= anotherValue )
		public extern static sbyte Sub( sbyte* value, sbyte anotherValue );
		public extern static short Sub( short* value, short anotherValue );
		public extern static int Sub( int* value, int anotherValue );
		public extern static long Sub( long* value, long anotherValue );

		public extern static byte Sub( byte* value, byte anotherValue );
		public extern static ushort Sub( ushort* value, ushort anotherValue );
		public extern static uint Sub( uint* value, uint anotherValue );
		public extern static ulong Sub( ulong* value, ulong anotherValue );
		// @}

		// @{ Min: variable = variable < anotherValue ? variable : anotherValue
		public extern static sbyte Min( sbyte* value, sbyte anotherValue );
		public extern static short Min( short* value, short anotherValue );
		public extern static int Min( int* value, int anotherValue );
		public extern static long Min( long* value, long anotherValue );

		public extern static byte Min( byte* value, byte anotherValue );
		public extern static ushort Min( ushort* value, ushort anotherValue );
		public extern static uint Min( uint* value, uint anotherValue );
		public extern static ulong Min( ulong* value, ulong anotherValue );
		// @}

		// @{ Max: variable = variable > anotherValue ? variable : anotherValue
		public extern static sbyte Max( sbyte* value, sbyte anotherValue );
		public extern static short Max( short* value, short anotherValue );
		public extern static int Max( int* value, int anotherValue );
		public extern static long Max( long* value, long anotherValue );

		public extern static byte Max( byte* value, byte anotherValue );
		public extern static ushort Max( ushort* value, ushort anotherValue );
		public extern static uint Max( uint* value, uint anotherValue );
		public extern static ulong Max( ulong* value, ulong anotherValue );
		// @}

		// @{ Sub: atomic( variable &= anotherValue )
		public extern static byte And( byte* value, byte anotherValue );
		public extern static ushort And( ushort* value, ushort anotherValue );
		public extern static uint And( uint* value, uint anotherValue );
		public extern static ulong And( ulong* value, ulong anotherValue );

		public extern static sbyte And( sbyte* value, sbyte anotherValue );
		public extern static short And( short* value, short anotherValue );
		public extern static int And( int* value, int anotherValue );
		public extern static long And( long* value, long anotherValue );
		// @}

		// @{ Sub: atomic( variable &= anotherValue )
		public extern static byte Or( byte* value, byte anotherValue );
		public extern static ushort Or( ushort* value, ushort anotherValue );
		public extern static uint Or( uint* value, uint anotherValue );
		public extern static ulong Or( ulong* value, ulong anotherValue );

		public extern static sbyte Or( sbyte* value, sbyte anotherValue );
		public extern static short Or( short* value, short anotherValue );
		public extern static int Or( int* value, int anotherValue );
		public extern static long Or( long* value, long anotherValue );
		// @}

		// @{ Nand: atomic version of 'variable = ~( variable & anotherValue )'
		public extern static byte Nand( byte* value, byte anotherValue );
		public extern static ushort Nand( ushort* value, ushort anotherValue );
		public extern static uint Nand( uint* value, uint anotherValue );
		public extern static ulong Nand( ulong* value, ulong anotherValue );

		public extern static sbyte Nand( sbyte* value, sbyte anotherValue );
		public extern static short Nand( short* value, short anotherValue );
		public extern static int Nand( int* value, int anotherValue );
		public extern static long Nand( long* value, long anotherValue );
		// @}

		// @{ Xor: atomic( variable ^= anotherValue )
		public extern static byte Xor( byte* value, byte anotherValue );
		public extern static ushort Xor( ushort* value, ushort anotherValue );
		public extern static uint Xor( uint* value, uint anotherValue );
		public extern static ulong Xor( ulong* value, ulong anotherValue );

		public extern static sbyte Xor( sbyte* value, sbyte anotherValue );
		public extern static short Xor( short* value, short anotherValue );
		public extern static int Xor( int* value, int anotherValue );
		public extern static long Xor( long* value, long anotherValue );
		// @}

		public static bool CompareExchange( RuntimeObjectBase* left, RuntimeObjectBase comparand, RuntimeObjectBase right ) {
			// Too rare case
			// if( expectedLeft == right ) return true;

			if( CompareExchange( bitcast<uintptr*>( left ), bitcast<uintptr>( comparand ), bitcast<uintptr>( right ) ) == bitcast<uintptr>( comparand ) ) {
				right.AddReference();
				comparand.ReleaseReference();
				return true;
			}

			return false;
		}

		public static void Exchange( RuntimeObjectBase* left, RuntimeObjectBase right ) {
			right.AddReference();

			RuntimeObjectBase referenceReleaser = null;
			*( uintptr* ) &referenceReleaser = Exchange( bitcast<uintptr*>( left ), bitcast<uintptr>( right ) );
		}
	}
}