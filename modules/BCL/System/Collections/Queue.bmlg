//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System.IO;

namespace System.Collections {
	public class Queue<T> {
		private T[] _items;
		private int _tail, _head, _count;
		private int _version;

		public Queue() {
			_items = new[16] T;
		}

		public Queue( int capacity ) {
			if( !BitOperations.IsPowerOf2( capacity ) )
				capacity = BitOperations.NextPowerOf2( capacity );

			if( !Assert.IsFalse( capacity < 0 ) )
				capacity = 3;

			_items = new[capacity] T;
		}

		public Queue( Queue<T> other ) {
			if( other == null ) return;

			_items = new[other._items.Length] T;
			_count = other._count;

			if( other._count > 0 ) {
				if( other._head < other._tail ) {
					CommonCollectionOperations.Copy<T>( &_items[0], &other._items[other._head], other._count );
				}
				else {
					CommonCollectionOperations.Copy<T>( &_items[0], &other._items[other._head], other._items.Length - other._head );
					CommonCollectionOperations.Copy<T>( &_items[other._items.Length - other._head], &other._items[0], other._tail );
				}
			}
		}

		public void Clear() {
			if( _head < _tail ) {
				CommonCollectionOperations.Clear<T>( &_items[_head], _count );
			}
			else if( _count > 0 ) {
				CommonCollectionOperations.Clear<T>( &_items[0], _tail );
				CommonCollectionOperations.Clear<T>( &_items[_head], _items.Length - _head );
			}

			_head = 0;
			_tail = 0;
			_count = 0;
			CommonCollectionOperations.UpdateVersion( &_version );
		}

		public bool Contains( T value ) {
			var index = _head;
			var size = _count;

			while( size-- > 0 ) {
				if( _items[index] == value )
					return true;

				index = ( index + 1 ) & ( _items.Length - 1 );
			}

			return false;
		}

		public T Dequeue() {
			if( !Assert.IsTrue( _count != 0 ) ) return default( T );

			var result = _items[_head];

			_items[_head] = default( T );
			_head = ( _head + 1 ) & ( _items.Length - 1 );
			--_count;
			CommonCollectionOperations.UpdateVersion( &_version );

			return result;
		}

		public void Enqueue( T item ) {
			if( _count == _items.Length )
				SetCapacity( _items.Length * 2 );

			_items[_tail] = item;
			_tail = ( _tail + 1 ) & ( _items.Length - 1 );
			++_count;
			CommonCollectionOperations.UpdateVersion( &_version );
		}

		public void AddRange( T* items, int count ) {
			EnsureCapacity( _count + count );

			// TODO
			// if( _head < _tail ) {
			// 	var tailCount = _items.Length - _tail;
			// 	var tailCopied = Math.Min( count, tailCount );

			// 	CommonCollectionOperations.Copy<T>( &_items[_tail], items, tailCopied );
			// 	if( tailCount != count ) CommonCollectionOperations.Copy<T>( &_items[0], items, count - tailCopied );
			// }
			// else {
			// 	CommonCollectionOperations.Copy<T>( &_items[_tail], items, count );
			// }

			// _tail = ( _tail + count ) & ( _items.Length - 1 );
			// _count += count;
			// CommonCollectionOperations.UpdateVersion( &_version );

			for( var i = 0; i < count; ++i )
				Enqueue( items[i] );
		}

		public T Peek() {
			if( !Assert.IsTrue( _count > 0 ) ) return default( T );

			return _items[_head];
		}
		
		public T First() {
			return Peek();
		}

		public T Last() {
			if( !Assert.IsTrue( _count > 0 ) ) return default( T );

			return _items[( _tail - 1 + _items.Length ) & ( _items.Length - 1 )];
		}

		public int Count {
			get {
				return _count;
			}
		}

		public T this[int index] {
			get { return _items[( _head + index ) & ( _items.Length - 1 )]; }
			set { _items[( _head + index ) & ( _items.Length - 1 )] = value; }
		}

		public int Capacity {
			get { return _items.Length; }
			set {
				if( value <= _items.Length ) return;

				EnsureCapacity( value );
			}
		}

		private void EnsureCapacity( int value ) {
			if( value <= _items.Length ) return;

			if( !BitOperations.IsPowerOf2( value ) )
				value = BitOperations.NextPowerOf2( value );

			SetCapacity( value );
		}

		private void SetCapacity( int capacity ) {
			var result = new[capacity] T;

			if( _head < _tail )
				CommonCollectionOperations.Copy<T>( &result[0], &_items[_head], _count );
			else if( _count > 0 ) {
				CommonCollectionOperations.Copy<T>( &result[0], &_items[_head], _items.Length - _head );
				CommonCollectionOperations.Copy<T>( &result[_items.Length - _head], &_items[0], _tail );
			}

			_items = result;
			_head = 0;
			_tail = ( _count == capacity ) ? 0 : _count;
			CommonCollectionOperations.UpdateVersion( &_version );
		}

		public T[] ToArray() {
			var result = new[_count] T;

			if( _count > 0 ) {
				if( _head < _tail ) {
					CommonCollectionOperations.Copy<T>( &result[0], &_items[_head], _count );
					return result;
				}

				CommonCollectionOperations.Copy<T>( &result[0], &_items[_head], _items.Length - _head );
				CommonCollectionOperations.Copy<T>( &result[_items.Length - _head], &_items[0], _tail );
			}

			return result;
		}

		public Enumerator GetEnumerator() { return new Enumerator( this ); }

		[EnumeratorAttribute]
		public struct Enumerator {
			private declaringtype _parent;
			private int _index;
			private int _version;
			private T _currentElement;

			internal Enumerator( declaringtype parent ) {
				_parent = parent;
				_version = _parent._version;
				_index = -1;
				_currentElement = default( T );
			}

			public bool MoveNext() {
				CommonCollectionOperations.VersionCheck( _parent._version == _version );

				if( _index == -2 )
					return false;

				++_index;

				if( _index == _parent._count ) {
					_index = -2;
					_currentElement = default( T );
					return false;
				}

				_currentElement = _parent[_index];
				return true;
			}

			public T Current {
				get {
					if( _index < 0 )
						Assert.Unreachable();

					return _currentElement;
				}
			}
		}

		public void Serialize( BinaryWriter writer ) {
			writer.Write( typeof( thistype ).FullQualifiedName.Hash );

			writer.Write( Count );

			if( typeof( T ).IsPlainDataType ) {
				if( _head < _tail ) {
					writer.Write( &_items[_head], sizeof( T ) * _count );
				}
				else if( _count > 0 ) {
					writer.Write( &_items[_head], sizeof( T ) * ( _items.Length - _head ) );
					writer.Write( &_items[0], sizeof( T ) * _tail );
				}
			}
			else {
				Assert.NotImplemented();
			}
		}

		public void Deserialize( BinaryReader reader ) {
			if( !Assert.IsTrue( typeof( thistype ).FullQualifiedName.Hash == reader.ReadUInt32() ) ) return;

			int count; reader.Read( count );

			Capacity = count;

			_head = 0;
			_tail = count & ( _items.Length - 1 );
			_count = count;
			CommonCollectionOperations.UpdateVersion( &_version );

			if( typeof( T ).IsPlainDataType ) {
				reader.Read( &_items[0], sizeof( T ) * _count );
			}
			else {
				Assert.NotImplemented();
			}
		}
	}
}