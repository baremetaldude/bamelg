//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

namespace System.Collections {
	public static struct PriorityQueueCommon {
		public static int GetLeftChildIndex( int parentIndex ) { return ( parentIndex * 2 ) + 1; }
		public static int GetParentIndex( int childIndex ) { return ( childIndex - 1 ) / 2; }
		public static int GetRightIndexFromLeft( int leftIndex ) { return leftIndex + 1; }
	}

	public class PriorityQueue<T> {
		private const int DefaultCapacity = 16;

		/// Returns true if left value have greater priority than right
		/// 'new PriorityQueue<int>( ( x, y ) => x < y )' will sort in ascending order
		private Functors.Func<T, T, bool> Comparer;

		private int _count;
		private T[] _heap;

		public PriorityQueue( Functors.Func<T, T, bool> comparer )
			: this( DefaultCapacity, comparer ) {
		}

		public PriorityQueue( int capacity, Functors.Func<T, T, bool> comparer ) {
			if( !BitOperations.IsPowerOf2( capacity ) )
				capacity = BitOperations.NextPowerOf2( capacity );

			_heap = new[capacity] T;

			_count = 0;
			Comparer = comparer;
		}

		public void Clear() {
			_count = 0;
		}

		public void AddRange( T* items, int count ) {
			EnsureCapacity( count );

			for( var i = 0; i < count; ++i )
				Enqueue( items[i] );
		}


		public void Enqueue( T value ) {
			EnsureCapacity( 1 );

			var i = _count;

			while( i > 0 ) {
				var parentIndex = PriorityQueueCommon.GetParentIndex( i );

				if( !Comparer( value, _heap[parentIndex] ) )
					break;

				_heap[i] = _heap[parentIndex];
				i = parentIndex;
			}

			_heap[i] = value;
			++_count;
		}

		public T Dequeue() {
			if( _count == 0 ) return default( T );

			var result = Top;

			if( _count > 1 ) {
				var i = 0;

				for( var leftChild = PriorityQueueCommon.GetLeftChildIndex( i ); leftChild < _count; leftChild = PriorityQueueCommon.GetLeftChildIndex( i ) ) {
					var rightChild = PriorityQueueCommon.GetRightIndexFromLeft( leftChild );
					var highestPriorityChild = rightChild < _count && Comparer( _heap[rightChild], _heap[leftChild] ) ? rightChild : leftChild;

					_heap[i] = _heap[highestPriorityChild];
					i = highestPriorityChild;
				}

				_heap[i] = _heap[_count - 1];
			}

			--_count;
			return result;
		}

		public void EnsureCapacity( int count ) {
			var newCount = _count + count;

			if( newCount >= _heap.Length ) {
				if( !BitOperations.IsPowerOf2( newCount ) )
					newCount = BitOperations.NextPowerOf2( newCount );

				var newHeap = new[newCount] T;

				CommonCollectionOperations.Copy<T>( &newHeap[0], &_heap[0], _count );

				_heap = newHeap;
			}
		}

		public int Count { get { return _count; } }
		public int Capacity { get { return _heap.Length; } }

		public T Top { get { System.Diagnostics.Debug.Assert( _count > 0 ); return _heap[0]; } }
		public T Peek() { System.Diagnostics.Debug.Assert( _count > 0 ); return _heap[0]; }

		public Enumerator GetEnumerator() {
			return new Enumerator( this );
		}

		[EnumeratorAttribute]
		public struct Enumerator {
			private readonly declaringtype _parent;
			private int _index, _count;

			internal Enumerator( declaringtype parent ) {
				_index = -1;
				_parent = parent;
				_count = parent._count;
			}

			public bool MoveNext() {
				return ++_index < _count;
			}

			public T Current { get { return _parent._heap[_index]; } }
		}
	}

	public class TrackablePriorityQueue<T> {
		private const int DefaultCapacity = 16;

		/// Returns true if left value have greater priority than right
		/// 'new PriorityQueue<int>( ( x, y ) => x < y )' will sort in ascending order
		public readonly Functors.Func<T, T, bool> Comparer;

		private int _count;
		private T[] _heap;
		private int[] _heapToTrackingKeyMapping, _trackingKeyToHeapMapping;

		private PoolIndexManager _trackingManager = new PoolIndexManager();

		public TrackablePriorityQueue( Functors.Func<T, T, bool> comparer )
			: this( DefaultCapacity, comparer ) {
		}

		public TrackablePriorityQueue( int capacity, Functors.Func<T, T, bool> comparer ) {
			if( !BitOperations.IsPowerOf2( capacity ) )
				capacity = BitOperations.NextPowerOf2( capacity );

			_heap = new[capacity] T;
			_heapToTrackingKeyMapping = new[capacity] int;
			_trackingKeyToHeapMapping = new[capacity] int;

			for( int i = 0; i < capacity; i++ ) {
				_heapToTrackingKeyMapping[i] = -1;
				_trackingKeyToHeapMapping[i] = -1;
			}

			_count = 0;
			Comparer = comparer;
		}

		public void Clear() {
			_count = 0;
		}

		public T this[int trackingIndex] {
			get {
				if( !Assert.IsTrue( trackingIndex >= 0 && trackingIndex < _trackingKeyToHeapMapping.Length ) ) return default( T );
				var heapIndex = _trackingKeyToHeapMapping[trackingIndex];
				if( !Assert.IsTrue( heapIndex >= 0 && heapIndex < _heap.Length ) ) return default( T );
				return _heap[heapIndex];
			}
		}

		public Functors.Comparison<T> FindRanker = null;

		private List<int> _heapIndices;

		public int Find( T value ) {
			if( FindRanker == null ) return -1;
			if( _count == 0 ) return -1;

			if( _heapIndices == null ) _heapIndices = new List<int>( 4 );
			_heapIndices.Clear();

			_heapIndices.Add( 0 );
			int resultIndex = -1;

			while( _heapIndices.Count > 0 ) {
				for( int i = _heapIndices.Count - 1; i >= 0; --i ) {
					var newIndex = _heapIndices[i];

					if( !Comparer( value, _heap[newIndex] ) ) {
						_heapIndices.RemoveAt( i );

						var leftIndex = PriorityQueueCommon.GetLeftChildIndex( newIndex );
						var rightIndex = PriorityQueueCommon.GetRightIndexFromLeft( leftIndex );

						if( leftIndex < _count ) { _heapIndices.Add( leftIndex ); ++i; }
						if( rightIndex < _count ) { _heapIndices.Add( rightIndex ); ++i; }
					}
					else {
						_heapIndices.RemoveAt( i );

						if( resultIndex == -1 )
							resultIndex = newIndex;
						else {
							if( FindRanker( _heap[resultIndex], _heap[newIndex] ) > 0 )
								resultIndex = newIndex;
						}
					}
				}
			}

			if( resultIndex == -1 ) return -1;

			return _heapToTrackingKeyMapping[resultIndex];
		}

		public int Enqueue( T value ) {
			EnsureCapacity( 1 );

			var i = _count;
			int trackingIndex = _trackingManager.Allocate();

			while( i > 0 ) {
				var parentIndex = PriorityQueueCommon.GetParentIndex( i );

				if( !Comparer( value, _heap[parentIndex] ) )
					break;

				_heap[i] = _heap[parentIndex];
				_trackingKeyToHeapMapping[_heapToTrackingKeyMapping[parentIndex]] = i; _heapToTrackingKeyMapping[i] = _heapToTrackingKeyMapping[parentIndex];

				i = parentIndex;
			}

			_heap[i] = value;
			_heapToTrackingKeyMapping[i] = trackingIndex; _trackingKeyToHeapMapping[trackingIndex] = i;
			++_count;

			return trackingIndex;
		}

		public T Dequeue() {
			return Remove( _heapToTrackingKeyMapping[0] );
		}

		public T Remove( int trackingIndex ) {
			if( _count == 0 ) return default( T );

			var heapIndex = _trackingKeyToHeapMapping[trackingIndex];
			if( !Assert.IsTrue( heapIndex >= 0 ) ) return default( T );

			_trackingManager.Deallocate( trackingIndex );

			var result = _heap[heapIndex];
			_trackingKeyToHeapMapping[trackingIndex] = -1;

			if( _count > 1 ) {
				var i = heapIndex;

				for( var leftChild = PriorityQueueCommon.GetLeftChildIndex( i ); leftChild < _count; leftChild = PriorityQueueCommon.GetLeftChildIndex( i ) ) {
					var rightChild = PriorityQueueCommon.GetRightIndexFromLeft( leftChild );
					var highestPriorityChild = rightChild < _count && Comparer( _heap[rightChild], _heap[leftChild] ) ? rightChild : leftChild;

					_heap[i] = _heap[highestPriorityChild];
					_trackingKeyToHeapMapping[_heapToTrackingKeyMapping[highestPriorityChild]] = i; _heapToTrackingKeyMapping[i] = _heapToTrackingKeyMapping[highestPriorityChild];

					i = highestPriorityChild;
				}

				if( i != _count - 1 ) {
					_heap[i] = _heap[_count - 1];
					_trackingKeyToHeapMapping[_heapToTrackingKeyMapping[_count - 1]] = i; _heapToTrackingKeyMapping[i] = _heapToTrackingKeyMapping[_count - 1];
				}

				_heapToTrackingKeyMapping[_count - 1] = -1;
			}

			--_count;
			return result;
		}

		public void EnsureCapacity( int count ) {
			var newCount = _count + count;

			if( newCount >= _heap.Length ) {
				if( !BitOperations.IsPowerOf2( newCount ) )
					newCount = BitOperations.NextPowerOf2( newCount );

				var heap = new[newCount] T;
				var heapToTrackingKeyMapping = new[newCount] int;
				var trackingKeyToHeapMapping = new[newCount] int;

				CommonCollectionOperations.Copy<T>( &heap[0], &_heap[0], _count );
				CommonCollectionOperations.Copy<int>( &heapToTrackingKeyMapping[0], &_heapToTrackingKeyMapping[0], _count );
				CommonCollectionOperations.Copy<int>( &trackingKeyToHeapMapping[0], &_trackingKeyToHeapMapping[0], _count );

				for( int i = _count; i < newCount; i++ ) {
					heapToTrackingKeyMapping[i] = -1;
					trackingKeyToHeapMapping[i] = -1;
				}

				_heap = heap;
				_heapToTrackingKeyMapping = heapToTrackingKeyMapping;
				_trackingKeyToHeapMapping = trackingKeyToHeapMapping;
			}
		}

		public T[] ToArray() {
			var result = new[_count] T;
			CommonCollectionOperations.Copy<T>( &result[0], &_heap[0], _count );
			return result;
		}

		public int Count { get { return _count; } }
		public int Capacity { get { return _heap.Length; } }

		public T Top { get { System.Diagnostics.Debug.Assert( _count > 0 ); return _heap[0]; } }
		public T Peek() { System.Diagnostics.Debug.Assert( _count > 0 ); return _heap[0]; }

		public Enumerator GetEnumerator() {
			return new Enumerator( this );
		}

		[EnumeratorAttribute]
		public struct Enumerator {
			private readonly declaringtype _parent;
			private int _index, _count;

			internal Enumerator( declaringtype parent ) {
				_index = -1;
				_parent = parent;
				_count = parent._count;
			}

			public bool MoveNext() {
				return ++_index < _count;
			}

			public T Current { get { return _parent[_index]; } }
		}
	}
}