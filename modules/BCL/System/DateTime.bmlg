//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System.Diagnostics;

namespace System {
	public enum DateTimeKind {
		Unspecified,
		Utc,   // UTC
		Local, // UTC [+ TimeZone offset [+ DST]]
	}

	public enum DayOfWeek : byte {
		Monday,
		Tuesday,
		Wednesday,
		Thursday,
		Friday,
		Saturday,
		Sunday,
	}

	public sealed partial struct DateTime {
		internal const long MaxTicks = 0x2BCA2875F4373FFFL;

		public static readonly DateTime MinValueUnspecified = new DateTime { _data = ( ulong ) DateTimeKind.Unspecified << 62 };
		public static readonly DateTime MaxValueUnspecified = new DateTime { _data = MaxTicks | ( ulong ) DateTimeKind.Unspecified << 62 };

		public static readonly DateTime MinValue = new DateTime { _data = ( ulong ) DateTimeKind.Utc << 62 };
		public static readonly DateTime MaxValue = new DateTime { _data = MaxTicks | ( ulong ) DateTimeKind.Utc << 62 };

		public static readonly DateTime MinValueLocal = new DateTime { _data = ( ulong ) DateTimeKind.Local << 62 };
		public static readonly DateTime MaxValueLocal = new DateTime { _data = MaxTicks | ( ulong ) DateTimeKind.Local << 62 };

		private ulong _data;

		public DateTime( long ticks ) {
			if( !Assert.IsTrue( ( ulong ) ticks <= MaxTicks ) ) ticks = 0;

			_data = ( ulong ) ticks;
		}

		public DateTime( long ticks, DateTimeKind kind ) {
			if( !Assert.IsTrue( ( ulong ) ticks <= MaxTicks ) ) ticks = 0;

			_data = ( ulong )( ticks | ( ( ( long ) kind ) << 62 ) );
		}

		public DateTime( int year, int month, int day ) {
			_data = ( ulong ) DateToTicks( year, month, day );
		}

		public DateTime( int year, int month, int day, int hour, int minute, int second ) {
			_data = ( ulong )( DateToTicks( year, month, day ) + TimeToTicks( hour, minute, second ) );
		}

		public DateTime( int year, int month, int day, int hour, int minute, int second, int millisecond ) {
			if( !Assert.IsFalse( millisecond < 0 || millisecond >= 1000 ) )
				millisecond = 0;

			var ticks = DateToTicks( year, month, day ) + TimeToTicks( hour, minute, second );
			ticks += millisecond * ( 10L * 1000 );

			if( !Assert.IsFalse( ticks < 0L || ticks > MaxTicks, "Bad combination of year/month/day/hour/minute/second/millisecond" ) )
				ticks = 0;

			_data = ( ulong ) ticks;
		}

		public DateTime( int year, int month, int day, DateTimeKind kind ) {
			long num = DateToTicks( year, month, day );
			_data = ( ulong )( num | ( ( ( long ) kind ) << 62 ) );
		}

		public DateTime( int year, int month, int day, int hour, int minute, int second, DateTimeKind kind ) {
			long num = DateToTicks( year, month, day ) + TimeToTicks( hour, minute, second );
			_data = ( ulong )( num | ( ( ( long ) kind ) << 62 ) );
		}

		public DateTime( int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind ) {
			if( !Assert.IsFalse( millisecond < 0 || millisecond >= 1000 ) )
				millisecond = 0;

			var ticks = DateToTicks( year, month, day ) + TimeToTicks( hour, minute, second );
			ticks += millisecond * ( 10L * 1000 );

			if( !Assert.IsFalse( ticks < 0L || ticks > MaxTicks, "Bad combination of year/month/day/hour/minute/second/millisecond" ) )
				ticks = 0;

			_data = ( ulong )( ticks | ( ( ( long ) kind ) << 62 ) );
		}

		public DateTimeKind Kind {
			get { return ( DateTimeKind )( _data >> 62 ); }
			set { _data = BitOperations.MergeBits( _data, value << 62UL, 0xC000000000000000UL ); }
		}

		public static bool IsLeapYear( int year ) {
			if( !Assert.IsFalse( year < 1 || year > 9999 ) )
				year = 0;

			if( year % 4 != 0 ) return false;
			if( year % 100 == 0 ) return year % 400 == 0;

			return true;
		}

		private static long DateToTicks( int year, int month, int day ) {
			if( !Assert.IsTrue( year >= 1 && year <= 9999 && month >= 1 && month <= 12 ) )
				return 0;

			var& daysInMonth = IsLeapYear( year ) ? PrimitiveTypesParser.TotalDaysInMonth366 : PrimitiveTypesParser.TotalDaysInMonth365;

			if( !Assert.IsTrue( day >= 1 && day <= daysInMonth[month] - daysInMonth[month - 1], "Bad combination of year/month/day" ) )
				return 0;

			--year;
			int totalDays = year * 365 + year / 4 - year / 100 + year / 400 + daysInMonth[month - 1] + day - 1;
			return totalDays * ( 10L * 1000 * 1000 * 60 * 60 * 24 );
		}

		internal static long TimeToTicks( int hour, int minute, int second ) {
			if( !Assert.IsFalse( hour < 0 || hour >= 24 || minute < 0 || minute >= 60 || second < 0 || second >= 60, "Bad combination of hour/minute/second" ) )
				return 0;

			var totalSeconds = hour * ( 60L * 60 ) + minute * 60L + second;
			if( !Assert.IsFalse( totalSeconds > 922337203685 || totalSeconds < -922337203685L ) )
				return 0;

			return ( long )( totalSeconds * 10000000UL );
		}

		public DateValues GetDateValues() { return new DateValues( ( ulong ) Ticks ); }

		public long Ticks { get { return ( long )( _data & 0x3FFFFFFFFFFFFFFFUL ); } }

		public int DayOfYear { get { return ( int ) GetDateValues().DayOfYear; } }
		public DayOfWeek DayOfWeek { get { return ( DayOfWeek )( Ticks / ( 10L * 1000 * 1000 * 60 * 60 * 24 ) % 7L ); } }

		private ulong KindBits { get { return _data & 0xC000000000000000UL; } }

		public int Year { get { return ( int ) GetDateValues().Year; } }
		public int Month { get { return ( int ) GetDateValues().Month; } }
		public int Day { get { return ( int ) GetDateValues().Day; } }

		public int Hour { get { return ( int )( ( Ticks / ( 60L * 60 * 1000 * 1000 * 10 ) ) % 24UL ); } }
		public int Minute { get { return ( int )( ( Ticks / ( 60L * 1000 * 1000 * 10 ) ) % 60L ); } }
		public int Second { get { return ( int )( ( Ticks / ( 1000L * 1000 * 10 ) ) % 60L ); } }
		public int Millisecond { get { return ( int )( ( Ticks / ( 1000L * 10 ) ) % 1000UL ); } }
		public int Microsecond { get { return ( int )( ( Ticks / 10 ) % 1000UL ); } }
		public int MicrosecondsWithMilliseconds { get { return ( int )( ( Ticks / 10 ) % 1000000UL ); } }

		/// Gets the date component
		public DateTime Date {
			get {
				long ticks = Ticks;
				return new DateTime { _data = ( ulong )( ( ticks - ( ticks % ( 10L * 1000 * 1000 * 60 * 60 * 24 ) ) ) | KindBits ) };
			}
		}

		/// Gets the time of day
		public TimeSpan TimeOfDay { get { return new TimeSpan( Ticks % ( 10L * 1000 * 1000 * 60 * 60 * 24 ) ); } }

		[Conditional( ConditionString = "DEBUG" )]
		private static void EnsureSameKind( [In] DateTime& left, [In] DateTime& right ) {
			Debug.Assert( left.Kind == right.Kind );
		}

		public static TimeSpan operator %( DateTime t1, TimeSpan t2 ) { return new TimeSpan( t1.Ticks % t2.Ticks ); }
		public static TimeDuration operator %( DateTime t1, TimeDuration t2 ) { return new TimeDuration( ( ulong ) t1.Ticks % t2.Ticks ); }

		public static TimeSpan operator -( [In] DateTime& left, [In] DateTime& right ) { EnsureSameKind( left, right ); return new TimeSpan( left.Ticks - right.Ticks ); }

		public static DateTime operator +( [In] DateTime& left, [In] TimeSpan& right ) { return new DateTime( left.Ticks + right.Ticks, left.Kind ); }
		public static DateTime operator -( [In] DateTime& left, [In] TimeSpan& right ) { return new DateTime( left.Ticks - right.Ticks, left.Kind ); }

		public static DateTime operator +( [In] DateTime& left, [In] TimeDuration& right ) { return new DateTime( left.Ticks + ( long ) right.Ticks, left.Kind ); }
		public static DateTime operator -( [In] DateTime& left, [In] TimeDuration& right ) { return new DateTime( left.Ticks - ( long ) right.Ticks, left.Kind ); }

		public static bool operator ==( [In] DateTime& left, [In] DateTime& right ) { EnsureSameKind( left, right ); return left.Ticks == right.Ticks; }
		public static bool operator !=( [In] DateTime& left, [In] DateTime& right ) { EnsureSameKind( left, right ); return left.Ticks != right.Ticks; }

		public static bool operator <( [In] DateTime& left, [In] DateTime& right ) { EnsureSameKind( left, right ); return left.Ticks < right.Ticks; }
		public static bool operator >( [In] DateTime& left, [In] DateTime& right ) { EnsureSameKind( left, right ); return left.Ticks > right.Ticks; }

		public static bool operator <=( [In] DateTime& left, [In] DateTime& right ) { EnsureSameKind( left, right ); return left.Ticks <= right.Ticks; }
		public static bool operator >=( [In] DateTime& left, [In] DateTime& right ) { EnsureSameKind( left, right ); return left.Ticks >= right.Ticks; }

		public static int DaysInMonth( int year, int month ) {
			if( !Assert.IsTrue( month >= 1 && month <= 12 ) ) return 0;

			var& daysInMonth = IsLeapYear( year ) ? PrimitiveTypesParser.TotalDaysInMonth366 : PrimitiveTypesParser.TotalDaysInMonth365;
			return daysInMonth[month] - daysInMonth[month - 1];
		}

		public static DateTime GetLastDayOfMonth( int year, int month ) {
			if( !Assert.IsTrue( year >= 1 && year <= 9999 && month >= 1 && month <= 12 ) ) return DateTime.MinValue;

			var dayOfYear = IsLeapYear( year ) ? PrimitiveTypesParser.TotalDaysInMonth366[month] : PrimitiveTypesParser.TotalDaysInMonth365[month];

			--year;
			int totalDays = year * 365 + year / 4 - year / 100 + year / 400 + dayOfYear - 1;
			return new DateTime( totalDays * ( 10L * 1000 * 1000 * 60 * 60 * 24 ) );
		}

		public static DateTime GetLastDayOfWeek( int year, int month, DayOfWeek dayOfWeek ) {
			var date = GetLastDayOfMonth( year, month );
			var lastDayOfWeek = date.DayOfWeek;

			if( lastDayOfWeek == dayOfWeek ) return date;
			return date.AddDays( dayOfWeek - lastDayOfWeek - ( lastDayOfWeek < dayOfWeek ? 7 : 0 ) );
		}

		public DateTime AddTicks( long value ) {
			var internalTicks = Ticks;

			if( !Assert.IsFalse( value > MaxTicks - internalTicks || value < -internalTicks ) )
				return this;

			return new DateTime { _data = cast<ulong>( ( internalTicks + value ) | KindBits ) };
		}

		public DateTime AddMicroseconds( long value ) { return AddTicks( value * 10L ); }
		public DateTime AddMilliseconds( long value ) { return AddTicks( value * ( 10L * 1000 ) ); }
		public DateTime AddSeconds( long value ) { return AddTicks( value * ( 10L * 1000 * 1000 ) ); }
		public DateTime AddMinutes( long value ) { return AddTicks( value * ( 10L * 1000 * 1000 * 60 ) ); }
		public DateTime AddHours( long value ) { return AddTicks( value * ( 10L * 1000 * 1000 * 60 * 60 ) ); }
		public DateTime AddDays( long value ) { return AddTicks( value * ( 10L * 1000 * 1000 * 60 * 60 * 24 ) ); }

		public bool TryAddMonths( thistype& result, int value ) {
			ulong resultTicks;
			var status = DateValues.TryAddMonths( resultTicks, ( ulong ) Ticks, value );
			if( !status ) return status;

			if( resultTicks > MaxTicks ) return false;

			result = new DateTime( ( long ) resultTicks, Kind );
			return true;
		}

		public thistype AddMonths( int value ) { thistype result; Assert.IsTrue( TryAddMonths( result, value ) ); return result; }

		public DateTime AddYears( int value ) { return AddMonths( value * 12 ); }

		public static DateTime Min( DateTime& left, DateTime& right ) { return left < right ? left : right; }
		public static DateTime Max( DateTime& left, DateTime& right ) { return left > right ? left : right; }

		public uint GetHashCode() { return _data.GetHashCode(); }

		// this='12:33:01' interval='00:00:05' ==> '12:33:05'
		public DateTime Ceil( TimeSpan interval ) {
			var result = this;
			var remainder = result % interval;

			result -= remainder;
			if( remainder.Ticks != 0 ) result += interval;

			return result;
		}

		public DateTime Ceil( TimeDuration interval ) {
			var result = this;
			var remainder = result % interval;

			result -= remainder;
			if( remainder.Ticks != 0 ) result += interval;

			return result;
		}

		// this='12:33:01' interval='00:00:05' ==> '12:33:00'
		public DateTime Floor( TimeSpan interval ) {
			var result = this;
			var remainder = result % interval;

			result -= remainder;

			return result;
		}

		public DateTime Floor( TimeDuration interval ) {
			var result = this;
			var remainder = result % interval;

			result -= remainder;

			return result;
		}

		public static bool IsDateValid( int year, int month, int day ) {
			if( ( uint ) year > 9999U ) return false;
			if( ( uint ) month - 1 > 11U ) return false;

			var& daysInMonth = IsLeapYear( ( int ) year ) ? PrimitiveTypesParser.TotalDaysInMonth366 : PrimitiveTypesParser.TotalDaysInMonth365;
			return day >= 1 && day <= daysInMonth[month] - daysInMonth[month - 1];
		}

		public static bool IsTimeValid( int hours, int minutes, int seconds ) {
			return ( uint ) hours < 24U && ( uint ) minutes < 60U && ( uint ) seconds < 60U;
		}

		public long ToUnixTimeSeconds() { return ( long )( Ticks / TimeSpan.TicksPerSecond - TimeDuration.Ticks_1970_1_1 / TimeSpan.TicksPerSecond ); }
		public long ToUnixTimeMilliseconds() { return ( long )( Ticks / TimeSpan.TicksPerMillisecond - TimeSpan.Ticks_1970_1_1 / TimeSpan.TicksPerMillisecond ); }

		public double ToUnixSecondsFractional() { return ( Ticks - 621355968000000000 ) / 10000000.0; }
		public double ToUnixMillisecondsFractional() { return ( Ticks - 621355968000000000 ) / 10000.0; }

		public static thistype Parse( CString input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf8String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf16String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf32String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }

		public static thistype Parse( CStringSpan input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf8StringSpan input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf16StringSpan input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf32StringSpan input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }

		public static thistype Parse( SbcsString input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( Utf8String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( Utf16String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( Utf32String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }

		public static Convert.ConversionResult TryParse( CString input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<byte>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( CUtf8String input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<byte>( input.GetChars(), input.ByteLength, value ); }
		public static Convert.ConversionResult TryParse( CUtf16String input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<char>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( CUtf32String input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<uint>( input.GetChars(), input.Length, value ); }

		public static Convert.ConversionResult TryParse( CStringSpan input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<byte>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( CUtf8StringSpan input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<byte>( input.GetChars(), input.ByteLength, value ); }
		public static Convert.ConversionResult TryParse( CUtf16StringSpan input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<char>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( CUtf32StringSpan input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<uint>( input.GetChars(), input.Length, value ); }

		public static Convert.ConversionResult TryParse( SbcsString input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<byte>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( Utf8String input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<byte>( input.GetChars(), input.ByteLength, value ); }
		public static Convert.ConversionResult TryParse( Utf16String input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<char>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( Utf32String input, thistype& value ) { return PrimitiveTypesParser.TryParseDateTime<uint>( input.GetChars(), input.Length, value ); }
	}
}