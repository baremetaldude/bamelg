//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System.Globalization;
using System.Runtime;

namespace System {
	public static partial struct PrimitiveTypesFormatter {
		public const int SingleDefaultPrecision = 7;
		public const int DoubleDefaultPrecision = 15;
		public const int Int8DefaultPrecision = 3;
		public const int UInt8DefaultPrecision = 3;
		public const int Int16DefaultPrecision = 5;
		public const int UInt16DefaultPrecision = 5;
		public const int Int32DefaultPrecision = 10;
		public const int UInt32DefaultPrecision = 10;
		public const int Int64DefaultPrecision = 19;
		public const int UInt64DefaultPrecision = 20;
		public const int DecimalDefaultPrecision = 100;

		const int DefaultExpPrecision = 6;
		const int _10pow8 = 100000000;
		const long _10pow16 = 10000000000000000;
		const ulong ULongDiv10pow8 = ulong.MaxValue / _10pow8;
		const ulong ULongMod10pow8 = 1 + ulong.MaxValue % _10pow8;

		const int DoubleBitsExponentShift = 52;
		const int DoubleBitsExponentMask = 0x7FF;
		const long DoubleBitsMantissaMask = 0xFFFFFFFFFFFFF;
		const int DecimalBitsScaleMask = 0x1F0000;

		// Save 388 stack bytes for Fibers
		[ThreadStatic]
		internal static Formatter Instance = new Formatter { _writeIndex = 0 };

		internal struct Formatter {
			public uint[4] _value;

			private bool _NaN;
			private bool _infinity;
			private bool _isCustomFormat;
			private bool _specifierIsUpper;
			private bool _positive;
			private char _specifier;
			internal int _precision;
			private int _defPrecision;

			private int _digitsLen;
			private int _offset;
			private int _decPointPos;

			internal byte[340] _buffer; // с запасом для double e+307 в FixedPoint форме
			internal int _writeIndex;
			internal CStringSpan GetTextBuffer() { return new CStringSpan( &_buffer[0], ( uint ) _writeIndex ); }

			public Formatter() {
				_writeIndex = 0;
			}

			public void Init() {
				_writeIndex = 0;
			}

			private int IntegerDigits {
				get { return _decPointPos > 0 ? _decPointPos : 1; }
			}

			private int DecimalDigits {
				get { return _digitsLen > _decPointPos ? _digitsLen - _decPointPos : 0; }
			}

			private bool IsFloatingSource {
				get { return _defPrecision == DoubleDefaultPrecision || _defPrecision == SingleDefaultPrecision; }
			}

			private bool IsZero {
				get { return _digitsLen == 0; }
			}

			private bool IsZeroInteger {
				get { return _digitsLen == 0 || _decPointPos <= 0; }
			}

			private void RoundPos( int pos ) {
				RoundBits( _digitsLen - pos );
			}

			private bool RoundDecimal( int decimals ) {
				return RoundBits( _digitsLen - _decPointPos - decimals );
			}

			internal bool _verbatimOutput = false;

			private bool RoundBits( int shift ) {
				if( shift <= 0 )
					return false;

				if( shift > _digitsLen ) {
					_digitsLen = 0;
					_decPointPos = 1;
					Memory.Fill( _value, 0, sizeof( _value ) );
					if( !_verbatimOutput ) _positive = true;
					return false;
				}

				shift += _offset;
				_digitsLen += _offset;
				while( shift > 8 ) {
					_value[0] = _value[1];
					_value[1] = _value[2];
					_value[2] = _value[3];
					_value[3] = 0;
					_digitsLen -= 8;
					shift -= 8;
				}

				shift = ( shift - 1 ) << 2;
				uint v = _value[0] >> shift;
				uint rem16 = v & 0xF;
				_value[0] = ( v ^ rem16 ) << shift;
				bool res = false;
				if( rem16 >= 0x5 ) {
					_value[0] |= ( int ) 0x99999999 >> ( 28 - shift );
					AddOneToDecHex();
					int newlen = DecHexLen();
					res = newlen != _digitsLen;
					_decPointPos = _decPointPos + newlen - _digitsLen;
					_digitsLen = newlen;
				}

				RemoveTrailingZeros();
				return res;
			}

			private void RemoveTrailingZeros() {
				_offset = CountTrailingZeros();
				_digitsLen -= _offset;

				if( _digitsLen == 0 ) {
					_offset = 0;
					_decPointPos = 1;
					if( !_verbatimOutput ) _positive = true;
				}
			}

			private void AddOneToDecHex() {
				if( _value[0] == 0x99999999 ) {
					_value[0] = 0;
					if( _value[1] == 0x99999999 ) {
						_value[1] = 0;
						if( _value[2] == 0x99999999 ) {
							_value[2] = 0;
							_value[3] = AddOneToDecHex( _value[3] );
						}
						else
							_value[2] = AddOneToDecHex( _value[2] );
					}
					else
						_value[1] = AddOneToDecHex( _value[1] );
				}
				else
					_value[0] = AddOneToDecHex( _value[0] );
			}

			// Assume val != 0x99999999
			private static uint AddOneToDecHex( uint val ) {
				if( ( val & 0xFFFF ) == 0x9999 )
					if( ( val & 0xFFFFFF ) == 0x999999 )
						if( ( val & 0xFFFFFFF ) == 0x9999999 )
							return val + 0x06666667;
						else
							return val + 0x00666667;
					else if( ( val & 0xFFFFF ) == 0x99999 )
						return val + 0x00066667;
					else
						return val + 0x00006667;
				else if( ( val & 0xFF ) == 0x99 )
					if( ( val & 0xFFF ) == 0x999 )
						return val + 0x00000667;
					else
						return val + 0x00000067;
				else if( ( val & 0xF ) == 0x9 )
					return val + 0x00000007;
				else
					return val + 1;
			}

			private int CountTrailingZeros() {
				if( _value[0] != 0 )
					return CountTrailingZeros( _value[0] );
				if( _value[1] != 0 )
					return CountTrailingZeros( _value[1] ) + 8;
				if( _value[2] != 0 )
					return CountTrailingZeros( _value[2] ) + 16;
				if( _value[3] != 0 )
					return CountTrailingZeros( _value[3] ) + 24;

				return _digitsLen;
			}

			private static int CountTrailingZeros( uint val ) {
				if( ( val & 0xFFFF ) == 0 )
					if( ( val & 0xFFFFFF ) == 0 )
						if( ( val & 0xFFFFFFF ) == 0 )
							return 7;
						else
							return 6;
					else if( ( val & 0xFFFFF ) == 0 )
						return 5;
					else
						return 4;
				else if( ( val & 0xFF ) == 0 )
					if( ( val & 0xFFF ) == 0 )
						return 3;
					else
						return 2;
				else if( ( val & 0xF ) == 0 )
					return 1;
				else
					return 0;
			}

			private void InitDecHexDigits( uint value ) {
				if( value >= _10pow8 ) {
					int div1 = ( int )( value / _10pow8 );
					value -= _10pow8 * ( uint ) div1;
					_value[1] = FastToDecHex( div1 );
				}
				_value[0] = ToDecHex( ( int ) value );
			}

			private void InitDecHexDigits( ulong value ) {
				if( value >= _10pow8 ) {
					long div1 = ( long )( value / _10pow8 );
					value -= _10pow8 * ( ulong ) div1;

					if( div1 >= _10pow8 ) {
						int div2 = ( int )( div1 / _10pow8 );
						div1 = div1 - div2 * ( long ) _10pow8;
						_value[2] = ToDecHex( div2 );
					}

					if( div1 != 0 )
						_value[1] = ToDecHex( ( int )( div1 ) );
				}

				if( value != 0 )
					_value[0] = ToDecHex( ( int ) value );
			}

			// Translate a decimal integer to hexadecimal digits.
			// The decimal integer is 96 digits and its value is hi * 2^64 + lo.
			// is the lower 64 bits.
			private void InitDecHexDigits( uint hi, ulong lo ) {
				if( hi == 0 ) {
					InitDecHexDigits( lo ); // Only the lower 64 bits matter.
					return;
				}

				// Compute (hi, lo) = (hi , lo) / HundredMillion.
				uint divhi = hi / _10pow8;
				ulong remhi = hi - divhi * _10pow8;
				ulong divlo = lo / _10pow8;
				ulong remlo = lo - divlo * _10pow8 + remhi * ULongMod10pow8;
				hi = divhi;
				lo = divlo + remhi * ULongDiv10pow8;
				divlo = remlo / _10pow8;
				remlo -= divlo * _10pow8;
				lo += divlo;
				_value[0] = ToDecHex( ( int ) remlo );

				// Divide hi * 2 ^ 64 + lo by HundredMillion using the fact that
				// hi < HundredMillion.
				divlo = lo / _10pow8;
				remlo = lo - divlo * _10pow8;
				lo = divlo;
				if( hi != 0 ) {
					lo += hi * ULongDiv10pow8;
					remlo += hi * ULongMod10pow8;
					divlo = remlo / _10pow8;
					lo += divlo;
					remlo -= divlo * _10pow8;
				}
				_value[1] = ToDecHex( ( int ) remlo );

				// Now we are left with 64 bits store in lo.
				if( lo >= _10pow8 ) {
					divlo = lo / _10pow8;
					lo -= divlo * _10pow8;
					_value[3] = ToDecHex( ( int ) divlo );
				}
				_value[2] = ToDecHex( ( int ) lo );
			}

			// Helper to translate an int in the range 0 .. 9999 to its
			// Hexadecimal digits representation.
			private static uint FastToDecHex( int val ) {
				if( val < 100 )
					return ( uint ) PackedDecimalDigitsTable[val];

				// Uses 2^19 (524288) to compute val / 100 for val < 10000.
				int v = ( val * 5243 ) >> 19;
				return ( ( uint ) PackedDecimalDigitsTable[v] << 8 ) | PackedDecimalDigitsTable[val - v * 100];
			}

			// Helper to translate an int in the range 0 .. 99999999 to its
			// Hexadecimal digits representation.
			private static uint ToDecHex( int val ) {
				uint res = 0;
				if( val >= 10000 ) {
					int v = val / 10000;
					val -= v * 10000;
					res = FastToDecHex( v ) << 16;
				}

				return res | FastToDecHex( val );
			}

			// Helper to count number of hexadecimal digits in a number.
			private static int FastDecHexLen( int val ) {
				if( val < 0x100 )
					if( val < 0x10 )
						return 1;
					else
						return 2;
				else if( val < 0x1000 )
					return 3;
				else
					return 4;
			}

			private static int DecHexLen( uint val ) {
				if( val < 0x10000 )
					return FastDecHexLen( ( int ) val );
				return 4 + FastDecHexLen( ( int )( val >> 16 ) );
			}

			// Count number of hexadecimal digits stored in _value
			private int DecHexLen() {
				if( _value[3] != 0 )
					return DecHexLen( _value[3] ) + 24;
				else if( _value[2] != 0 )
					return DecHexLen( _value[2] ) + 16;
				else if( _value[1] != 0 )
					return DecHexLen( _value[1] ) + 8;
				else if( _value[0] != 0 )
					return DecHexLen( _value[0] );
				else
					return 0;
			}

			// Compute the initial precision for rounding a floating number
			// according to the used format.
			private int InitialFloatingPrecision() {
				if( _specifier == 'R' )
					return _defPrecision + 2;
				if( _precision < _defPrecision )
					return _defPrecision;
				if( _specifier == 'G' )
					return Math.Min( _defPrecision + 2, _precision );
				if( _specifier == 'E' )
					return Math.Min( _defPrecision + 2, _precision + 1 );

				return _defPrecision;
			}

			public string FastIntegerToString( int value ) {
				if( value < 0 ) {
					value = -value;
					Append( '-' );
				}

				if( value >= 10000 ) {
					int v = value / 10000;
					FastAppendDigits( v, false );
					FastAppendDigits( value - v * 10000, true );
				}
				else
					FastAppendDigits( value, false );

				return ( string ) new CStringSpan( _buffer, ( uint ) _writeIndex );
			}

			public SbcsString ToSbcsString() { return SbcsString.FromSBCS( Buffer ); }
			public Utf8String ToUtf8String() { return Utf8String.FromSBCS( Buffer ); }
			public Utf16String ToUtf16String() { return Utf16String.FromSBCS( Buffer ); }
			public Utf32String ToUtf32String() { return Utf32String.FromSBCS( Buffer ); }

			public void AppendTo( StringBuilder builder ) { builder.AppendAscii( _buffer, _writeIndex ); }

			public CStringSpan Buffer { get { return new CStringSpan( _buffer, ( uint ) _writeIndex ); } }

			private void Multiply10( int count ) {
				if( count <= 0 || _digitsLen == 0 )
					return;

				_decPointPos += count;
			}

			private void Divide10( int count ) {
				if( count <= 0 || _digitsLen == 0 )
					return;

				_decPointPos -= count;
			}

			private void AppendIntegerStringWithGroupSeparator( int[] groups, SbcsString groupSeparator ) {
				if( IsZeroInteger ) {
					Append( '0' );
					return;
				}

				int total = 0;
				int groupIndex = 0;

				for( int i = 0; i < groups.Length; ++i ) {
					total += groups[i];
					if( total <= _decPointPos )
						groupIndex = i;
					else
						break;
				}

				if( groups.Length > 0 && total > 0 ) {
					int counter;
					int groupSize = groups[groupIndex];
					int fraction = _decPointPos > total ? _decPointPos - total : 0;
					if( groupSize == 0 ) {
						while( groupIndex >= 0 && groups[groupIndex] == 0 )
							--groupIndex;

						groupSize = fraction > 0 ? fraction : groups[groupIndex];
					}
					if( fraction == 0 )
						counter = groupSize;
					else {
						groupIndex += fraction / groupSize;
						counter = fraction % groupSize;
						if( counter == 0 )
							counter = groupSize;
						else
							++groupIndex;
					}

					for( int i = 0; ; ) {
						if( ( _decPointPos - i ) <= counter || counter == 0 ) {
							AppendDigits( _digitsLen - _decPointPos, _digitsLen - i );
							break;
						}

						AppendDigits( _digitsLen - i - counter, _digitsLen - i );
						i += counter;
						Append( groupSeparator );
						if( --groupIndex < groups.Length && groupIndex >= 0 )
							groupSize = groups[groupIndex];
						counter = groupSize;
					}
				}
				else {
					AppendDigits( _digitsLen - _decPointPos, _digitsLen );
				}
			}

			private void Append( char c ) {
				_buffer[_writeIndex++] = ( byte ) c;
			}

			private void Append( char c, int count ) {
				while( count-- > 0 )
					_buffer[_writeIndex++] = ( byte ) c;
			}

			internal void Append( SbcsString s ) {
				var slen = s.Length;
				for( var i = 0U; i < slen; ++i )
					_buffer[_writeIndex++] = s[( int ) i];
			}

			private void AppendExponent( int exponent, int minDigits ) {
				if( _specifierIsUpper || _specifier == 'R' )
					Append( 'E' );
				else
					Append( 'e' );

				if( exponent >= 0 )
					Append( '+' );
				else {
					Append( '-' );
					exponent = -exponent;
				}

				if( exponent == 0 )
					Append( '0', minDigits );
				else if( exponent < 10 ) {
					Append( '0', minDigits - 1 );
					Append( ( char )( '0' | exponent ) );
				}
				else {
					uint hexDigit = FastToDecHex( exponent );
					if( exponent >= 100 || minDigits == 3 )
						Append( ( char )( '0' | ( hexDigit >> 8 ) ) );
					Append( ( char )( '0' | ( ( hexDigit >> 4 ) & 0xF ) ) );
					Append( ( char )( '0' | ( hexDigit & 0xF ) ) );
				}
			}

			private void AppendOneDigit( int start ) {
				start += _offset;

				uint v;
				if( start < 0 )
					v = 0;
				else if( start < 8 )
					v = _value[0];
				else if( start < 16 )
					v = _value[1];
				else if( start < 24 )
					v = _value[2];
				else if( start < 32 )
					v = _value[3];
				else
					v = 0;

				v >>= ( start & 0x7 ) << 2;
				_buffer[_writeIndex++] = ( byte )( '0' | v & 0xF );
			}

			private void FastAppendDigits( int val, bool force ) {
				int i = _writeIndex;
				int digits;
				if( force || val >= 100 ) {
					int v = ( val * 5243 ) >> 19;
					digits = PackedDecimalDigitsTable[v];
					if( force || val >= 1000 )
						_buffer[i++] = ( byte )( '0' | digits >> 4 );
					_buffer[i++] = ( byte )( '0' | ( digits & 0xF ) );
					digits = PackedDecimalDigitsTable[val - v * 100];
				}
				else
					digits = PackedDecimalDigitsTable[val];

				if( force || val >= 10 )
					_buffer[i++] = ( byte )( '0' | digits >> 4 );
				_buffer[i++] = ( byte )( '0' | ( digits & 0xF ) );
				_writeIndex = i;
			}

			private void AppendDigits( int start, int end ) {
				if( start >= end )
					return;

				int i = _writeIndex + ( end - start );
				_writeIndex = i;

				end += _offset;
				start += _offset;

				for( int next = start + 8 - ( start & 0x7 ); ; start = next, next += 8 ) {
					uint v;
					if( next == 8 )
						v = _value[0];
					else if( next == 16 )
						v = _value[1];
					else if( next == 24 )
						v = _value[2];
					else if( next == 32 )
						v = _value[3];
					else
						v = 0;
					v >>= ( start & 0x7 ) << 2;
					if( next > end )
						next = end;

					_buffer[--i] = ( byte )( '0' | v & 0xF );
					switch( next - start ) {
						case 8:
							_buffer[--i] = ( byte )( '0' | ( v >>= 4 ) & 0xF );
							goto case 7;
						case 7:
							_buffer[--i] = ( byte )( '0' | ( v >>= 4 ) & 0xF );
							goto case 6;
						case 6:
							_buffer[--i] = ( byte )( '0' | ( v >>= 4 ) & 0xF );
							goto case 5;
						case 5:
							_buffer[--i] = ( byte )( '0' | ( v >>= 4 ) & 0xF );
							goto case 4;
						case 4:
							_buffer[--i] = ( byte )( '0' | ( v >>= 4 ) & 0xF );
							goto case 3;
						case 3:
							_buffer[--i] = ( byte )( '0' | ( v >>= 4 ) & 0xF );
							goto case 2;
						case 2:
							_buffer[--i] = ( byte )( '0' | ( v >>= 4 ) & 0xF );
							goto case 1;
						case 1:
							if( next == end )
								return;
							continue;
					}
				}
			}

			private void AppendIntegerString( int minLength ) {
				if( _decPointPos <= 0 ) {
					Append( '0', minLength );
					return;
				}

				if( _decPointPos < minLength )
					Append( '0', minLength - _decPointPos );

				AppendDigits( _digitsLen - _decPointPos, _digitsLen );
			}

			private void AppendDecimalString( int precision ) {
				AppendDigits( _digitsLen - precision - _decPointPos, _digitsLen - _decPointPos );
			}

			private void InitBinary( uint value ) {
				switch( _defPrecision ) {
					case Int8DefaultPrecision: value = ( byte ) value; break;
					case Int16DefaultPrecision: value = ( ushort ) value; break;
				}

				if( value == 0 ) {
					Append( '0', _precision > 0 ? _precision : 1 );
					return;
				}

				var upperBit = 31 - BitOperations.CountLeadingZeros( value );
				var mask = 1 << upperBit;

				if( _precision != -1 && _precision > upperBit + 1 )
					Append( '0', _precision - upperBit - 1 );

				for( int i = 0; i <= upperBit; ++i, mask >>= 1 )
					Append( ( value & mask ) != 0 ? '1' : '0' );
			}

			private void InitBinary( ulong value ) {
				switch( _defPrecision ) {
					case Int8DefaultPrecision: value = ( byte ) value; break;
					case Int16DefaultPrecision: value = ( ushort ) value; break;
					case Int32DefaultPrecision: value = ( uint ) value; break;
				}

				if( value == 0 ) {
					Append( '0', _precision > 0 ? _precision : 1 );
					return;
				}

				var upperBit = ( int )( 63 - BitOperations.CountLeadingZeros( value ) );
				var mask = 1L << upperBit;

				if( _precision != -1 && _precision > upperBit + 1 )
					Append( '0', _precision - upperBit - 1 );

				for( int i = 0; i <= upperBit; ++i, mask >>= 1 )
					Append( ( value & mask ) != 0 ? '1' : '0' );
			}

			private void InitHex( uint value ) {
				switch( _defPrecision ) {
					case Int8DefaultPrecision: value = ( byte ) value; break;
					case Int16DefaultPrecision: value = ( ushort ) value; break;
				}

				_value[0] = value;
				_value[1] = 0;
				_decPointPos = _digitsLen = DecHexLen();
				if( value == 0 )
					_decPointPos = 1;
			}

			private void InitHex( ulong value ) {
				switch( _defPrecision ) {
					case Int8DefaultPrecision: value = ( byte ) value; break;
					case Int16DefaultPrecision: value = ( ushort ) value; break;
					case Int32DefaultPrecision: value = ( uint ) value; break;
				}

				_value[0] = ( uint ) value;
				_value[1] = ( uint )( value >> 32 );
				_decPointPos = _digitsLen = DecHexLen();
				if( value == 0 )
					_decPointPos = 1;
			}

			private void Init( string format ) {
				_writeIndex = 0;
				Memory.Fill( _value, 0, sizeof( _value ) );
				_offset = 0;
				_NaN = _infinity = false;
				_isCustomFormat = false;
				_specifierIsUpper = true;
				_precision = -1;

				if( format == null || format.Length == 0 ) {
					_specifier = 'G';
					return;
				}

				var parseIndex = 0U;
				char specifier = format[parseIndex];

				if( _verbatimOutput = specifier == '@' ) {
					if( format.Length == 1 ) {
						_specifier = 'G';
						return;
					}

					++parseIndex;
					specifier = format[parseIndex];
				}

				if( specifier >= 'a' && specifier <= 'z' ) {
					specifier = ( char )( specifier - 'a' + 'A' );
					_specifierIsUpper = false;
				}
				else if( specifier < 'A' || specifier > 'Z' ) {
					_isCustomFormat = true;
					_specifier = '0';
					return;
				}

				_specifier = specifier; ++parseIndex;

				if( parseIndex + 1 < format.Length && format[parseIndex].IsDigitAscii && format[parseIndex + 1].IsDigitAscii ) {
					var num = ( ushort )( format[parseIndex] - '0' );
					var num2 = ( ushort )( format[parseIndex + 1] - '0' );

					_precision = num * 10 + num2;
				}
				else if( parseIndex < format.Length && format[parseIndex].IsDigitAscii ) {
					_precision = format[parseIndex] - '0';
				}
			}

			public void Init( string format, int value, int defPrecision ) {
				Init( format );
				_defPrecision = defPrecision;
				_positive = value >= 0;

				if( _specifier == 'X' ) {
					InitHex( ( uint ) value );
					return;
				}

				if( _specifier == 'B' ) {
					InitBinary( ( uint ) value );
					return;
				}

				if( value < 0 )
					value = -value;
				InitDecHexDigits( ( uint ) value );
				_decPointPos = _digitsLen = DecHexLen();
			}

			public void Init( string format, uint value, int defPrecision ) {
				Init( format );
				_defPrecision = defPrecision;
				_positive = true;

				if( _specifier == 'X' ) {
					InitHex( value );
					return;
				}

				if( _specifier == 'B' ) {
					InitBinary( value );
					return;
				}

				InitDecHexDigits( value );
				_decPointPos = _digitsLen = DecHexLen();
			}

			public void Init( string format, long value, int defPrecision ) {
				Init( format );
				_defPrecision = defPrecision;
				_positive = value >= 0;

				if( _specifier == 'X' ) {
					InitHex( ( ulong ) value );
					return;
				}

				if( _specifier == 'B' ) {
					InitBinary( ( ulong ) value );
					return;
				}

				if( value < 0 )
					value = -value;

				InitDecHexDigits( ( ulong ) value );
				_decPointPos = _digitsLen = DecHexLen();
			}

			public void Init( string format, ulong value, int defPrecision ) {
				Init( format );
				_defPrecision = defPrecision;
				_positive = true;

				if( _specifier == 'X' ) {
					InitHex( value );
					return;
				}

				if( _specifier == 'B' ) {
					InitBinary( value );
					return;
				}

				InitDecHexDigits( value );
				_decPointPos = _digitsLen = DecHexLen();
			}

			public bool InitDouble( string format, double value, int defPrecision ) {
				Init( format );

				var bits = bitcast<long>( value );
				_defPrecision = defPrecision;
				_positive = bits >= 0;
				bits &= long.MaxValue;

				if( bits == 0 ) {
					_decPointPos = 1;
					_digitsLen = 0;
					if( !_verbatimOutput ) _positive = true;
					return true;
				}

				int e = ( int )( bits >> DoubleBitsExponentShift );
				long m = bits & DoubleBitsMantissaMask;

				if( e == DoubleBitsExponentMask ) {
					var isNan = m != 0;
					if( isNan ) { Append( "NaN" ); return false; }

					var isInfinity = m == 0;
					if( isInfinity ) { Append( _positive ? ( SbcsString ) "Infinity" : ( SbcsString ) "-Infinity" ); return false; }

					return false;
				}

				int expAdjust = 0;
				if( e == 0 ) {
					// We need 'm' to be large enough so we won't lose precision.
					e = 1;
					int scale = GetScaleOrder( m );
					if( scale < DoubleDefaultPrecision ) {
						expAdjust = scale - DoubleDefaultPrecision;
						m *= TenPowersTable[-expAdjust];
					}
				}
				else {
					m = ( m + DoubleBitsMantissaMask + 1 ) * 10;
					expAdjust = -1;
				}

				// multiply the mantissa by 10 ^ N
				ulong lo = ( uint ) m;
				ulong hi = ( ulong ) m >> 32;
				ulong lo2 = MantissaBitsTable[e];
				ulong hi2 = lo2 >> 32;
				lo2 = ( uint ) lo2;
				ulong mm = hi * lo2 + lo * hi2 + ( ( lo * lo2 ) >> 32 );
				long res = ( long )( hi * hi2 + ( mm >> 32 ) );

				while( res < _10pow16 ) {
					mm = ( mm & uint.MaxValue ) * 10;
					res = res * 10 + ( long )( mm >> 32 );
					--expAdjust;
				}

				if( ( mm & 0x80000000 ) != 0 )
					++res;

				int order = DoubleDefaultPrecision + 2;
				_decPointPos = TensExponentTable[e] + expAdjust + order;

				// Rescale 'res' to the initial precision (15-17 for doubles).
				int initialPrecision = InitialFloatingPrecision();
				if( order > initialPrecision ) {
					long val = TenPowersTable[order - initialPrecision];
					res = ( res + ( val >> 1 ) ) / val;
					order = initialPrecision;
				}

				if( res >= TenPowersTable[order] ) {
					++order;
					++_decPointPos;
				}

				InitDecHexDigits( ( ulong ) res );
				_offset = CountTrailingZeros();
				_digitsLen = order - _offset;

				return true;
			}

			public void ApplyFormat( string format ) {
				switch( _specifier ) {
					// case 'C': return FormatCurrency( _precision );
					case 'D': FormatDecimal( _precision ); break;
					case 'E': FormatExponential( _precision ); break;
					case 'F': FormatFixedPoint( _precision ); break;
					case 'G': FormatGeneral( _precision ); break;

					case 'N': FormatNumber( _precision ); break;
					// case 'P': return FormatPercent( _precision );
					case 'X': FormatHexadecimal(); break;
					case 'B': FormatBinary(); break;
					
					default:
						// if( _isCustomFormat )
						//	return FormatCustom( format );
						
						Assert.Fail( "The specified format '" + format + "' is invalid" );
						break;
				}
			}

			public void FormatNumber( int precision ) {
				precision = precision >= 0 ? precision : 2;
				RoundDecimal( precision );

				if( !_positive ) {
					Append( '-' );
					// switch( nfi.NumberNegativePattern )
					// {
					// case 0:
					// Append( '(' );
					// break;
					// case 1:
					// Append( nfi.NegativeSign );
					// break;
					// case 2:
					// Append( nfi.NegativeSign );
					// Append( ' ' );
					// break;
					// }
				}

				// AppendIntegerStringWithGroupSeparator( nfi.NumberGroupSizes, nfi.NumberGroupSeparator );

				if( precision > 0 ) {
					Append( '.' );
					AppendDecimalString( precision );
				}

				if( !_positive ) {
					// switch( nfi.NumberNegativePattern )
					// {
					// case 0:
					// Append( ')' );
					// break;
					// case 3:
					// Append( nfi.NegativeSign );
					// break;
					// case 4:
					// Append( ' ' );
					// Append( nfi.NegativeSign );
					// break;
					// }
				}
			}

			public void FormatDecimal( int precision ) {
				if( precision < _digitsLen )
					precision = _digitsLen;

				if( precision == 0 ) {
					Append( '0' );
					return;
				}

				if( !_positive )
					Append( '-' );

				AppendDigits( 0, precision );
			}

			public void FormatHexadecimal() {
				int size = Math.Max( _precision, _decPointPos );
				var digits = _specifierIsUpper ? HexDigitsUpper : HexDigitsLower;

				_writeIndex = size;
				ulong val = _value[0] | ( ( ulong ) _value[1] << 32 );

				while( size > 0 ) {
					_buffer[--size] = ( byte ) digits[( byte ) val & 0xF];
					val >>= 4;
				}
			}

			public void FormatBinary() {
			}

			public void FormatFixedPoint( int precision ) {
				if( precision == -1 )
					precision = 2;

				RoundDecimal( precision );

				if( !_positive )
					Append( '-' );

				AppendIntegerString( IntegerDigits );

				if( precision > 0 ) {
					Append( '.' );
					AppendDecimalString( precision );
				}
			}

			public void FormatGeneral( int precision ) {
				bool enableExp;

				if( precision == -1 ) {
					enableExp = IsFloatingSource;
					precision = _defPrecision;
				}
				else {
					enableExp = true;
					if( precision == 0 )
						precision = _defPrecision;
					RoundPos( precision );
				}

				int intDigits = _decPointPos;
				int digits = _digitsLen;
				int decDigits = digits - intDigits;

				if( ( intDigits > precision || intDigits <= -4 ) && enableExp ) {
					FormatExponential( digits - 1, 2 );
					return;
				}

				if( decDigits < 0 )
					decDigits = 0;
				if( intDigits < 0 )
					intDigits = 0;

				if( !_positive )
					Append( '-' );

				if( intDigits == 0 )
					Append( '0' );
				else
					AppendDigits( digits - intDigits, digits );

				if( decDigits > 0 ) {
					Append( '.' );
					AppendDigits( 0, decDigits );
				}
			}

			public void FormatExponential( int precision ) {
				if( precision == -1 )
					precision = DefaultExpPrecision;

				RoundPos( precision + 1 );
				FormatExponential( precision, 3 );
			}

			private void FormatExponential( int precision, int expDigits ) {
				int decDigits = _decPointPos;
				int digits = _digitsLen;
				int exponent = decDigits - 1;
				decDigits = _decPointPos = 1;

				if( !_positive )
					Append( '-' );

				AppendOneDigit( digits - 1 );

				if( precision > 0 ) {
					Append( '.' );
					AppendDigits( digits - precision - 1, digits - _decPointPos );
				}

				AppendExponent( exponent, expDigits );
			}

			public void FormatInt8( sbyte value ) {
				FastIntegerToString( value );
			}

			public void FormatUInt8( byte value ) {
				FastIntegerToString( value );
			}

			public void FormatInt16( short value ) {
				FastIntegerToString( value );
			}

			public void FormatUInt16( ushort value ) {
				FastIntegerToString( value );
			}

			public void FormatInt32( int value ) {
				if( value >= _10pow8 || value <= -_10pow8 ) {
					Init( ( string ) null, value, Int32DefaultPrecision );
					FormatDecimal( -1 );
				}
				else
					FastIntegerToString( value );
			}

			public void FormatUInt32( uint value ) {
				if( value >= _10pow8 ) {
					Init( ( string ) null, value, UInt32DefaultPrecision );
					FormatDecimal( -1 );
				}
				else
					FastIntegerToString( ( int ) value );
			}

			public void FormatInt64( long value ) {
				if( value >= _10pow8 || value <= -_10pow8 ) {
					Init( ( string ) null, value, Int64DefaultPrecision );
					FormatDecimal( -1 );
				}
				else
					FastIntegerToString( ( int ) value );
			}

			public void FormatUInt64( ulong value ) {
				if( value >= _10pow8 ) {
					Init( ( string ) null, value, UInt64DefaultPrecision );
					FormatDecimal( -1 );
				}
				else
					FastIntegerToString( ( int ) value );
			}

			public void FormatSingleIEEE754( double value ) {
				if( InitDouble( null, value, SingleDefaultPrecision ) )
					FormatGeneral( -1 );
			}

			public void FormatDoubleIEEE754( double value ) {
				if( InitDouble( null, value, DoubleDefaultPrecision ) )
					FormatGeneral( -1 );
			}
		}

		public static SbcsString FormatBoolSbcs( bool value ) { return value ? ( SbcsString ) "true" : ( SbcsString ) "false"; }
		public static Utf8String FormatBoolUtf8( bool value ) { return value ? ( Utf8String ) "true" : ( Utf8String ) "false"; }
		public static Utf16String FormatBoolUtf16( bool value ) { return value ? ( Utf16String ) "true" : ( Utf16String ) "false"; }
		public static Utf32String FormatBoolUtf32( bool value ) { return value ? ( Utf32String ) "true" : ( Utf32String ) "false"; }

		public static string FormatChar( char value ) {
			return new string( value, 1 );
		}

		public static SbcsString FormatInt8Sbcs( sbyte value ) { Instance.Init(); Instance.FormatInt8( value ); return Instance.ToSbcsString(); }
		public static Utf8String FormatInt8Utf8( sbyte value ) { Instance.Init(); Instance.FormatInt8( value ); return Instance.ToUtf8String(); }
		public static Utf16String FormatInt8Utf16( sbyte value ) { Instance.Init(); Instance.FormatInt8( value ); return Instance.ToUtf16String(); }
		public static Utf32String FormatInt8Utf32( sbyte value ) { Instance.Init(); Instance.FormatInt8( value ); return Instance.ToUtf32String(); }

		public static SbcsString FormatUInt8Sbcs( byte value ) { Instance.Init(); Instance.FormatUInt8( value ); return Instance.ToSbcsString(); }
		public static Utf8String FormatUInt8Utf8( byte value ) { Instance.Init(); Instance.FormatUInt8( value ); return Instance.ToUtf8String(); }
		public static Utf16String FormatUInt8Utf16( byte value ) { Instance.Init(); Instance.FormatUInt8( value ); return Instance.ToUtf16String(); }
		public static Utf32String FormatUInt8Utf32( byte value ) { Instance.Init(); Instance.FormatUInt8( value ); return Instance.ToUtf32String(); }

		public static SbcsString FormatInt16Sbcs( short value ) { Instance.Init(); Instance.FormatInt16( value ); return Instance.ToSbcsString(); }
		public static Utf8String FormatInt16Utf8( short value ) { Instance.Init(); Instance.FormatInt16( value ); return Instance.ToUtf8String(); }
		public static Utf16String FormatInt16Utf16( short value ) { Instance.Init(); Instance.FormatInt16( value ); return Instance.ToUtf16String(); }
		public static Utf32String FormatInt16Utf32( short value ) { Instance.Init(); Instance.FormatInt16( value ); return Instance.ToUtf32String(); }

		public static SbcsString FormatUInt16Sbcs( ushort value ) { Instance.Init(); Instance.FormatUInt16( value ); return Instance.ToSbcsString(); }
		public static Utf8String FormatUInt16Utf8( ushort value ) { Instance.Init(); Instance.FormatUInt16( value ); return Instance.ToUtf8String(); }
		public static Utf16String FormatUInt16Utf16( ushort value ) { Instance.Init(); Instance.FormatUInt16( value ); return Instance.ToUtf16String(); }
		public static Utf32String FormatUInt16Utf32( ushort value ) { Instance.Init(); Instance.FormatUInt16( value ); return Instance.ToUtf32String(); }

		public static SbcsString FormatInt32Sbcs( int value ) { Instance.Init(); Instance.FormatInt32( value ); return Instance.ToSbcsString(); }
		public static Utf8String FormatInt32Utf8( int value ) { Instance.Init(); Instance.FormatInt32( value ); return Instance.ToUtf8String(); }
		public static Utf16String FormatInt32Utf16( int value ) { Instance.Init(); Instance.FormatInt32( value ); return Instance.ToUtf16String(); }
		public static Utf32String FormatInt32Utf32( int value ) { Instance.Init(); Instance.FormatInt32( value ); return Instance.ToUtf32String(); }

		public static SbcsString FormatUInt32Sbcs( uint value ) { Instance.Init(); Instance.FormatUInt32( value ); return Instance.ToSbcsString(); }
		public static Utf8String FormatUInt32Utf8( uint value ) { Instance.Init(); Instance.FormatUInt32( value ); return Instance.ToUtf8String(); }
		public static Utf16String FormatUInt32Utf16( uint value ) { Instance.Init(); Instance.FormatUInt32( value ); return Instance.ToUtf16String(); }
		public static Utf32String FormatUInt32Utf32( uint value ) { Instance.Init(); Instance.FormatUInt32( value ); return Instance.ToUtf32String(); }

		public static SbcsString FormatInt64Sbcs( long value ) { Instance.Init(); Instance.FormatInt64( value ); return Instance.ToSbcsString(); }
		public static Utf8String FormatInt64Utf8( long value ) { Instance.Init(); Instance.FormatInt64( value ); return Instance.ToUtf8String(); }
		public static Utf16String FormatInt64Utf16( long value ) { Instance.Init(); Instance.FormatInt64( value ); return Instance.ToUtf16String(); }
		public static Utf32String FormatInt64Utf32( long value ) { Instance.Init(); Instance.FormatInt64( value ); return Instance.ToUtf32String(); }

		public static SbcsString FormatUInt64Sbcs( ulong value ) { Instance.Init(); Instance.FormatUInt64( value ); return Instance.ToSbcsString(); }
		public static Utf8String FormatUInt64Utf8( ulong value ) { Instance.Init(); Instance.FormatUInt64( value ); return Instance.ToUtf8String(); }
		public static Utf16String FormatUInt64Utf16( ulong value ) { Instance.Init(); Instance.FormatUInt64( value ); return Instance.ToUtf16String(); }
		public static Utf32String FormatUInt64Utf32( ulong value ) { Instance.Init(); Instance.FormatUInt64( value ); return Instance.ToUtf32String(); }

		public static string FormatInt8Hex( sbyte value ) {
			Instance.Init();
			Instance.Init( "X", ( uint ) value, UInt8DefaultPrecision );
			Instance._precision = 2;
			Instance.FormatHexadecimal();
			return Instance.ToUtf16String();
		}

		public static string FormatInt16Hex( short value ) {
			Instance.Init();
			Instance.Init( "X", ( uint ) value, UInt16DefaultPrecision );
			Instance._precision = 4;
			Instance.FormatHexadecimal();
			return Instance.ToUtf16String();
		}

		public static string FormatInt32Hex( int value ) {
			Instance.Init();
			Instance.Init( "X", ( uint ) value, UInt32DefaultPrecision );
			Instance._precision = 8;
			Instance.FormatHexadecimal();
			return Instance.ToUtf16String();
		}

		public static string FormatInt64Hex( long value ) {
			Instance.Init();
			Instance.Init( "X", ( ulong ) value, UInt64DefaultPrecision );
			Instance._precision = 16;
			Instance.FormatHexadecimal();
			return Instance.ToUtf16String();
		}

		public static string FormatIntPtrHex( intptr value ) {
			Instance.Init();
			Instance.Init( "X", ( ulong ) value, UInt64DefaultPrecision );
			Instance._precision = sizeof( intptr ) * 2;
			Instance.FormatHexadecimal();
			return Instance.ToUtf16String();
		}

		public static void FormatInteger( StringBuilder builder, string format, sbyte value ) { Instance.Init( format, ( int ) value, Int8DefaultPrecision ); Instance.ApplyFormat( format ); Instance.AppendTo( builder ); }
		public static void FormatInteger( StringBuilder builder, string format, byte value ) { Instance.Init( format, ( int ) value, UInt8DefaultPrecision ); Instance.ApplyFormat( format ); Instance.AppendTo( builder ); }
		public static void FormatInteger( StringBuilder builder, string format, short value ) { Instance.Init( format, ( int ) value, Int16DefaultPrecision ); Instance.ApplyFormat( format ); Instance.AppendTo( builder ); }
		public static void FormatInteger( StringBuilder builder, string format, ushort value ) { Instance.Init( format, ( int ) value, UInt16DefaultPrecision ); Instance.ApplyFormat( format ); Instance.AppendTo( builder ); }
		public static void FormatInteger( StringBuilder builder, string format, int value ) { Instance.Init( format, ( int ) value, Int32DefaultPrecision ); Instance.ApplyFormat( format ); Instance.AppendTo( builder ); }
		public static void FormatInteger( StringBuilder builder, string format, uint value ) { Instance.Init( format, ( uint ) value, UInt32DefaultPrecision ); Instance.ApplyFormat( format ); Instance.AppendTo( builder ); }
		public static void FormatInteger( StringBuilder builder, string format, long value ) { Instance.Init( format, ( long ) value, Int64DefaultPrecision ); Instance.ApplyFormat( format ); Instance.AppendTo( builder ); }
		public static void FormatInteger( StringBuilder builder, string format, ulong value ) { Instance.Init( format, ( ulong ) value, UInt64DefaultPrecision ); Instance.ApplyFormat( format ); Instance.AppendTo( builder ); }
		public static void FormatDouble( StringBuilder builder, string format, float value ) { if( Instance.InitDouble( format, value, SingleDefaultPrecision ) ) Instance.ApplyFormat( format ); Instance.AppendTo( builder ); }
		public static void FormatDouble( StringBuilder builder, string format, double value ) { if( Instance.InitDouble( format, value, DoubleDefaultPrecision ) ) Instance.ApplyFormat( format ); Instance.AppendTo( builder ); }

		public static string FormatUInt8Hex( byte value ) { return FormatInt8Hex( bitcast<sbyte>( value ) ); }
		public static string FormatUInt16Hex( ushort value ) { return FormatInt16Hex( bitcast<short>( value ) ); }
		public static string FormatUInt32Hex( uint value ) { return FormatInt32Hex( bitcast<int>( value ) ); }
		public static string FormatUInt64Hex( ulong value ) { return FormatInt64Hex( bitcast<long>( value ) ); }
		public static string FormatUIntPtrHex( uintptr value ) { return FormatIntPtrHex( bitcast<intptr>( value ) ); }

		private static double[9] Exponent10 = new double[9] { 1E+1, 1E+2, 1E+4, 1E+8, 1E+16, 1E+32, 1E+64, 1E+128, 1E+256 };
		private static double[9] InverseExponent10 = new double[9] { 1E-1, 1E-2, 1E-4, 1E-8, 1E-16, 1E-32, 1E-64, 1E-128, 1E-256 };

		public static SbcsString FormatSingleIEEE754Sbcs( double value ) { Instance.Init(); Instance.FormatSingleIEEE754( value ); return Instance.ToSbcsString(); }
		public static Utf8String FormatSingleIEEE754Utf8( double value ) { Instance.Init(); Instance.FormatSingleIEEE754( value ); return Instance.ToUtf8String(); }
		public static Utf16String FormatSingleIEEE754Utf16( double value ) { Instance.Init(); Instance.FormatSingleIEEE754( value ); return Instance.ToUtf16String(); }
		public static Utf32String FormatSingleIEEE754Utf32( double value ) { Instance.Init(); Instance.FormatSingleIEEE754( value ); return Instance.ToUtf32String(); }

		public static SbcsString FormatDoubleIEEE754Sbcs( double value ) { Instance.Init(); Instance.FormatDoubleIEEE754( value ); return Instance.ToSbcsString(); }
		public static Utf8String FormatDoubleIEEE754Utf8( double value ) { Instance.Init(); Instance.FormatDoubleIEEE754( value ); return Instance.ToUtf8String(); }
		public static Utf16String FormatDoubleIEEE754Utf16( double value ) { Instance.Init(); Instance.FormatDoubleIEEE754( value ); return Instance.ToUtf16String(); }
		public static Utf32String FormatDoubleIEEE754Utf32( double value ) { Instance.Init(); Instance.FormatDoubleIEEE754( value ); return Instance.ToUtf32String(); }

		private static byte[24] _12hourMapping = { 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };

		public static void FormatDateTime( StringBuilder builder, string format, DateTime value ) {
			int year, dayOfYear, month, day;

			switch( format ) {
				case "u":
				case "U":
					value = value.ToUniversalTime();
					break;
			}

			value.GetDateValues( year, dayOfYear, month, day );

			var hour = value.Hour;
			var minute = value.Minute;
			var second = value.Second;

			var customFormatStartPos = 0U;
			if( !format.StartsWith( '%' ) )
				switch( format ) {
					// short date
					case "d":
						[CheckAllEnumValues]
						switch( CultureInfo.Current.Kind ) {
							case CultureInfo.CultureKind.EN: // "1/5/2013"
								builder.Append( month );
								builder.Append( '/' );
								builder.Append( day );
								builder.Append( '/' );
								builder.Append( year );
								break;

							case CultureInfo.CultureKind.RU: // "05.01.2013"
							case CultureInfo.CultureKind.DE: // "05.01.2013"
							case CultureInfo.CultureKind.FR: // "05/01/2013"
							case CultureInfo.CultureKind.UK: // "05.01.2013"
								builder.Append( day, "D2" );
								builder.Append( CultureInfo.Current.DateTimeFormat.DateSeparator );
								builder.Append( month, "D2" );
								builder.Append( CultureInfo.Current.DateTimeFormat.DateSeparator );
								builder.Append( year );
								break;
						}
						return;

					// long date
					case "D":
						[CheckAllEnumValues]
						switch( CultureInfo.Current.Kind ) {
							case CultureInfo.CultureKind.EN: // "Saturday, January 05, 2013"
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.DayNames[value.DayOfWeek] );
								builder.Append( ", " );
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( day, "D2" );
								builder.Append( ", " );
								builder.Append( year );
								break;

							case CultureInfo.CultureKind.RU: // "5 января 2013 г."
								builder.Append( day );
								builder.Append( ' ' );
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthGenitiveNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								builder.Append( " г." );
								break;

							case CultureInfo.CultureKind.UK: // "5 січня 2013 р."
								builder.Append( day );
								builder.Append( ' ' );
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthGenitiveNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								builder.Append( " р." );
								break;

							case CultureInfo.CultureKind.FR: // "samedi 5 janvier 2013"
								builder.Append( CultureInfo.Current.DateTimeFormat.DayNames[value.DayOfWeek] );
								builder.Append( ' ' );
								builder.Append( day, "D2" );
								builder.Append( ' ' );
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								break;

							case CultureInfo.CultureKind.DE: // "Samstag, 5. Januar 2013"
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.DayNames[value.DayOfWeek] );
								builder.Append( ", " );
								builder.Append( day, "D2" );
								builder.Append( ". " );
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								break;
						}
						return;

					// full date short time
					case "f":
						[CheckAllEnumValues]
						switch( CultureInfo.Current.Kind ) {
							case CultureInfo.CultureKind.EN: // "Saturday, January 05, 2013 2:33 PM"
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.DayNames[value.DayOfWeek] );
								builder.Append( ", " );
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( day, "D2" );
								builder.Append( ", " );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( _12hourMapping[hour] );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ' ' );
								builder.Append( hour < 12 ? "AM" : "PM" );
								break;

							case CultureInfo.CultureKind.RU: // "5 января 2013 г. 14:33"
								builder.Append( day );
								builder.Append( ' ' );
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthGenitiveNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								builder.Append( " г. " );
								builder.Append( hour );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								break;

							case CultureInfo.CultureKind.UK: // "5 січня 2013 р. 14:33"
								builder.Append( day );
								builder.Append( ' ' );
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthGenitiveNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								builder.Append( " р. " );
								builder.Append( hour );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								break;

							case CultureInfo.CultureKind.FR: // "samedi 5 janvier 2013 14:33"
								builder.Append( CultureInfo.Current.DateTimeFormat.DayNames[value.DayOfWeek] );
								builder.Append( ' ' );
								builder.Append( day, "D2" );
								builder.Append( ' ' );
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( hour, "D2" );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								break;

							case CultureInfo.CultureKind.DE: // "Samstag, 5. Januar 2013 14:33"
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.DayNames[value.DayOfWeek] );
								builder.Append( ", " );
								builder.Append( day, "D2" );
								builder.Append( ". " );
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( hour, "D2" );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								break;
						}
						return;

					// full date long time
					case "F":
						[CheckAllEnumValues]
						switch( CultureInfo.Current.Kind ) {
							case CultureInfo.CultureKind.EN: // "Saturday, January 05, 2013 2:33:21 PM"
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.DayNames[value.DayOfWeek] );
								builder.Append( ", " );
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( day, "D2" );
								builder.Append( ", " );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( _12hourMapping[hour] );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ':' );
								builder.Append( second, "D2" );
								builder.Append( ' ' );
								builder.Append( hour < 12 ? "AM" : "PM" );
								break;

							case CultureInfo.CultureKind.RU: // "5 января 2013 г. 14:33:21"
								builder.Append( day );
								builder.Append( ' ' );
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthGenitiveNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								builder.Append( " г. " );
								builder.Append( hour );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ':' );
								builder.Append( second, "D2" );
								break;

							case CultureInfo.CultureKind.UK: // "5 січня 2013 р. 14:33:21"
								builder.Append( day );
								builder.Append( ' ' );
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthGenitiveNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								builder.Append( " р. " );
								builder.Append( hour );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ':' );
								builder.Append( second, "D2" );
								break;

							case CultureInfo.CultureKind.FR: // "samedi 5 janvier 2013 14:33:21"
								builder.Append( CultureInfo.Current.DateTimeFormat.DayNames[value.DayOfWeek] );
								builder.Append( ' ' );
								builder.Append( day, "D2" );
								builder.Append( ' ' );
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( hour, "D2" );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ':' );
								builder.Append( second, "D2" );
								break;

							case CultureInfo.CultureKind.DE: // "Samstag, 5. Januar 2013 14:33:21"
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.DayNames[value.DayOfWeek] );
								builder.Append( ", " );
								builder.Append( day, "D2" );
								builder.Append( ". " );
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( hour, "D2" );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ':' );
								builder.Append( second, "D2" );
								break;
						}
						return;

					// general date short time
					case "g":
						[CheckAllEnumValues]
						switch( CultureInfo.Current.Kind ) {
							case CultureInfo.CultureKind.EN: // "1/5/2013 2:33 PM"
								builder.Append( month );
								builder.Append( '/' );
								builder.Append( day );
								builder.Append( '/' );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( _12hourMapping[hour] );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ' ' );
								builder.Append( hour < 12 ? "AM" : "PM" );
								break;

							case CultureInfo.CultureKind.RU: // "05.01.2013 14:33"
							case CultureInfo.CultureKind.UK: // "05.01.2013 14:33"
								builder.Append( day, "D2" );
								builder.Append( '.' );
								builder.Append( month, "D2" );
								builder.Append( '.' );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( hour );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								break;

							case CultureInfo.CultureKind.FR: // "05/01/2013 04:03"
							case CultureInfo.CultureKind.DE: // "05.01.2013 04:03"
								builder.Append( day, "D2" );
								builder.Append( CultureInfo.Current.DateTimeFormat.DateSeparator );
								builder.Append( month, "D2" );
								builder.Append( CultureInfo.Current.DateTimeFormat.DateSeparator );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( hour, "D2" );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								break;
						}
						return;

					// general date long time
					case "G":
						[CheckAllEnumValues]
						switch( CultureInfo.Current.Kind ) {
							case CultureInfo.CultureKind.EN: // "1/5/2013 2:33:21 PM"
								builder.Append( month );
								builder.Append( '/' );
								builder.Append( day );
								builder.Append( '/' );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( _12hourMapping[hour] );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ':' );
								builder.Append( second, "D2" );
								builder.Append( ' ' );
								builder.Append( hour < 12 ? "AM" : "PM" );
								break;

							case CultureInfo.CultureKind.RU: // "05.01.2013 14:33:21"
							case CultureInfo.CultureKind.UK: // "05.01.2013 14:33:21"
								builder.Append( day, "D2" );
								builder.Append( '.' );
								builder.Append( month, "D2" );
								builder.Append( '.' );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( hour );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ':' );
								builder.Append( second, "D2" );
								break;

							case CultureInfo.CultureKind.FR: // "05/01/2013 04:03:21"
							case CultureInfo.CultureKind.DE: // "05.01.2013 04:03:21"
								builder.Append( day, "D2" );
								builder.Append( CultureInfo.Current.DateTimeFormat.DateSeparator );
								builder.Append( month, "D2" );
								builder.Append( CultureInfo.Current.DateTimeFormat.DateSeparator );
								builder.Append( year );
								builder.Append( ' ' );
								builder.Append( hour, "D2" );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ':' );
								builder.Append( second, "D2" );
								break;
						}
						return;

					// bamelg-specific, sortable long time, "14:33:21"
					case "ts":
					case "TS":
						builder.Append( hour, "D2" );
						builder.Append( ':' );
						builder.Append( minute, "D2" );
						builder.Append( ':' );
						builder.Append( second, "D2" );
						return;

					// month + day
					case "M":
					case "m":
						[CheckAllEnumValues]
						switch( CultureInfo.Current.Kind ) {
							case CultureInfo.CultureKind.EN: // "January 05"
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( day, "D2" );
								break;

							case CultureInfo.CultureKind.RU: // "января 05"
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthGenitiveNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( day, "D2" );
								break;

							case CultureInfo.CultureKind.FR: // "5 janvier"
							case CultureInfo.CultureKind.UK: // "5 січня"
								builder.Append( day );
								builder.Append( ' ' );
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								break;

							case CultureInfo.CultureKind.DE: // "05 Januar"
								builder.Append( day, "D2" );
								builder.Append( ' ' );
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								break;
						}
						return;

					case "t": // short time
						[CheckAllEnumValues]
						switch( CultureInfo.Current.Kind ) {
							case CultureInfo.CultureKind.EN: // "2:33 PM"
								builder.Append( _12hourMapping[hour] );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ' ' );
								builder.Append( hour < 12 ? "AM" : "PM" );
								break;

							case CultureInfo.CultureKind.RU: // "14:33"
							case CultureInfo.CultureKind.UK: // "14:33"
								builder.Append( hour );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								break;

							case CultureInfo.CultureKind.FR: // "14:33"
							case CultureInfo.CultureKind.DE: // "14:33"
								builder.Append( hour, "D2" );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								break;
						}
						return;

					// long time
					case "T":
						[CheckAllEnumValues]
						switch( CultureInfo.Current.Kind ) {
							case CultureInfo.CultureKind.EN: // "2:33:21 PM"
								builder.Append( _12hourMapping[hour] );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ':' );
								builder.Append( second, "D2" );
								builder.Append( ' ' );
								builder.Append( hour < 12 ? "AM" : "PM" );
								break;

							case CultureInfo.CultureKind.RU: // "14:33:21"
							case CultureInfo.CultureKind.UK: // "14:33:21"
								builder.Append( hour );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ':' );
								builder.Append( second, "D2" );
								break;

							case CultureInfo.CultureKind.FR: // "14:33:21"
							case CultureInfo.CultureKind.DE: // "14:33:21"
								builder.Append( hour, "D2" );
								builder.Append( ':' );
								builder.Append( minute, "D2" );
								builder.Append( ':' );
								builder.Append( second, "D2" );
								break;
						}
						return;

					case "Y":
					case "y":
						[CheckAllEnumValues]
						switch( CultureInfo.Current.Kind ) {
							case CultureInfo.CultureKind.EN: // "January, 2013"
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ", " );
								builder.Append( year );
								break;

							case CultureInfo.CultureKind.RU: // "Январь 2013"
							case CultureInfo.CultureKind.DE: // "Januar 2013"
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								break;

							case CultureInfo.CultureKind.UK: // "Січень 2013 р."
								AppendCapital( builder, CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								builder.Append( " р." );
								break;

							case CultureInfo.CultureKind.FR: // "janvier 2013"
								builder.Append( CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
								builder.Append( ' ' );
								builder.Append( year );
								break;
						}
						return;

					// universal sortable, "2013-01-05 14:33:21Z"
					case "u":
						builder.Append( year );
						builder.Append( '-' );
						builder.Append( month, "D2" );
						builder.Append( '-' );
						builder.Append( day, "D2" );
						builder.Append( ' ' );
						builder.Append( hour, "D2" );
						builder.Append( ':' );
						builder.Append( minute, "D2" );
						builder.Append( ':' );
						builder.Append( second, "D2" );
						builder.Append( 'Z' );
						return;

					// universal full, "Saturday, January 05, 2013 10:33:21 AM"
					case "U": goto case "F";

					// round-trip, "2013-01-05T14:33:21.4560000+04:00"
					case "O":
						builder.Append( year );
						builder.Append( '-' );
						builder.Append( month, "D2" );
						builder.Append( '-' );
						builder.Append( day, "D2" );
						builder.Append( ' ' );
						builder.Append( hour, "D2" );
						builder.Append( ':' );
						builder.Append( minute, "D2" );
						builder.Append( ':' );
						builder.Append( second, "D2" );

						var microseconds = ( int )( value.Ticks % 10000000 );
						if( microseconds != 0 ) {
							builder.Append( '.' );
							builder.Append( microseconds, "D7" );
						}

						if( value.Kind == DateTimeKind.Local ) {
							var offset = DateTime.GetLocalFromUtcOffset( value );
							if( offset.Ticks != 0 ) {
								if( offset >= TimeSpan.Zero ) builder.Append( '+' );
								builder.Append( offset.Hours, "D2" );
								builder.Append( ':' );
								builder.Append( offset.Minutes, "D2" );
							}
						}

						return;

					// round-trip, "2013-01-05 14:33:21.4560000+04:00"
					case "o":
						builder.Append( year );
						builder.Append( '-' );
						builder.Append( month, "D2" );
						builder.Append( '-' );
						builder.Append( day, "D2" );
						builder.Append( 'T' );
						builder.Append( hour, "D2" );
						builder.Append( ':' );
						builder.Append( minute, "D2" );
						builder.Append( ':' );
						builder.Append( second, "D2" );

						var microseconds = ( int )( value.Ticks % 10000000 );
						if( microseconds != 0 ) {
							builder.Append( '.' );
							builder.Append( microseconds, "D7" );
						}

						if( value.Kind == DateTimeKind.Local ) {
							var offset = DateTime.GetLocalFromUtcOffset( value );
							if( offset.Ticks != 0 ) {
								if( offset >= TimeSpan.Zero ) builder.Append( '+' );
								builder.Append( offset.Hours, "D2" );
								builder.Append( ':' );
								builder.Append( offset.Minutes, "D2" );
							}
						}

						return;

					// RFC string, "Sat, 05 Jan 2013 14:33:21 GMT"
					case "R":
					case "r":
						AppendCapital( builder, CultureInfo.EN.DateTimeFormat.AbbreviatedDayNames[value.DayOfWeek] );
						builder.Append( ", " );
						builder.Append( day, "D2" );
						builder.Append( ' ' );
						AppendCapital( builder, CultureInfo.EN.DateTimeFormat.AbbreviatedMonthNames[month - 1] );
						builder.Append( ' ' );
						builder.Append( year );
						builder.Append( ' ' );
						builder.Append( hour, "D2" );
						builder.Append( ':' );
						builder.Append( minute, "D2" );
						builder.Append( ':' );
						builder.Append( second, "D2" );
						builder.Append( " GMT" );
						return;

					case "":
					case "S": // bamelg-specific sortable, "2013-01-05 14:33:21"
						builder.Append( year );
						builder.Append( '-' );
						builder.Append( month, "D2" );
						builder.Append( '-' );
						builder.Append( day, "D2" );
						builder.Append( ' ' );
						builder.Append( hour, "D2" );
						builder.Append( ':' );
						builder.Append( minute, "D2" );
						builder.Append( ':' );
						builder.Append( second, "D2" );
						return;

					case "s": // sortable, "2013-01-05T14:33:21"
						builder.Append( year );
						builder.Append( '-' );
						builder.Append( month, "D2" );
						builder.Append( '-' );
						builder.Append( day, "D2" );
						builder.Append( 'T' );
						builder.Append( hour, "D2" );
						builder.Append( ':' );
						builder.Append( minute, "D2" );
						builder.Append( ':' );
						builder.Append( second, "D2" );
						return;
				}
			else {
				++customFormatStartPos;
			}

			// custom format
			for( var i = customFormatStartPos; i < format.Length; ++i ) {
				if( format[i] == '\\' ) continue;
				var remaining = format.Length - i;

				if( remaining >= 7 && StartsWithEqualChars( format.GetChars() + i, 7 ) ) {
					var skip = 7 - 1;

					switch( format[i] ) {
						case 'f': builder.Append( value.Ticks % 10000000, "D7" ); i += skip; continue;
						case 'F': if( value.Ticks % 10000000 != 0 ) builder.Append( value.Ticks % 10000000, "D7" ); i += skip; continue;
						case 'y': builder.Append( year, "D7" ); i += skip; continue;
					}
				}

				if( remaining >= 6 && StartsWithEqualChars( format.GetChars() + i, 6 ) ) {
					var skip = 6 - 1;

					switch( format[i] ) {
						case 'f': builder.Append( value.Ticks / 10 % 1000000, "D6" ); i += skip; continue;
						case 'F': if( value.Ticks / 10 % 1000000 != 0 ) builder.Append( value.Ticks / 10 % 1000000, "D6" ); i += skip; continue;
						case 'y': builder.Append( year, "D6" ); i += skip; continue;
					}
				}

				if( remaining >= 5 && StartsWithEqualChars( format.GetChars() + i, 5 ) ) {
					var skip = 5 - 1;

					switch( format[i] ) {
						case 'f': builder.Append( value.Ticks / 100 % 100000, "D5" ); i += skip; continue;
						case 'F': if( value.Ticks / 100 % 100000 != 0 ) builder.Append( value.Ticks / 100 % 100000, "D5" ); i += skip; continue;
						case 'y': builder.Append( year, "D5" ); i += skip; continue;
					}
				}

				if( remaining >= 4 && StartsWithEqualChars( format.GetChars() + i, 4 ) ) {
					var skip = 4 - 1;

					switch( format[i] ) {
						case 'd':
							[CheckAllEnumValues]
							switch( CultureInfo.Current.Kind ) {
								case CultureInfo.CultureKind.EN: // "Saturday"
								case CultureInfo.CultureKind.DE: // "Samstag"
									AppendCapital( builder, CultureInfo.Current.DateTimeFormat.DayNames[value.DayOfWeek] );
									break;

								case CultureInfo.CultureKind.RU: // "суббота"
								case CultureInfo.CultureKind.UK: // "субота"
								case CultureInfo.CultureKind.FR: // "samedi"
									builder.Append( CultureInfo.Current.DateTimeFormat.DayNames[value.DayOfWeek] );
									break;
							}

							i += skip;
							continue;

						case 'f': builder.Append( value.Ticks / 1000 % 10000, "D4" ); i += skip; continue;
						case 'F': if( value.Ticks / 1000 % 10000 != 0 ) builder.Append( value.Ticks / 1000 % 10000, "D4" ); i += skip; continue;
						case 'M': // MMMM
							[CheckAllEnumValues]
							switch( CultureInfo.Current.Kind ) {
								case CultureInfo.CultureKind.EN: // "January"
								case CultureInfo.CultureKind.RU: // "Январь"
								case CultureInfo.CultureKind.UK: // "Січень"
								case CultureInfo.CultureKind.DE: // "Samstag"
									AppendCapital( builder, CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
									break;

								case CultureInfo.CultureKind.FR: // "janvier"
									builder.Append( CultureInfo.Current.DateTimeFormat.MonthNames[month - 1] );
									break;
							}

							i += skip;
							continue;
						case 'y': builder.Append( year, "D4" ); i += skip; continue;
					}
				}

				if( remaining >= 3 && StartsWithEqualChars( format.GetChars() + i, 3 ) ) {
					var skip = 3 - 1;

					switch( format[i] ) {
						case 'd':
							[CheckAllEnumValues]
							switch( CultureInfo.Current.Kind ) {
								case CultureInfo.CultureKind.EN: // "Sat"
								case CultureInfo.CultureKind.RU: // "Сб"
								case CultureInfo.CultureKind.UK: // "Сб"
								case CultureInfo.CultureKind.DE: // "Sa"
									AppendCapital( builder, CultureInfo.Current.DateTimeFormat.AbbreviatedDayNames[value.DayOfWeek] );
									break;

								case CultureInfo.CultureKind.FR: // "sam."
									builder.Append( CultureInfo.Current.DateTimeFormat.AbbreviatedDayNames[value.DayOfWeek] );
									break;
							}

							i += skip;
							continue;

						case 'f': builder.Append( value.Ticks / 10000 % 1000, "D3" ); i += skip; continue;
						case 'F': if( value.Ticks / 10000 % 1000 != 0 ) builder.Append( value.Ticks / 10000 % 1000, "D3" ); i += skip; continue;
						case 'M': // MMM
							[CheckAllEnumValues]
							switch( CultureInfo.Current.Kind ) {
								case CultureInfo.CultureKind.EN: // "Jan"
								case CultureInfo.CultureKind.DE: // "Jan"
								case CultureInfo.CultureKind.UK: // "Січ"
									AppendCapital( builder, CultureInfo.Current.DateTimeFormat.AbbreviatedMonthNames[month - 1] );
									break;

								case CultureInfo.CultureKind.RU: // "янв"
								case CultureInfo.CultureKind.FR: // "janv."
									builder.Append( CultureInfo.Current.DateTimeFormat.AbbreviatedMonthNames[month - 1] );
									break;
							}
							i += skip;
							continue;

						case 'y': builder.Append( year, "D3" ); i += skip; continue;
						case 'z': { // offset from UTC, "+04:00"
								var offset = DateTime.GetLocalFromUtcOffset( value );
								if( offset >= TimeSpan.Zero ) builder.Append( '+' );
								builder.Append( offset.Hours, "D2" );
								builder.Append( ':' );
								builder.Append( offset.Minutes, "D2" );
								i += skip;
								continue;
							}
					}
				}

				if( remaining >= 2 && StartsWithEqualChars( format.GetChars() + i, 2 ) ) {
					var skip = 2 - 1;

					switch( format[i] ) {
						case 'd': builder.Append( day, "D2" ); i += skip; continue;
						case 'f': builder.Append( value.Ticks / 100000 % 100, "D2" ); i += skip; continue;
						case 'F': if( value.Ticks / 100000 % 100 != 0 ) builder.Append( value.Ticks / 100000 % 100, "D2" ); i += skip; continue;
						case 'h': builder.Append( hour % 12, "D2" ); i += skip; continue;
						case 'H': builder.Append( hour, "D2" ); i += skip; continue;
						case 'm': builder.Append( minute, "D2" ); i += skip; continue;
						case 'M': builder.Append( month, "D2" ); i += skip; continue;
						case 's': builder.Append( second, "D2" ); i += skip; continue;
						case 'y': builder.Append( year % 100, "D2" ); i += skip; continue;
						case 'z': { // hour offset from UTC, "+04"
								var offset = DateTime.GetLocalFromUtcOffset( value );
								if( offset.Hours >= 0 ) builder.Append( '+' );
								builder.Append( offset.Hours, "D2" );
								i += skip;
								continue;
							}
					}
				}

				// TODO add literal string delimiter support
				{
					var skip = 0;

					switch( format[i] ) {
						case 'd': builder.Append( day ); i += skip; continue;
						case 'f': builder.Append( value.Ticks / 1000000 % 10 ); i += skip; continue;
						case 'F': if( value.Ticks / 1000000 % 10 != 0 ) builder.Append( value.Ticks / 1000000 % 10 ); i += skip; continue;
						case 'h': builder.Append( hour % 12 ); i += skip; continue;
						case 'H': builder.Append( hour ); i += skip; continue;
						case 'm': builder.Append( minute ); i += skip; continue;
						case 'M': builder.Append( month ); i += skip; continue;
						case 's': builder.Append( second ); i += skip; continue;
						case 'y': builder.Append( year % 100 ); i += skip; continue;
						case 'z': { // hour offset from UTC, "+4"
								var offset = DateTime.GetLocalFromUtcOffset( value );
								if( offset.Hours >= 0 ) builder.Append( '+' );
								builder.Append( offset.Hours );
								i += skip;
								continue;
							}

						case ':': // time separator
							builder.Append( CultureInfo.Current.DateTimeFormat.TimeSeparator );
							i += skip;
							continue;

						case '/': // date separator
							builder.Append( CultureInfo.Current.DateTimeFormat.DateSeparator );
							i += skip;
							continue;
					}
				}

				builder.Append( format[i] );
			}
		}

		private static bool StartsWithEqualChars( char* ptr, int max ) {
			for( var i = 1; i < max; ++i ) {
				if( ptr[i] != ptr[0] ) return false;
			}

			return true;
		}

		public static void FormatTimeSpan( StringBuilder builder, string format, TimeSpan value ) {
			if( value.Ticks < 0 ) {
				builder.Append( '-' );
				value.Ticks = -value.Ticks;
			}

			var days = value.Days;

			switch( format ) {
				case "":
				case "c":
					if( days != 0 ) {
						builder.Append( days );
						builder.Append( '.' );
					}

					builder.Append( value.Hours, "D2" );
					builder.Append( ':' );
					builder.Append( value.Minutes, "D2" );
					builder.Append( ':' );
					builder.Append( value.Seconds, "D2" );

					if( value.MicrosecondsWithMilliseconds != 0 ) {
						builder.Append( '.' );
						builder.Append( value.MicrosecondsWithMilliseconds, "D6" );
					}

					break;
				default: builder.Append( "Invalid format!" ); break;
			}
		}

		private static void AppendCapital( StringBuilder builder, string value ) {
			if( value.IsNullOrEmpty ) return;

			builder.Append( char.ToUpper( value[0] ) );
			builder.Append( new CUtf16StringSpan( value.GetChars() + 1, value.Length - 1 ) );
		}

		private static void FormatMemoryImpl<T>( byte[16]& table, T* result, void* data, uintptr length ) {
			var bytes = ( byte* ) data;

			for( uint i = 0, j = 0; j < length; ++j, i += 2 ) {
				result[i] = ( T ) table[bytes[j] >> 4];
				result[i + 1] = ( T ) table[bytes[j] & 15];
			}
		}

		public static SbcsString FormatMemoryHexSbcs( void* data, uintptr length, bool upperCase ) {
			var result = new SbcsString.Builder( ( uint ) length * 2 );
			var converter = StreamFormatMemoryHexUtf8( result.GetChars(), length * 2, data, length, upperCase );
			converter.MoveNext();
			return result.Detach();
		}

		public static Utf8String FormatMemoryHexUtf8( void* data, uintptr length, bool upperCase ) {
			var result = new Utf8String.Builder( ( uint ) length * 2 );
			var converter = StreamFormatMemoryHexUtf8( result.GetChars(), length * 2, data, length, upperCase );
			converter.MoveNext();
			return result.Detach();
		}

		public static string FormatMemoryHexUtf16( void* data, uintptr length, bool upperCase ) {
			var result = new Utf16String.Builder( ( uint ) length * 2 );
			var converter = StreamFormatMemoryHexUtf16( result.GetChars(), length * 4, data, length, upperCase );
			converter.MoveNext();
			return result.Detach();
		}

		public static Utf32String FormatMemoryHexUtf32( void* data, uintptr length, bool upperCase ) {
			var result = new Utf32String.Builder( ( uint ) length * 2 );
			var converter = StreamFormatMemoryHexUtf32( result.GetChars(), length * 8, data, length, upperCase );
			converter.MoveNext();
			return result.Detach();
		}

		public static void FormatMemoryHexUtf16( StringBuilder builder, void* data, uintptr length, bool upperCase ) {
			builder.EnsureCapacity( ( int ) length * 2 );

			var converter = StreamFormatMemoryHexUtf16( builder.GetChars() + builder.Length, length * 4U, data, length, upperCase );
			converter.MoveNext();

			builder.Length += ( int ) length * 2;
		}

		public static yield<MemorySegment<byte>> StreamFormatMemoryHexUtf8( void* buffer, uintptr bufferByteLength, void* data, uintptr length, bool upperCase ) {
			var maxPrintedBytes = bufferByteLength / 2;

			while( length > 0 ) {
				var printed = Math.Min( length, maxPrintedBytes );
				FormatMemoryImpl<byte>( upperCase ? HexDigitsUpper : HexDigitsLower, ( byte* ) buffer, data, printed );
				yield return new MemorySegment<byte>( ( byte* ) buffer, printed * 2 );
				if( checkwrap( length -= printed ) ) break;
			}
		}

		public static yield<MemorySegment<char>> StreamFormatMemoryHexUtf16( void* buffer, uintptr bufferByteLength, void* data, uintptr length, bool upperCase ) {
			var maxPrintedBytes = bufferByteLength / 4;

			while( length > 0 ) {
				var printed = Math.Min( length, maxPrintedBytes );
				FormatMemoryImpl<char>( upperCase ? HexDigitsUpper : HexDigitsLower, ( char* ) buffer, data, printed );
				yield return new MemorySegment<char>( ( char* ) buffer, printed * 2 );
				if( checkwrap( length -= printed ) ) break;
			}
		}

		public static yield<MemorySegment<uint>> StreamFormatMemoryHexUtf32( void* buffer, uintptr bufferByteLength, void* data, uintptr length, bool upperCase ) {
			var maxPrintedBytes = bufferByteLength / 8;

			while( length > 0 ) {
				var printed = Math.Min( length, maxPrintedBytes );
				FormatMemoryImpl<uint>( upperCase ? HexDigitsUpper : HexDigitsLower, ( uint* ) buffer, data, printed );
				yield return new MemorySegment<uint>( ( uint* ) buffer, printed * 2 );
				if( checkwrap( length -= printed ) ) break;
			}
		}

		[UnitTest]
		public static void UnitTest() {
			var& cc = CultureInfo.Current;

			Assert.AreEqual( "NaN", FormatDoubleIEEE754Utf16( double.NaN ) );
			Assert.AreEqual( "Infinity", FormatDoubleIEEE754Utf16( double.PositiveInfinity ) );
			Assert.AreEqual( "-Infinity", FormatDoubleIEEE754Utf16( double.NegativeInfinity ) );

			Assert.AreEqual( "0F", FormatInt8Hex( ( sbyte ) 15 ) );
			Assert.AreEqual( "000F", FormatInt16Hex( ( short ) 15 ) );
			Assert.AreEqual( "0000000F", FormatInt32Hex( ( int ) 15 ) );
			Assert.AreEqual( "000000000000000F", FormatInt64Hex( ( long ) 15 ) );

			Assert.AreEqual( "7F", FormatInt8Hex( sbyte.MaxValue ) );
			Assert.AreEqual( "FF", FormatUInt8Hex( byte.MaxValue ) );
			Assert.AreEqual( "7FFF", FormatInt16Hex( short.MaxValue ) );
			Assert.AreEqual( "FFFF", FormatUInt16Hex( ushort.MaxValue ) );
			Assert.AreEqual( "7FFFFFFF", FormatInt32Hex( int.MaxValue ) );
			Assert.AreEqual( "FFFFFFFF", FormatUInt32Hex( uint.MaxValue ) );
			Assert.AreEqual( "7FFFFFFFFFFFFFFF", FormatInt64Hex( long.MaxValue ) );
			Assert.AreEqual( "FFFFFFFFFFFFFFFF", FormatUInt64Hex( ulong.MaxValue ) );

			Assert.AreEqual( sbyte.MaxValue.ToString(), FormatInt8Utf16( sbyte.MaxValue ) );
			Assert.AreEqual( sbyte.MinValue.ToString(), FormatInt8Utf16( sbyte.MinValue ) );
			Assert.AreEqual( byte.MaxValue.ToString(), FormatUInt8Utf16( byte.MaxValue ) );
			Assert.AreEqual( byte.MinValue.ToString(), FormatUInt8Utf16( byte.MinValue ) );

			Assert.AreEqual( short.MaxValue.ToString(), FormatInt16Utf16( short.MaxValue ) );
			Assert.AreEqual( short.MinValue.ToString(), FormatInt16Utf16( short.MinValue ) );
			Assert.AreEqual( ushort.MaxValue.ToString(), FormatUInt16Utf16( ushort.MaxValue ) );
			Assert.AreEqual( ushort.MinValue.ToString(), FormatUInt16Utf16( ushort.MinValue ) );

			Assert.AreEqual( int.MaxValue.ToString(), FormatInt32Utf16( int.MaxValue ) );
			Assert.AreEqual( int.MinValue.ToString(), FormatInt32Utf16( int.MinValue ) );
			Assert.AreEqual( uint.MaxValue.ToString(), FormatUInt32Utf16( uint.MaxValue ) );
			Assert.AreEqual( uint.MinValue.ToString(), FormatUInt32Utf16( uint.MinValue ) );

			Assert.AreEqual( 0.01.ToString(), FormatDoubleIEEE754Utf16( 0.01 ) );
			Assert.AreEqual( ( -10.01 ).ToString(), FormatDoubleIEEE754Utf16( -10.01 ) );

			Assert.AreEqual( long.MaxValue.ToString(), FormatInt64Utf16( long.MaxValue ) );
			Assert.AreEqual( long.MinValue.ToString(), FormatInt64Utf16( long.MinValue ) );
			Assert.AreEqual( ulong.MaxValue.ToString(), FormatUInt64Utf16( ulong.MaxValue ) );
			Assert.AreEqual( ulong.MinValue.ToString(), FormatUInt64Utf16( ulong.MinValue ) );

			var time = new DateTime( 2013, 1, 5, 14, 33, 21, 456, DateTimeKind.Utc );

			Assert.AreEqual( "2013-01-05T14:33:21", string.Format( "{0:s}", time ) );
			Assert.AreEqual( "2013-01-05 14:33:21", string.Format( "{0:S}", time ) );
			Assert.AreEqual( "Sat, 05 Jan 2013 14:33:21 GMT", string.Format( "{0:r}", time ) );
			Assert.AreEqual( "Sat, 05 Jan 2013 14:33:21 GMT", string.Format( "{0:R}", time ) );
			Assert.AreEqual( "2013-01-05T14:33:21.4560000", string.Format( "{0:o}", time ) );
			Assert.AreEqual( "2013-01-05 14:33:21.4560000", string.Format( "{0:O}", time ) );
			Assert.AreEqual( "2013-01-05 14:33:21Z", string.Format( "{0:u}", time ) );
			Assert.AreEqual( "4 45 456 4560 45600 456000 4560000", string.Format( "{0:f ff fff ffff fffff ffffff fffffff}", time ) );
			Assert.AreEqual( "13 13 2013 2013 02013 002013", string.Format( "{0:y yy yyy yyyy yyyyy yyyyyy}", time ) );
			Assert.AreEqual( "21 21", string.Format( "{0:s ss}", time ) );

			CultureInfo.Current = CultureInfo.EN;
			Assert.AreEqual( "1/5/2013", string.Format( "{0:d}", time ) );
			Assert.AreEqual( "Saturday, January 05, 2013", string.Format( "{0:D}", time ) );
			Assert.AreEqual( "Saturday, January 05, 2013 2:33 PM", string.Format( "{0:f}", time ) );
			Assert.AreEqual( "Saturday, January 05, 2013 2:33:21 PM", string.Format( "{0:F}", time ) );
			Assert.AreEqual( "1/5/2013 2:33 PM", string.Format( "{0:g}", time ) );
			Assert.AreEqual( "1/5/2013 2:33:21 PM", string.Format( "{0:G}", time ) );
			Assert.AreEqual( "2:33 PM", string.Format( "{0:t}", time ) );
			Assert.AreEqual( "2:33:21 PM", string.Format( "{0:T}", time ) );
			Assert.AreEqual( "Saturday, January 05, 2013 2:33:21 PM", string.Format( "{0:U}", time ) );
			Assert.AreEqual( "January, 2013", string.Format( "{0:y}", time ) );
			Assert.AreEqual( "January 05", string.Format( "{0:m}", time ) );
			Assert.AreEqual( "14:33:21", string.Format( "{0:TS}", time ) );
			Assert.AreEqual( "5 05 Sat Saturday", string.Format( "{0:d dd ddd dddd}", time ) );
			Assert.AreEqual( "1/01/Jan/January", string.Format( "{0:M/MM/MMM/MMMM}", time ) );
			Assert.AreEqual( "2:02", string.Format( "{0:h:hh}", time ) );

			CultureInfo.Current = CultureInfo.RU;
			Assert.AreEqual( "05.01.2013", string.Format( "{0:d}", time ) );
			Assert.AreEqual( "5 января 2013 г.", string.Format( "{0:D}", time ) );
			Assert.AreEqual( "5 января 2013 г. 14:33", string.Format( "{0:f}", time ) );
			Assert.AreEqual( "5 января 2013 г. 14:33:21", string.Format( "{0:F}", time ) );
			Assert.AreEqual( "05.01.2013 14:33", string.Format( "{0:g}", time ) );
			Assert.AreEqual( "05.01.2013 14:33:21", string.Format( "{0:G}", time ) );
			Assert.AreEqual( "14:33", string.Format( "{0:t}", time ) );
			Assert.AreEqual( "14:33:21", string.Format( "{0:T}", time ) );
			Assert.AreEqual( "5 января 2013 г. 14:33:21", string.Format( "{0:U}", time ) );
			Assert.AreEqual( "января 05", string.Format( "{0:m}", time ) );
			Assert.AreEqual( "14:33:21", string.Format( "{0:TS}", time ) );
			Assert.AreEqual( "5 05 Сб суббота", string.Format( "{0:d dd ddd dddd}", time ) );
			Assert.AreEqual( "1.01.янв.Январь", string.Format( "{0:M/MM/MMM/MMMM}", time ) );
			Assert.AreEqual( "2:02", string.Format( "{0:h:hh}", time ) );

			CultureInfo.Current = cc;
		}

		internal static byte[16] HexDigitsLower = { ( byte ) '0', ( byte ) '1', ( byte ) '2', ( byte ) '3', ( byte ) '4', ( byte ) '5', ( byte ) '6', ( byte ) '7', ( byte ) '8', ( byte ) '9', ( byte ) 'a', ( byte ) 'b', ( byte ) 'c', ( byte ) 'd', ( byte ) 'e', ( byte ) 'f' };
		internal static byte[16] HexDigitsUpper = { ( byte ) '0', ( byte ) '1', ( byte ) '2', ( byte ) '3', ( byte ) '4', ( byte ) '5', ( byte ) '6', ( byte ) '7', ( byte ) '8', ( byte ) '9', ( byte ) 'A', ( byte ) 'B', ( byte ) 'C', ( byte ) 'D', ( byte ) 'E', ( byte ) 'F' };

		public static int GetScaleOrder( int value ) {
			for( int i = TenPowersTable.Length / 2 + 1; i >= 0; --i )
				if( value >= TenPowersTable[i] )
					return i + 1;
			return 1;
		}

		public static int GetScaleOrder( long value ) {
			for( int i = TenPowersTable.Length - 1; i >= 0; --i )
				if( value >= TenPowersTable[i] )
					return i + 1;
			return 1;
		}
	}
}