//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System.Diagnostics;
using System.Runtime;

namespace System.IO {
	public abstract class TraceStream : IStream {
		protected IStream _stream;
		private string _name;

		public StreamCapabilities Capabilities { get { return _stream.Capabilities; } }
		public StreamingBufferInfo* BufferInfo { get { return _stream.BufferInfo; } }

		private TraceStream( IStream stream, string name = "" ) {
			_stream = stream;

			_name = name.IsNullOrEmpty ? bitcast<InterfaceInstance>( stream ).Type->ToString() : name;
		}

		int IStream.Read( void* buffer, int length ) {
			Trace.Write( "Stream: {0} read length={1}", _name, length );
			var result = _stream.Read( buffer, length );
			Trace.Write( "Stream: {0} read completed readen={1}", _name, result );
			return result;
		}

		void IStream.Write( void* buffer, int length ) {
			Trace.Write( "Stream: {0} write length={1}", _name, length );
			var result = _stream.Read( buffer, length );
			Trace.Write( "Stream: {0} write completed", _name );
		}

		int IStream.Read( vararg MemorySegment segments ) {
			var totalSize = 0;
			foreach( var segment in segments )
				totalSize += ( int ) segment.Count;

			Trace.Write( "Stream: {0} read scatter segments={1} totalSize={2}", _name, segments.Length, totalSize );
			var result = _stream.Read( vararg( segments, segments.Length ) );
			Trace.Write( "Stream: {0} read scatter completed readen={1}", _name, result );

			return result;
		}

		void IStream.Write( vararg MemorySegment segments ) {
			var totalSize = 0;
			foreach( var segment in segments )
				totalSize += ( int ) segment.Count;

			Trace.Write( "Stream: {0} write gather segments={1} totalSize={2}", _name, segments.Length, totalSize );
			_stream.Write( vararg( segments, segments.Length ) );
			Trace.Write( "Stream: {0} write gather completed", _name );
		}

		void IStream.Flush( FlushKind flushKind ) {
			_stream.Flush( flushKind );
		}

		TimeSpan IStream.Timeout { get { return TimeSpan.Zero; } set { } }

		long IStream.Position { get { return _stream.Position; } }

		long IStream.Seek( long offset, SeekOrigin origin ) {
			Trace.Write( "Stream: {0} seek offset={1} orign={2}", _name, offset, origin );
			var result = _stream.Seek( offset, origin );
			Trace.Write( "Stream: {0} seek completed", _name );
			return result;
		}
	}
}