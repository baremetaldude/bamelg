//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.Diagnostics;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace System.IO {
	// Writes primitive data types into binary stream. Regardless of input's byte order data stored in little-endian form
	public class BinaryWriter {
		public IStream BaseStream;

		protected StreamingBufferInfo* _bufferInfo;

		public bool IsEndOfStream { get; set; }

		public BinaryWriter( IStream stream ) {
			BaseStream = stream.GetBufferedWriteStream( _bufferInfo );
		}

		~BinaryWriter() { Cleanup(); }
		public override void Dispose() { Cleanup(); base.Dispose(); }

		private void Cleanup() {
			if( BaseStream != null ) {
				if( !IsEndOfStream ) BaseStream.Flush( FlushKind.Write );
				BaseStream = null;
			}
		}

		#region Primitive types

		private void WritePrimitive<T>( T& value ) {
			if( !BaseStream.EnsureWritable( _bufferInfo, sizeof( T ) ) ) {
				IsEndOfStream = true;
				return;
			}

			unaligned( *cast<T*>( _bufferInfo->WriteBufferStart ) ) = value;
			_bufferInfo->OnWritePerformed( sizeof( value ) );
		}

		public void Write( bool value ) { WritePrimitive<bool>( value ); }

		public void Write( sbyte value ) { WritePrimitive<sbyte>( value ); }
		public void Write( byte value ) { WritePrimitive<byte>( value ); }

		public void Write( short_littleendian value ) { WritePrimitive<short_littleendian>( value ); }
		public void Write( ushort_littleendian value ) { WritePrimitive<ushort_littleendian>( value ); }
		public void Write( int_littleendian value ) { WritePrimitive<int_littleendian>( value ); }
		public void Write( uint_littleendian value ) { WritePrimitive<uint_littleendian>( value ); }
		public void Write( long_littleendian value ) { WritePrimitive<long_littleendian>( value ); }
		public void Write( ulong_littleendian value ) { WritePrimitive<ulong_littleendian>( value ); }

		public void WriteBigEndian( short_bigendian value ) { WritePrimitive<short_bigendian>( value ); }
		public void WriteBigEndian( ushort_bigendian value ) { WritePrimitive<ushort_bigendian>( value ); }
		public void WriteBigEndian( int_bigendian value ) { WritePrimitive<int_bigendian>( value ); }
		public void WriteBigEndian( uint_bigendian value ) { WritePrimitive<uint_bigendian>( value ); }
		public void WriteBigEndian( long_bigendian value ) { WritePrimitive<long_bigendian>( value ); }
		public void WriteBigEndian( ulong_bigendian value ) { WritePrimitive<ulong_bigendian>( value ); }

		public void Write( float_littleendian value ) { WritePrimitive<float_littleendian>( value ); }
		public void Write( double_littleendian value ) { WritePrimitive<double_littleendian>( value ); }

		public void WriteBigEndian( float_bigendian value ) { WritePrimitive<float_bigendian>( value ); }
		public void WriteBigEndian( double_bigendian value ) { WritePrimitive<double_bigendian>( value ); }

		public void Write( [In] Guid& value ) {
			if( !BaseStream.EnsureWritable( _bufferInfo, sizeof( value ) ) ) {
				IsEndOfStream = true;
				return;
			}

			if( CompilerInfo.CurrentPlatform == PlatformID.Windows ) {
				var bytes = value.Bytes;
				unaligned( *cast<byte[16]*>( _bufferInfo->WriteBufferStart ) ) = bytes;
			}
			else {
				unaligned( *cast<Guid*>( _bufferInfo->WriteBufferStart ) ) = value;
			}

			_bufferInfo->OnWritePerformed( sizeof( value ) );
		}

		public void Write( [In] DateTime& value ) { Write( *( long* ) &value ); }
		public void Write( [In] DateTimeUTC& value ) { Write( *( long* ) &value ); }
		public void Write( [In] TimeSpan& value ) { Write( *( long* ) &value ); }

		// public void Write( [In] void* buffer, int length ) { BaseStream.Write( buffer, length ); } // BaseStream always buffered

		public void Write( System.Serialization.IBinarySerializable value, System.Serialization.SerializerContext context ) { value.Serialize( this, context ); }

		#endregion

		#region MemorySegment operations

		public void WriteValues( sbyte* value, uint count ) {
			if( BaseStream.Write( ( byte* ) value, count ) != count )
				IsEndOfStream = true;
		}

		public void WriteValues( byte* value, uint count ) {
			if( BaseStream.Write( value, count ) != count )
				IsEndOfStream = true;
		}

		public void WriteValues( short* value, uint count ) {
			if( !CompilerInfo.BigEndian ) {
				var byteCount = sizeof( value[0] ) * count;
				if( BaseStream.Write( value, byteCount ) != byteCount )
					IsEndOfStream = true;
			}
			else
				for( var i = 0U; i < count; ++i )
					Write( value[i] );
		}

		public void WriteValues( ushort* value, uint count ) {
			if( !CompilerInfo.BigEndian ) {
				var byteCount = sizeof( value[0] ) * count;
				if( BaseStream.Write( value, byteCount ) != byteCount )
					IsEndOfStream = true;
			}
			else
				for( var i = 0U; i < count; ++i )
					Write( value[i] );
		}

		public void WriteValues( char* value, uint count ) {
			if( !CompilerInfo.BigEndian ) {
				var byteCount = sizeof( value[0] ) * count;
				if( BaseStream.Write( value, byteCount ) != byteCount )
					IsEndOfStream = true;
			}
			else
				for( var i = 0U; i < count; ++i )
					Write( value[i] );
		}

		public void WriteValues( int* value, uint count ) {
			if( !CompilerInfo.BigEndian ) {
				var byteCount = sizeof( value[0] ) * count;
				if( BaseStream.Write( value, byteCount ) != byteCount )
					IsEndOfStream = true;
			}
			else
				for( var i = 0U; i < count; ++i )
					Write( value[i] );
		}

		public void WriteValues( uint* value, uint count ) {
			if( !CompilerInfo.BigEndian ) {
				var byteCount = sizeof( value[0] ) * count;
				if( BaseStream.Write( value, byteCount ) != byteCount )
					IsEndOfStream = true;
			}
			else
				for( var i = 0U; i < count; ++i )
					Write( value[i] );
		}

		public void WriteValues( long* value, uint count ) {
			if( !CompilerInfo.BigEndian ) {
				var byteCount = sizeof( value[0] ) * count;
				if( BaseStream.Write( value, byteCount ) != byteCount )
					IsEndOfStream = true;
			}
			else
				for( var i = 0U; i < count; ++i )
					Write( value[i] );
		}

		public void WriteValues( ulong* value, uint count ) {
			if( !CompilerInfo.BigEndian ) {
				var byteCount = sizeof( value[0] ) * count;
				if( BaseStream.Write( value, byteCount ) != byteCount )
					IsEndOfStream = true;
			}
			else
				for( var i = 0U; i < count; ++i )
					Write( value[i] );
		}

		public void WriteValues( DateTime* value, uint count ) {
			if( !CompilerInfo.BigEndian ) {
				var byteCount = sizeof( value[0] ) * count;
				if( BaseStream.Write( value, byteCount ) != byteCount )
					IsEndOfStream = true;
			}
			else
				for( var i = 0U; i < count; ++i )
					Write( value[i] );
		}

		public void WriteValues( DateTimeUTC* value, uint count ) {
			if( !CompilerInfo.BigEndian ) {
				var byteCount = sizeof( value[0] ) * count;
				if( BaseStream.Write( value, byteCount ) != byteCount )
					IsEndOfStream = true;
			}
			else
				for( var i = 0U; i < count; ++i )
					Write( value[i] );
		}

		public void WriteValues( TimeSpan* value, uint count ) {
			if( !CompilerInfo.BigEndian ) {
				var byteCount = sizeof( value[0] ) * count;
				if( BaseStream.Write( value, byteCount ) != byteCount )
					IsEndOfStream = true;
			}
			else
				for( var i = 0U; i < count; ++i )
					Write( value[i] );
		}

		public void WriteValues( Guid* value, uint count ) {
			if( CompilerInfo.CurrentPlatform == PlatformID.Windows ) {
				for( var i = 0U; i < count; ++i )
					Write( value[i] );
			}
			else {
				var byteCount = sizeof( value[0] ) * count;
				if( BaseStream.Write( value, byteCount ) != byteCount )
					IsEndOfStream = true;
			}
		}

		public void WriteValues( sbyte[] buffer, uint offset, uint length ) {
			if( buffer == null ) { Debug.Fail(); return; }
			if( length > buffer.Length ) { Debug.Fail(); return; }
			if( offset >= buffer.Length ) { Debug.Fail(); return; }
			if( offset + length > buffer.Length ) { Debug.Fail(); return; }

			WriteValues( &buffer[offset], length );
		}

		public void WriteValues( byte[] buffer, uint offset, uint length ) {
			if( buffer == null ) { Debug.Fail(); return; }
			if( length > buffer.Length ) { Debug.Fail(); return; }
			if( offset >= buffer.Length ) { Debug.Fail(); return; }
			if( offset + length > buffer.Length ) { Debug.Fail(); return; }

			WriteValues( &buffer[offset], length );
		}

		public void WriteValues( short[] buffer, uint offset, uint length ) {
			if( buffer == null ) { Debug.Fail(); return; }
			if( length > buffer.Length ) { Debug.Fail(); return; }
			if( offset >= buffer.Length ) { Debug.Fail(); return; }
			if( offset + length > buffer.Length ) { Debug.Fail(); return; }

			WriteValues( &buffer[offset], length );
		}

		public void WriteValues( ushort[] buffer, uint offset, uint length ) {
			if( buffer == null ) { Debug.Fail(); return; }
			if( length > buffer.Length ) { Debug.Fail(); return; }
			if( offset >= buffer.Length ) { Debug.Fail(); return; }
			if( offset + length > buffer.Length ) { Debug.Fail(); return; }

			WriteValues( &buffer[offset], length );
		}

		public void WriteValues( int[] buffer, uint offset, uint length ) {
			if( buffer == null ) { Debug.Fail(); return; }
			if( length > buffer.Length ) { Debug.Fail(); return; }
			if( offset >= buffer.Length ) { Debug.Fail(); return; }
			if( offset + length > buffer.Length ) { Debug.Fail(); return; }

			WriteValues( &buffer[offset], length );
		}

		public void WriteValues( uint[] buffer, uint offset, uint length ) {
			if( buffer == null ) { Debug.Fail(); return; }
			if( length > buffer.Length ) { Debug.Fail(); return; }
			if( offset >= buffer.Length ) { Debug.Fail(); return; }
			if( offset + length > buffer.Length ) { Debug.Fail(); return; }

			WriteValues( &buffer[offset], length );
		}

		public void WriteValues( long[] buffer, uint offset, uint length ) {
			if( buffer == null ) { Debug.Fail(); return; }
			if( length > buffer.Length ) { Debug.Fail(); return; }
			if( offset >= buffer.Length ) { Debug.Fail(); return; }
			if( offset + length > buffer.Length ) { Debug.Fail(); return; }

			WriteValues( &buffer[offset], length );
		}

		public void WriteValues( ulong[] buffer, uint offset, uint length ) {
			if( buffer == null ) { Debug.Fail(); return; }
			if( length > buffer.Length ) { Debug.Fail(); return; }
			if( offset >= buffer.Length ) { Debug.Fail(); return; }
			if( offset + length > buffer.Length ) { Debug.Fail(); return; }

			WriteValues( &buffer[offset], length );
		}

		#endregion

		#region Array operations

		public void WriteArray( sbyte* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( sbyte[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( byte* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( byte[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( short* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( short[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( ushort* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( ushort[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( char* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( char[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( int* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( int[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( uint* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( uint[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( long* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( long[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( ulong* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( ulong[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( DateTime* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( DateTimeUTC* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( DateTime[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( DateTimeUTC[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( TimeSpan* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( TimeSpan[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		public void WriteArray( Guid* value, uint count ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( count );
			WriteValues( value, count );
		}

		public void WriteArray( Guid[] value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			WriteArray( &value[0], value.Length );
		}

		#endregion

		#region String operations

		public void Write( CString value ) {
			if( value.IsNullOrEmpty ) { Write( uint.MaxValue ); return; }

			var length = value.Length;
			Write( length );
			Write( System.Environment.DefaultCodePage );
			WriteValues( value.GetChars(), length * sizeof( value[0] ) );
		}

		public void Write( SbcsString value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( value.Length );
			Write( value.CodePage );
			WriteValues( value.GetChars(), value.ByteLength );
		}

		public void Write( Utf8String value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( value.Length );
			Write( value.ByteLength );
			WriteValues( value.GetChars(), value.ByteLength );
		}

		public void Write( Utf16String value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( value.Length );
			WriteValues( value.GetChars(), value.Length );
		}

		public void Write( Utf32String value ) {
			if( value == null ) { Write( uint.MaxValue ); return; }

			Write( value.Length );
			WriteValues( value.GetChars(), value.Length );
		}

		public void WriteNullTerminated( CString value ) {
			if( value.IsNullOrEmpty ) { Write( ( byte ) 0 ); return; }

			WriteValues( value.GetChars(), value.Length + 1 );
		}

		public void WriteNullTerminated( SbcsString value ) {
			if( value == null ) { Write( ( byte ) 0 ); return; }

			WriteValues( value.GetChars(), value.Length + 1 );
		}

		public void WriteNullTerminated( Utf8String value ) {
			if( value == null ) { Write( ( byte ) 0 ); return; }

			WriteValues( value.GetChars(), value.ByteLength + 1 );
		}

		public void WriteNullTerminated( Utf16String value ) {
			if( value == null ) { Write( ( ushort ) 0 ); return; }

			WriteValues( value.GetChars(), value.Length + 1 );
		}

		public void WriteNullTerminated( Utf32String value ) {
			if( value == null ) { Write( ( uint ) 0 ); return; }

			WriteValues( value.GetChars(), value.Length + 1 );
		}

		#endregion

		public void Flush( FlushKind flushKind = FlushKind.DeepWrite ) { BaseStream.Flush( flushKind ); }

		public void WriteCompact( uint_littleendian value ) {
			Debug.Assert( value < 0x40000000 );

			var bytes = ( byte* ) &value;

			if( value < 0x80 )
				Write( bytes[0] );
			else if( value < 0x4000 ) {
				bytes[1] |= 0x80;
				Write( *( ushort_bigendian* ) bytes );
			}
			else {
				bytes[3] |= 0xC0;
				Write( *( uint_bigendian* ) bytes );
			}
		}

		public void WriteCompact( int_littleendian value ) {
			Debug.Assert( value >= -0x20000000 && value < 0x20000000 );

			if( value >= 0 ) {
				WriteCompact( ( uint ) value << 1 );
				return;
			}

			WriteCompact( ( ( ~( uint ) value ) << 1 ) | 1 );
		}
	}
}