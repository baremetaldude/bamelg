//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading;

namespace System.Threading {
	public abstract class Dispatcher {
		public Dispatcher() {
		}

		#region thread-safe API

		#region unbiased alarms, unaffected by system clock changes

		public AlarmUnbiased* BeginAlarmUnbiased( TimeDuration interval, Functors.Action action ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + interval, interval, action );
		}

		public AlarmUnbiased* BeginAlarmUnbiasedAligned( TimeDuration interval, Functors.Action action ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now.Ceil( interval ), interval, action );
		}

		public AlarmUnbiased* BeginAlarmUnbiasedAlignedToUTC( TimeDuration interval, Functors.Action action ) {
			return BeginAlarmUnbiased( new TimeDuration( interval.Ticks - ( DateTimeUTC.UtcNow % interval ).Ticks ), interval, action );
		}

		public AlarmUnbiased* BeginAlarmUnbiased( TimeDuration initialExpiration, TimeDuration interval, Functors.Action action ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + initialExpiration, interval, action );
		}

		public AlarmUnbiased* BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend initialExpirationUnbiased, TimeDuration interval, Functors.Action action ) {
			return ( AlarmUnbiased* ) BeginAlarm( initialExpirationUnbiased, interval, action );
		}

		public AlarmUnbiased* ScheduleUnbiased( TimeDuration initialExpiration, Functors.Action action ) {
			return ScheduleUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + initialExpiration, action );
		}

		public AlarmUnbiased* ScheduleUnbiased( TimeStamp.BootTime_ExcludeSuspend initialExpirationUnbiased, Functors.Action action ) {
			return ( AlarmUnbiased* ) BeginAlarm( initialExpirationUnbiased, TimeDuration.Zero, action );
		}

		public AlarmUnbiased* BeginAlarmUnbiased( TimeDuration interval, Functors.Action<void*> action, void* data ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + interval, interval, action, data );
		}

		public AlarmUnbiased* BeginAlarmUnbiasedAligned( TimeDuration interval, Functors.Action<void*> action, void* data ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now.Ceil( interval ), interval, action, data );
		}

		public AlarmUnbiased* BeginAlarmUnbiased( TimeDuration initialExpiration, TimeDuration interval, Functors.Action<void*> action, void* data ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + initialExpiration, interval, action, data );
		}

		public AlarmUnbiased* BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend initialExpirationUnbiased, TimeDuration interval, Functors.Action<void*> action, void* data ) {
			return ( AlarmUnbiased* ) BeginAlarm( initialExpirationUnbiased, interval, action, null, data );
		}

		public AlarmUnbiased* ScheduleUnbiased( TimeDuration initialExpiration, Functors.Action<void*> action, void* data ) {
			return ScheduleUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + initialExpiration, action, data );
		}

		public AlarmUnbiased* ScheduleUnbiased( TimeStamp.BootTime_ExcludeSuspend initialExpirationUnbiased, Functors.Action<void*> action, void* data ) {
			return ( AlarmUnbiased* ) BeginAlarm( initialExpirationUnbiased, TimeDuration.Zero, action, null, data );
		}

		public AlarmUnbiased* BeginAlarmUnbiased( TimeDuration interval, Delegates.Action action ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + interval, interval, action );
		}

		public AlarmUnbiased* BeginAlarmUnbiasedAligned( TimeDuration interval, Delegates.Action action ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now.Ceil( interval ), interval, action );
		}

		public AlarmUnbiased* BeginAlarmUnbiasedUtcAligned( TimeDuration interval, Delegates.Action action ) {
			return BeginAlarmUnbiased( new TimeDuration( interval.Ticks - ( DateTimeUTC.UtcNow % interval ).Ticks ), interval, action );
		}

		public AlarmUnbiased* BeginAlarmUnbiased( TimeDuration initialExpiration, TimeDuration interval, Delegates.Action action ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + initialExpiration, interval, action );
		}

		public AlarmUnbiased* BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend initialExpirationUnbiased, TimeDuration interval, Delegates.Action action ) {
			return ( AlarmUnbiased* ) BeginAlarm( initialExpirationUnbiased, interval, action );
		}

		public AlarmUnbiased* ScheduleUnbiased( TimeDuration initialExpiration, Delegates.Action action ) {
			return ScheduleUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + initialExpiration, action );
		}

		public AlarmUnbiased* ScheduleUnbiased( TimeStamp.BootTime_ExcludeSuspend initialExpirationUnbiased, Delegates.Action action ) {
			return ( AlarmUnbiased* ) BeginAlarm( initialExpirationUnbiased, TimeDuration.Zero, action );
		}

		public AlarmUnbiased* BeginAlarmUnbiased( TimeDuration interval, DPC* dpc ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + interval, interval, dpc );
		}

		public AlarmUnbiased* BeginAlarmUnbiasedAligned( TimeDuration interval, DPC* dpc ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now.Ceil( interval ), interval, dpc );
		}

		public AlarmUnbiased* BeginAlarmUnbiased( TimeDuration initialExpiration, TimeDuration interval, DPC* dpc ) {
			return BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + initialExpiration, interval, dpc );
		}

		public AlarmUnbiased* BeginAlarmUnbiased( TimeStamp.BootTime_ExcludeSuspend initialExpirationUnbiased, TimeDuration interval, DPC* dpc ) {
			return ( AlarmUnbiased* ) BeginAlarm( initialExpirationUnbiased, interval, bitcast<Functors.Action<void*>>( dpc->OnAction ), bitcast<Functors.Action<void*>>( dpc->OnDispose ), dpc );
		}

		public AlarmUnbiased* ScheduleUnbiased( TimeDuration initialExpiration, DPC* dpc ) {
			return ScheduleUnbiased( TimeStamp.BootTime_ExcludeSuspend.Now + initialExpiration, dpc );
		}

		public AlarmUnbiased* ScheduleUnbiased( TimeStamp.BootTime_ExcludeSuspend initialExpirationUnbiased, DPC* dpc ) {
			return ( AlarmUnbiased* ) BeginAlarm( initialExpirationUnbiased, TimeDuration.Zero, bitcast<Functors.Action<void*>>( dpc->OnAction ), bitcast<Functors.Action<void*>>( dpc->OnDispose ), dpc );
		}

		public void RemoveAlarm( AlarmUnbiased*& alarm ) {
			RemoveAlarm( AlarmKind.Unbiased, ( AlarmEntry* ) alarm );
			alarm = null;
		}

		#endregion

		#region UTC alarms

		public AlarmUtc* BeginAlarmUtc( TimeDuration interval, Functors.Action action ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow + interval, interval, action );
		}

		public AlarmUtc* BeginAlarmUtcAligned( TimeDuration interval, Functors.Action action ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow.Ceil( interval ), interval, action );
		}

		public AlarmUtc* BeginAlarmUtc( TimeDuration initialExpiration, TimeDuration interval, Functors.Action action ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow + initialExpiration, interval, action );
		}

		public AlarmUtc* BeginAlarmUtc( DateTimeUTC initialExpirationUtc, TimeDuration interval, Functors.Action action ) {
			return ( AlarmUtc* ) BeginAlarm( initialExpirationUtc, interval, action );
		}

		public AlarmUtc* ScheduleUtc( TimeDuration initialExpiration, Functors.Action action ) {
			return ScheduleUtc( DateTimeUTC.UtcNow + initialExpiration, action );
		}

		public AlarmUtc* ScheduleUtc( DateTimeUTC initialExpirationUtc, Functors.Action action ) {
			return ( AlarmUtc* ) BeginAlarm( initialExpirationUtc, TimeDuration.Zero, action );
		}

		public AlarmUtc* BeginAlarmUtc( TimeDuration interval, Functors.Action<void*> action, void* data ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow + interval, interval, action, data );
		}

		public AlarmUtc* BeginAlarmUtcAligned( TimeDuration interval, Functors.Action<void*> action, void* data ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow.Ceil( interval ), interval, action, data );
		}

		public AlarmUtc* BeginAlarmUtc( TimeDuration initialExpiration, TimeDuration interval, Functors.Action<void*> action, void* data ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow + initialExpiration, interval, action, data );
		}

		public AlarmUtc* BeginAlarmUtc( DateTimeUTC initialExpirationUtc, TimeDuration interval, Functors.Action<void*> action, void* data ) {
			return ( AlarmUtc* ) BeginAlarm( initialExpirationUtc, interval, action, null, data );
		}

		public AlarmUtc* ScheduleUtc( TimeDuration initialExpiration, Functors.Action<void*> action, void* data ) {
			return ScheduleUtc( DateTimeUTC.UtcNow + initialExpiration, action, data );
		}

		public AlarmUtc* ScheduleUtc( DateTimeUTC initialExpirationUtc, Functors.Action<void*> action, void* data ) {
			return ( AlarmUtc* ) BeginAlarm( initialExpirationUtc, TimeDuration.Zero, action, null, data );
		}

		public AlarmUtc* BeginAlarmUtc( TimeDuration interval, Delegates.Action action ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow + interval, interval, action );
		}

		public AlarmUtc* BeginAlarmUtcAligned( TimeDuration interval, Delegates.Action action ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow.Ceil( interval ), interval, action );
		}

		public AlarmUtc* BeginAlarmUtc( TimeDuration initialExpiration, TimeDuration interval, Delegates.Action action ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow + initialExpiration, interval, action );
		}

		public AlarmUtc* BeginAlarmUtc( DateTimeUTC initialExpirationUtc, TimeDuration interval, Delegates.Action action ) {
			return ( AlarmUtc* ) BeginAlarm( initialExpirationUtc, interval, action );
		}

		public AlarmUtc* ScheduleUtc( TimeDuration initialExpiration, Delegates.Action action ) {
			return ScheduleUtc( DateTimeUTC.UtcNow + initialExpiration, action );
		}

		public AlarmUtc* ScheduleUtc( DateTimeUTC initialExpirationUtc, Delegates.Action action ) {
			return ( AlarmUtc* ) BeginAlarm( initialExpirationUtc, TimeDuration.Zero, action );
		}

		public AlarmUtc* BeginAlarmUtc( TimeDuration interval, DPC* dpc ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow + interval, interval, dpc );
		}

		public AlarmUtc* BeginAlarmUtcAligned( TimeDuration interval, DPC* dpc ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow.Ceil( interval ), interval, dpc );
		}

		public AlarmUtc* BeginAlarmUtc( TimeDuration initialExpiration, TimeDuration interval, DPC* dpc ) {
			return BeginAlarmUtc( DateTimeUTC.UtcNow + initialExpiration, interval, dpc );
		}

		public AlarmUtc* BeginAlarmUtc( DateTimeUTC initialExpirationUtc, TimeDuration interval, DPC* dpc ) {
			return ( AlarmUtc* ) BeginAlarm( initialExpirationUtc, interval, bitcast<Functors.Action<void*>>( dpc->OnAction ), bitcast<Functors.Action<void*>>( dpc->OnDispose ), dpc );
		}

		public AlarmUtc* ScheduleUtc( TimeDuration initialExpiration, DPC* dpc ) {
			return ScheduleUtc( DateTimeUTC.UtcNow + initialExpiration, dpc );
		}

		public AlarmUtc* ScheduleUtc( DateTimeUTC initialExpirationUtc, DPC* dpc ) {
			return ( AlarmUtc* ) BeginAlarm( initialExpirationUtc, TimeDuration.Zero, bitcast<Functors.Action<void*>>( dpc->OnAction ), bitcast<Functors.Action<void*>>( dpc->OnDispose ), dpc );
		}

		public void RemoveAlarm( AlarmUtc*& alarm ) {
			RemoveAlarm( AlarmKind.Utc, ( AlarmEntry* ) alarm );
			alarm = null;
		}

		#endregion

		#region tasks

		public void BeginInvoke( Functors.Action action ) {
			if( action == null ) return;
			if( IsDispatchingThread ) { action(); return; }

			EnqueueInvoke( DPC.Create( action ) );
		}

		public void BeginInvoke<T0>( Functors.Action<T0> action, T0 p0 ) {
			if( action == null ) return;
			if( IsDispatchingThread ) { action( p0 ); return; }

			EnqueueInvoke( DPC.Create<T0>( action, p0 ) );
		}

		public void BeginInvoke( Delegates.Action action ) {
			if( action == null ) return;
			if( IsDispatchingThread ) { action(); return; }

			EnqueueInvoke( DPC.Create( action ) );
		}

		public void BeginInvoke<T0>( Delegates.Action<T0> action, T0 p0 ) {
			if( action == null ) return;
			if( IsDispatchingThread ) { action( p0 ); return; }

			EnqueueInvoke( DPC.Create<T0>( action, p0 ) );
		}

		public void EnqueueInvoke( Functors.Action action ) {
			EnqueueInvoke( DPC.Create( action ) );
		}

		public void EnqueueInvoke<T0>( Functors.Action<T0> action, T0 p0 ) {
			EnqueueInvoke( DPC.Create<T0>( action, p0 ) );
		}

		public void EnqueueInvoke( Delegates.Action action ) {
			EnqueueInvoke( DPC.Create( action ) );
		}

		public void EnqueueInvoke<T0>( Delegates.Action<T0> action, T0 p0 ) {
			EnqueueInvoke( DPC.Create<T0>( action, p0 ) );
		}

		public void Invoke( Functors.Action action ) {
			Debug.Assert( IsDispatchingStarted );

			if( IsDispatchingThread ) {
				action();
				return;
			}

			var wait = new Semaphore();
			var task = new DPC<Functors.Action, Semaphore*> {
				P0 = action,
				P1 = &wait,
				OnAction = data => {
					var passedTask = ( DPC<Functors.Action, Semaphore*>* ) data;
					passedTask->P0();
					passedTask->P1->Post(); // task completed
				},
				OnDispose = null
			};
			task.OnActionDispose = task.OnAction;

			EnqueueInvoke( &task );
			wait.Wait(); // wait for task completion
		}

		public void Invoke<T0>( Functors.Action<T0> action, T0 p0 ) {
			Debug.Assert( IsDispatchingStarted );

			if( IsDispatchingThread ) {
				action( p0 );
				return;
			}

			var wait = new Semaphore();
			var task = new DPC<Functors.Action<T0>, T0, Semaphore*> {
				P0 = action,
				P1 = p0,
				P2 = &wait,
				OnAction = data => {
					var passedTask = ( DPC<Functors.Action<T0>, T0, Semaphore*>* ) data;
					passedTask->P0( passedTask->P1 );
					passedTask->P2->Post(); // task completed
				},
				OnDispose = null
			};
			task.OnActionDispose = task.OnAction;

			EnqueueInvoke( &task );
			wait.Wait(); // wait for task completion
		}

		public void Invoke( Delegates.Action action ) {
			Debug.Assert( IsDispatchingStarted );

			if( IsDispatchingThread ) {
				action();
				return;
			}

			var wait = new Semaphore();
			var task = new DPC<Delegates.Action, Semaphore*> {
				P0 = action,
				P1 = &wait,
				OnAction = data => {
					var passedTask = ( DPC<Delegates.Action, Semaphore*>* ) data;
					passedTask->P0();
					passedTask->P1->Post(); // task completed
				},
				OnDispose = null
			};
			task.OnActionDispose = task.OnAction;

			EnqueueInvoke( &task );
			wait.Wait(); // wait for task completion
		}

		public void Invoke<T0>( Delegates.Action<T0> action, T0 p0 ) {
			Debug.Assert( IsDispatchingStarted );

			if( IsDispatchingThread ) {
				action( p0 );
				return;
			}

			var wait = new Semaphore();
			var task = new DPC<Delegates.Action<T0>, T0, Semaphore*> {
				P0 = action,
				P1 = p0,
				P2 = &wait,
				OnAction = data => {
					var passedTask = ( DPC<Delegates.Action<T0>, T0, Semaphore*>* ) data;
					passedTask->P0( passedTask->P1 );
					passedTask->P2->Post(); // task completed
				},
				OnDispose = null
			};
			task.OnActionDispose = task.OnAction;

			EnqueueInvoke( &task );
			wait.Wait(); // wait for task completion
		}

		#endregion

		#endregion // thread-safe API

		#region impl

		private Mutex _taskLock = new Mutex();
		private DPC* _taskHead = null, _taskTail = null;

		private Mutex _alarmLock = new Mutex();
		private PagedPool<AlarmEntry> _alarmsPool = new PagedPool<AlarmEntry>();
		private List<AlarmExecuteInfo> _freedAlarms = new List<AlarmExecuteInfo>();
		private TrackablePriorityQueue<AlarmEntry*> _utcAlarms = new TrackablePriorityQueue<AlarmEntry*>( ( x, y ) => y->Expiration.CompareTo( x->Expiration ) );
		private TrackablePriorityQueue<AlarmEntry*> _unbiasedAlarms = new TrackablePriorityQueue<AlarmEntry*>( ( x, y ) => y->Expiration.CompareTo( x->Expiration ) );

		private List<AlarmExecuteInfo> _readyAlarms = new List<AlarmExecuteInfo>();

		private enum AlarmKind {
			Utc,
			Unbiased,
		}

		private struct AlarmExecuteInfo {
			public Functors.Action<void*> Action;
			public void* Payload;
		}

		private struct AlarmEntry : AlarmExecuteInfo, IFormattable {
			public Functors.Action<void*> Dispose;

			public ulong Expiration;
			public TimeDuration Period;

			public uint TrackingIndex;

			public bool IsOneShot { get { return Period == TimeDuration.Zero; } }

			~AlarmEntry() {
				if( Dispose != null ) Dispose( Payload );
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Append( &this );
				builder.AppendFormat( @"( Expiration = ""{0:yyyy.MM.dd HH:mm:ss.fff}"", Period = ""{1}"", Index = {2} )", new DateTimeUTC( Expiration ), Period, TrackingIndex );
			}
		}

		private AlarmEntry* BeginAlarm( DateTimeUTC initialExpiration, TimeDuration interval, Functors.Action action ) {
			return BeginAlarm( initialExpiration, interval, passedData => bitcast<Functors.Action>( passedData )(), null, bitcast<void*>( action ) );
		}

		private AlarmEntry* BeginAlarm( DateTimeUTC initialExpiration, TimeDuration interval, Delegates.Action action ) {
			cast<RuntimeObjectBase>( action ).AddReference();

			return BeginAlarm( initialExpiration, interval, passedData => {
				var& passedAction = *( Delegates.Action* ) &passedData; // dont touch refcount here
				passedAction();
			}, passedData => {
				var& passedAction = *( Delegates.Action* ) &passedData; // dont touch refcount here
				cast<RuntimeObjectBase>( passedAction ).ReleaseReference();
			}, bitcast<void*>( action ) );
		}

		private AlarmEntry* BeginAlarm( TimeStamp.BootTime_ExcludeSuspend initialExpiration, TimeDuration interval, Functors.Action action ) {
			return BeginAlarm( initialExpiration, interval, passedData => bitcast<Functors.Action>( passedData )(), null, bitcast<void*>( action ) );
		}

		private AlarmEntry* BeginAlarm( TimeStamp.BootTime_ExcludeSuspend initialExpiration, TimeDuration interval, Delegates.Action action ) {
			cast<RuntimeObjectBase>( action ).AddReference();

			return BeginAlarm( initialExpiration, interval, passedData => {
				var& passedAction = *( Delegates.Action* ) &passedData; // dont touch refcount here
				passedAction();
			}, passedData => {
				var& passedAction = *( Delegates.Action* ) &passedData; // dont touch refcount here
				cast<RuntimeObjectBase>( passedAction ).ReleaseReference();
			}, bitcast<void*>( action ) );
		}

		private AlarmEntry* BeginAlarm( DateTimeUTC initialExpiration, TimeDuration interval, Functors.Action<void*> action, Functors.Action<void*> dispose, void* payload ) {
			if( !Assert.IsTrue( interval >= TimeDuration.Zero ) ) return null;

			using( _alarmLock.LockRegion() ) {
				var alarm = _alarmsPool.Allocate();

				alarm->Expiration = ( ulong ) initialExpiration.Ticks;
				alarm->Period = interval;

				alarm->Action = action;
				alarm->Dispose = dispose;
				alarm->Payload = payload;

				alarm->TrackingIndex = _utcAlarms.Enqueue( alarm );
				if( _utcAlarms.Top == alarm ) NotifyNewDispatcherTasks();

				TraceAlarmAdd( alarm );
				return alarm;
			}
		}

		private AlarmEntry* BeginAlarm( TimeStamp.BootTime_ExcludeSuspend initialExpiration, TimeDuration interval, Functors.Action<void*> action, Functors.Action<void*> dispose, void* payload ) {
			if( !Assert.IsTrue( interval >= TimeDuration.Zero ) ) return null;

			using( _alarmLock.LockRegion() ) {
				var alarm = _alarmsPool.Allocate();

				alarm->Expiration = ( ulong ) initialExpiration.Ticks;
				alarm->Period = interval;

				alarm->Action = action;
				alarm->Dispose = dispose;
				alarm->Payload = payload;

				alarm->TrackingIndex = _unbiasedAlarms.Enqueue( alarm );
				if( _unbiasedAlarms.Top == alarm ) NotifyNewDispatcherTasks();

				TraceAlarmAdd( alarm );
				return alarm;
			}
		}

		private void RemoveAlarm( AlarmKind kind, AlarmEntry* alarm ) {
			if( alarm == null ) return;

			var update = false;

			using( _alarmLock.LockRegion() ) {
				if( alarm->TrackingIndex == uint.MaxValue ) return;

				AlarmEntry* removed;

				switch( kind ) {
					case AlarmKind.Unbiased:
						update = _unbiasedAlarms.Top == alarm;
						removed = _unbiasedAlarms.Remove( alarm->TrackingIndex );
						break;

					case AlarmKind.Utc:
						update = _utcAlarms.Top == alarm;
						removed = _utcAlarms.Remove( alarm->TrackingIndex );
						break;
				}

				TraceAlarmRemoved( alarm );

				alarm->TrackingIndex = uint.MaxValue;

				if( removed == alarm ) {
					if( alarm->Dispose != null ) {
						_freedAlarms.Add( new AlarmExecuteInfo { Payload = alarm->Payload, Action = alarm->Dispose } );
						alarm->Dispose = null;
					}

					_alarmsPool.Free( alarm );
				}
				else
					Debug.Fail( "Bad alarm specified" );
			}

			if( update ) NotifyNewDispatcherTasks();
		}

		private void DumpAlarms() {
			Assert.IsTrue( _unbiasedAlarms.IsValid() );
			foreach( var alarm in _unbiasedAlarms )
				Console.WriteLine( "Unbiased alarm: {0}", *alarm );

			Assert.IsTrue( _utcAlarms.IsValid() );
			foreach( var alarm in _utcAlarms )
				Console.WriteLine( "UTC alarm:      {0}", *alarm );
		}

		public void BeginInvoke( DPC* task ) {
			if( task == null ) return;

			if( IsDispatchingThread ) {
				task->OnActionDispose( task );
				return;
			}

			EnqueueInvoke( task );
		}

		public void EnqueueInvoke( DPC* task ) {
			if( task == null ) return;

			task->Next = null;

			using( _taskLock.LockRegion() ) {
				if( _taskTail == null ) {
					_taskHead = _taskTail = task;
				}
				else {
					_taskTail->Next = task;
					_taskTail = task;
				}
			}

			NotifyNewDispatcherTasks();
		}

		#endregion

		#region event loop integration

		protected abstract void NotifyNewDispatcherTasks();
		public abstract bool IsDispatchingThread { get; }
		public abstract bool IsDispatchingStarted { get; }

		public TimeStamp.BootTime_ExcludeSuspend UnbiasedNow;
		public DateTimeUTC UtcNow; // when first notification wake up blocking thread

		public struct AlarmUtc { }
		public struct AlarmUnbiased { }

		public void ExecuteTasks() {
			DPC* first = null;

			using( _taskLock.LockRegion() ) {
				first = _taskHead;
				_taskHead = _taskTail = null;
			}

			for( var task = first; task != null; ) {
				var next = task->Next;
				DPC.RunAndDispose( task );
				task = next;
			}
		}

		public void CancelTasks() {
			DPC* first = null;

			using( _taskLock.LockRegion() ) {
				first = _taskHead;
				_taskHead = _taskTail = null;
			}

			for( var task = first; task != null; ) {
				var next = task->Next;
				DPC.Dispose( task );
				task = next;
			}
		}

		private void OnAlarm( DateTimeUTC time ) {
			var ticks = time.Ticks;
			var isQueueUpdated = _utcAlarms.Count > 0 && _utcAlarms.Peek()->Expiration <= ticks;

			while( _utcAlarms.Count > 0 ) {
				var alarm = _utcAlarms.Peek();
				if( alarm->Expiration > ticks )
					break;

				_readyAlarms.Add( *alarm );

				TraceAlarmReady( alarm );

				if( alarm->IsOneShot ) {
					TraceAlarmRemoved( alarm );

					_utcAlarms.Dequeue();

					if( alarm->Dispose != null ) {
						_readyAlarms.Add( new AlarmExecuteInfo { Payload = alarm->Payload, Action = alarm->Dispose } );
						alarm->Dispose = null;
					}

					alarm->TrackingIndex = uint.MaxValue;
					_alarmsPool.Free( alarm );
				}
				else {
					var expirations = ( ticks - alarm->Expiration ) / alarm->Period.Ticks;
					alarm->Expiration += alarm->Period.Ticks * ( expirations + 1 ); // heap now invalid

					TraceAlarmRearmed( alarm );
					_utcAlarms.Replace( alarm->TrackingIndex, alarm );
				}
			}

			if( isQueueUpdated ) TraceAlarmQueueUpdate();
		}

		private void OnAlarm( TimeStamp.BootTime_ExcludeSuspend time ) {
			var ticks = time.Ticks;
			var isQueueUpdated = _unbiasedAlarms.Count > 0 && _unbiasedAlarms.Peek()->Expiration <= ticks;

			while( _unbiasedAlarms.Count > 0 ) {
				var alarm = _unbiasedAlarms.Peek();
				if( alarm->Expiration > ticks )
					break;

				_readyAlarms.Add( *alarm );

				TraceAlarmReady( alarm );

				if( alarm->IsOneShot ) {
					TraceAlarmRemoved( alarm );

					_unbiasedAlarms.Dequeue();

					if( alarm->Dispose != null ) {
						_readyAlarms.Add( new AlarmExecuteInfo { Payload = alarm->Payload, Action = alarm->Dispose } );
						alarm->Dispose = null;
					}

					alarm->TrackingIndex = uint.MaxValue;
					_alarmsPool.Free( alarm );
				}
				else {
					var expirations = ( ticks - alarm->Expiration ) / alarm->Period.Ticks;
					alarm->Expiration += alarm->Period.Ticks * ( expirations + 1 ); // priority queue invalid now

					TraceAlarmRearmed( alarm );
					_unbiasedAlarms.Replace( alarm->TrackingIndex, alarm );
				}
			}

			if( isQueueUpdated ) TraceAlarmQueueUpdate();
		}

		protected void FinalizeAlarms() {
			using( _alarmLock.LockRegion() ) {
				foreach( var alarm in _freedAlarms )
					alarm.Action( alarm.Payload );

				_freedAlarms.Clear();
				_utcAlarms.Clear();
				_unbiasedAlarms.Clear();
			}
		}

		protected bool FindReadyAlarms() {
			_readyAlarms.Clear();

			using( _alarmLock.LockRegion() ) {
				foreach( var alarm in _freedAlarms )
					alarm.Action( alarm.Payload );
				_freedAlarms.Clear();

				OnAlarm( UtcNow );
				OnAlarm( UnbiasedNow );
			}

			return _readyAlarms.Count > 0;
		}

		protected void ExecuteReadyAlarms() {
			foreach( var alarm in _readyAlarms )
				alarm.Action( alarm.Payload );

			_readyAlarms.Clear();
		}

		protected void OnAlarm() {
			if( FindReadyAlarms() )
				ExecuteReadyAlarms();
		}

		protected TimeDuration GetWaitTime() {
			using( _alarmLock.LockRegion() ) {
				var utcTimeout = GetWaitTime( AlarmKind.Utc );
				var unbiasedTimeout = GetWaitTime( AlarmKind.Unbiased );
				return utcTimeout < unbiasedTimeout ? utcTimeout : unbiasedTimeout;
			}
		}

		private TimeDuration GetWaitTime( AlarmKind kind ) {
			switch( kind ) {
				case AlarmKind.Utc:
					if( _utcAlarms.Count > 0 ) {
						var dt = new TimeDuration( _utcAlarms.Top->Expiration - UtcNow.Ticks );

						if( dt > TimeDuration.Zero )
							return dt;

						return TimeDuration.Zero;
					}
					break;

				case AlarmKind.Unbiased:
					if( _unbiasedAlarms.Count > 0 ) {
						var dt = new TimeDuration( _unbiasedAlarms.Top->Expiration - UnbiasedNow.Ticks );

						if( dt > TimeDuration.Zero )
							return dt;

						return TimeDuration.Zero;
					}

					break;
			}

			return TimeDuration.MaxValue;
		}

		#endregion

		#region tracing

		protected const string TraceConditionString = "TRACE_EVENT_LOOP";

		public bool Tracing { get; set; }
		public bool TracingAlarmQueue { get; set; }

		protected static Console.OutputAttributes TraceStyleNormal = new Console.OutputAttributes() { BackgroundColor = ConsoleColor.Blue };
		protected static Console.OutputAttributes TraceStyleHigh = new Console.OutputAttributes() { BackgroundColor = ConsoleColor.Blue, Bold = true };
		protected static Console.OutputAttributes TraceStyleError = new Console.OutputAttributes() { BackgroundColor = ConsoleColor.Red, Bold = true };

		[Conditional( ConditionString = TraceConditionString )]
		private void TraceAlarmAdd( AlarmEntry* alarm ) {
			if( !Tracing ) return;

			using( Console.AttributedRegion( TraceStyleHigh ) )
				Console.WriteLine( "Dispatcher: Alarm {0} added", *alarm );

			if( TracingAlarmQueue ) DumpAlarms();
		}

		[Conditional( ConditionString = TraceConditionString )]
		private void TraceAlarmRemoved( AlarmEntry* alarm ) {
			if( !Tracing ) return;

			using( Console.AttributedRegion( TraceStyleHigh ) )
				Console.WriteLine( "Dispatcher: Alarm {0} removed", *alarm );

			if( TracingAlarmQueue ) DumpAlarms();
		}

		[Conditional( ConditionString = TraceConditionString )]
		private void TraceAlarmRearmed( AlarmEntry* alarm ) {
			if( !Tracing ) return;

			using( Console.AttributedRegion( TraceStyleHigh ) )
				Console.WriteLine( "Dispatcher: Alarm {0} rearmed", *alarm );

			if( TracingAlarmQueue ) DumpAlarms();
		}

		[Conditional( ConditionString = TraceConditionString )]
		private void TraceAlarmReady( AlarmEntry* alarm ) {
			if( !Tracing ) return;

			using( Console.AttributedRegion( TraceStyleNormal ) )
				Console.WriteLine( "Dispatcher: Alarm {0} ready", *alarm );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private void TraceAlarmQueueUpdate() {
			if( !TracingAlarmQueue ) return;

			if( TracingAlarmQueue ) DumpAlarms();
		}

		#endregion
	}
}