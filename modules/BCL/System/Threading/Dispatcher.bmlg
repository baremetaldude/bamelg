//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.Collections;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading;

namespace System.Threading {
	public abstract class Dispatcher {
		public Dispatcher() {
		}

		protected abstract void NotifyNewDispatcherTasks();
		protected abstract void SetAlarm( AlarmKind kind, TimeSpan time );
		protected abstract void StopAlarm( AlarmKind kind );
		protected abstract bool IsDispatchingThread { get; }

		public DateTime NotificationStartTime, NotificationStartTimeUtc; // when first notification wake up blocking thread

		protected TimeSpan GetWaitTime() {
			var utcTimeout = GetWaitTime( AlarmKind.Utc );
			var unbiasedTimeout = GetWaitTime( AlarmKind.Unbiased );
			return utcTimeout < unbiasedTimeout ? utcTimeout : unbiasedTimeout;
		}

		protected TimeSpan GetWaitTime( AlarmKind kind ) {
			switch( kind ) {
				case AlarmKind.Utc:
					if( _utcAlarms.Count > 0 ) {
						var now = DateTime.UtcNow;
						var dt = _utcAlarms.Top->Expiration - now;
						
						if( dt > TimeSpan.Zero )
							return dt;

						// OnAlarm( AlarmKind.Utc, now, _utcAlarms );
						return TimeSpan.Zero;
					}
					break;

				case AlarmKind.Unbiased:
					if( _unbiasedAlarms.Count > 0 ) {
						var now = DateTime.UnbiasedNow;
						var dt = _unbiasedAlarms.Top->Expiration - now;

						if( dt > TimeSpan.Zero )
							return dt;

						// OnAlarm( AlarmKind.Unbiased, now, _unbiasedAlarms );
						return TimeSpan.Zero;
					}

					break;
			}

			return TimeSpan.MaxValue;
		}

		private struct TaskEntry {
			public TaskEntry* Next;
			public Functors.Action<TaskEntry*> Action;
		}

		private struct TaskEntry<T0> : TaskEntry { public T0 P0; }
		private struct TaskEntry<T0, T1> : TaskEntry { public T0 P0; public T1 P1; }
		private struct TaskEntry<T0, T1, T2> : TaskEntry { public T0 P0; public T1 P1; public T2 P2; }

		protected enum AlarmKind {
			Utc,
			Unbiased,
		}

		private struct AlarmEntry {
			public DateTime Expiration;
			public TimeSpan Period;

			public Functors.Action<void*> Action;
			public Functors.Action<void*> Dispose;
			public void* Payload;

			public bool OneShot { get; set; }

			~AlarmEntry() {
				if( Dispose != null ) Dispose( Payload );
			}
		}

		private Mutex _lock = new Mutex();

		private Mutex _taskLock = new Mutex();
		private TaskEntry* _taskHead = null, _taskTail = null;

		private PagedPool<AlarmEntry> _alarmsPool = new PagedPool<AlarmEntry>();
		private TrackablePriorityQueue<AlarmEntry*> _utcAlarms = new TrackablePriorityQueue<AlarmEntry*>( ( x, y ) => x->Expiration < y->Expiration );
		private TrackablePriorityQueue<AlarmEntry*> _unbiasedAlarms = new TrackablePriorityQueue<AlarmEntry*>( ( x, y ) => x->Expiration < y->Expiration );

		public void ExecuteTasks() {
			TaskEntry* first = null;

			using( _taskLock.LockRegion() ) {
				first = _taskHead;
				_taskHead = _taskTail = null;
			}

			for( var task = first; task != null; ) {
				var next = task->Next;
				task->Action( task );
				task = next;
			}
		}

		private void OnAlarm( AlarmKind kind, DateTime time, TrackablePriorityQueue<AlarmEntry*> alarms ) {
			while( alarms.Count > 0 ) {
				var alarm = alarms.Peek();
				if( alarm->Expiration >= time )
					break;

				var expirations = ( time - alarm->Expiration ).Ticks / alarm->Period.Ticks;
				alarm->Action( alarm->Payload );

				alarms.Dequeue();

				if( alarm->OneShot ) {
					_alarmsPool.Free( alarm );
				}
				else {
					alarm->Expiration += alarm->Period * ( expirations + 1 );
					alarms.Enqueue( alarm );
				}
			}

			if( alarms.Count == 0 ) StopAlarm( kind );
			else SetAlarm( kind, alarms.Peek()->Expiration - time );
		}

		public void OnUtcAlarm() {
			OnAlarm( AlarmKind.Utc, NotificationStartTimeUtc, _utcAlarms );
		}

		public void OnUnbiasedAlarm() {
			OnAlarm( AlarmKind.Unbiased, NotificationStartTime, _unbiasedAlarms );
		}

		private void UpdateUtcAlarms() {
			var now = DateTime.UtcNow;
			var dt = _utcAlarms.Top->Expiration - now;

			if( dt > TimeSpan.Zero )
				SetAlarm( AlarmKind.Utc, dt );
			else
				OnAlarm( AlarmKind.Utc, now, _utcAlarms );
		}

		private void UpdateUnbiasedAlarms() {
			var now = DateTime.UnbiasedNow;
			var dt = _unbiasedAlarms.Top->Expiration - now;

			if( dt > TimeSpan.Zero )
				SetAlarm( AlarmKind.Unbiased, dt );
			else
				OnAlarm( AlarmKind.Unbiased, now, _unbiasedAlarms );
		}

		/// @{ thread-safe

		/// @{ unbiased
		public int BeginAlarm( TimeSpan interval, Functors.Action action, bool oneShot = false ) {
			return BeginAlarm( interval, interval, action, oneShot );
		}

		public int BeginAlarm( TimeSpan initialExpiration, TimeSpan interval, Functors.Action action, bool oneShot = false ) {
			return BeginAlarm( AlarmKind.Unbiased, DateTime.UnbiasedNow + initialExpiration, interval, action, oneShot );
		}

		public int BeginAlarm( TimeSpan interval, Functors.Action<void*> action, void* data, bool oneShot = false ) {
			return BeginAlarm( interval, interval, action, data, oneShot );
		}

		public int BeginAlarm( TimeSpan initialExpiration, TimeSpan interval, Functors.Action<void*> action, void* data, bool oneShot = false ) {
			return BeginAlarm( AlarmKind.Unbiased, DateTime.UnbiasedNow + initialExpiration, interval, action, null, data, oneShot );
		}

		public int BeginAlarm( TimeSpan interval, Delegates.Action action, bool oneShot = false ) {
			return BeginAlarm( interval, interval, action, oneShot );
		}

		public int BeginAlarm( TimeSpan initialExpiration, TimeSpan interval, Delegates.Action action, bool oneShot = false ) {
			return BeginAlarm( AlarmKind.Unbiased, DateTime.UnbiasedNow + initialExpiration, interval, action, oneShot );
		}

		public void RemoveAlarm( int alarmId ) {
			RemoveAlarm( AlarmKind.Unbiased, alarmId );
		}
		/// @}


		/// @{ UTC
		public int BeginUtcAlarm( TimeSpan interval, Functors.Action action, bool oneShot = false ) {
			return BeginAlarm( interval, interval, action, oneShot );
		}

		public int BeginUtcAlarm( TimeSpan initialExpiration, TimeSpan interval, Functors.Action action, bool oneShot = false ) {
			return BeginAlarm( AlarmKind.Utc, DateTime.UtcNow + initialExpiration, interval, action, oneShot );
		}

		public int BeginUtcAlarm( TimeSpan interval, Delegates.Action action, bool oneShot = false ) {
			return BeginUtcAlarm( interval, interval, action, oneShot );
		}

		public int BeginUtcAlarm( TimeSpan initialExpiration, TimeSpan interval, Delegates.Action action, bool oneShot = false ) {
			return BeginAlarm( AlarmKind.Utc, DateTime.UtcNow + initialExpiration, interval, action, oneShot );
		}

		public void RemoveUtcAlarm( int alarmId ) {
			RemoveAlarm( AlarmKind.Utc, alarmId );
		}
		/// @}

		/// @{ impl
		private int BeginAlarm( AlarmKind kind, DateTime initialExpiration, TimeSpan interval, Functors.Action action, bool oneShot = false ) {
			return BeginAlarm( kind, initialExpiration, interval, passedData => {
				var passedAction = bitcast<Functors.Action>( passedData );
				passedAction();
			}, null, bitcast<void*>( action ), oneShot );
		}

		private int BeginAlarm( AlarmKind kind, DateTime initialExpiration, TimeSpan interval, Delegates.Action action, bool oneShot = false ) {
			cast<RuntimeObjectBase>( action ).AddReference();

			return BeginAlarm( kind, initialExpiration, interval, passedData => {
				var& passedAction = *( Delegates.Action* ) &passedData; // dont touch refcount here
				passedAction();
			}, passedData => {
				var& passedAction = *( Delegates.Action* ) &passedData; // dont touch refcount here
				cast<RuntimeObjectBase>( passedAction ).ReleaseReference();
			}, bitcast<void*>( action ), oneShot );
		}

		private int BeginAlarm( AlarmKind kind, DateTime initialExpiration, TimeSpan interval, Functors.Action<void*> action, Functors.Action<void*> dispose, void* payload, bool oneShot = false ) {
			using( _lock.LockRegion() ) { // guard _alarmsPool
				var alarm = _alarmsPool.Allocate();

				alarm->Expiration = initialExpiration;
				alarm->Period = interval;
				alarm->OneShot = oneShot;

				alarm->Action = action;
				alarm->Dispose = dispose;
				alarm->Payload = payload;

				int trackingIndex;
				switch( kind ) {
					case AlarmKind.Unbiased:
						trackingIndex = _unbiasedAlarms.Enqueue( alarm );
						if( _unbiasedAlarms.Top == alarm ) UpdateUnbiasedAlarms();
						break;

					case AlarmKind.Utc:
						trackingIndex = _utcAlarms.Enqueue( alarm );
						if( _utcAlarms.Top == alarm ) UpdateUtcAlarms();
						break;
				}

				return trackingIndex;
			}
		}

		private void RemoveAlarm( AlarmKind kind, int alarmId ) {
			using( _lock.LockRegion() ) { // guard _alarmsPool
				AlarmEntry* alarm;

				int trackingIndex;
				switch( kind ) {
					case AlarmKind.Unbiased:
						alarm = _unbiasedAlarms[alarmId];
						var update = _unbiasedAlarms.Top == alarm;
						_unbiasedAlarms.Remove( alarmId );
						if( update ) UpdateUnbiasedAlarms();
						break;

					case AlarmKind.Utc:
						alarm = _utcAlarms[alarmId];
						var update = _utcAlarms.Top == alarm;
						_utcAlarms.Remove( alarmId );
						if( update ) UpdateUtcAlarms();
						break;
				}

				_alarmsPool.Free( alarm );
			}
		}
		/// @}
		/// @}

		private void Enqueue( TaskEntry* task ) {
			task->Next = null;

			using( _taskLock.LockRegion() ) {
				if( _taskTail == null ) {
					_taskHead = _taskTail = task;
				}
				else {
					_taskTail->Next = task;
					_taskTail = task;
				}
			}

			NotifyNewDispatcherTasks();
		}

		public void BeginInvoke( Functors.Action action ) {
			var task = heapalloc TaskEntry<Functors.Action> {
				P0 = action,
				Action = data => {
					var passedTask = ( TaskEntry<Functors.Action>* ) data;
					passedTask->P0();
					heapfree passedTask;
				}
			};

			Enqueue( task );
		}

		public void BeginInvoke<T0>( Functors.Action<T0> action, T0 p0 ) {
			var task = heapalloc TaskEntry<Functors.Action<T0>, T0> {
				P0 = action,
				P1 = p0,
				Action = data => {
					var passedTask = ( TaskEntry<Functors.Action<T0>, T0>* ) data;
					passedTask->P0( passedTask->P1 );
					heapfree passedTask;
				}
			};

			Enqueue( task );
		}

		public void BeginInvoke( Delegates.Action action ) {
			var task = heapalloc TaskEntry<Delegates.Action> {
				P0 = action,
				Action = data => {
					var passedTask = ( TaskEntry<Delegates.Action>* ) data;
					passedTask->P0();
					heapfree passedTask;
				}
			};

			Enqueue( task );
		}

		public void BeginInvoke<T0>( Delegates.Action<T0> action, T0 p0 ) {
			var task = heapalloc TaskEntry<Delegates.Action<T0>, T0> {
				P0 = action,
				P1 = p0,
				Action = data => {
					var passedTask = ( TaskEntry<Delegates.Action<T0>, T0>* ) data;
					passedTask->P0( passedTask->P1 );
					heapfree passedTask;
				}
			};

			Enqueue( task );
		}

		public void Invoke( Functors.Action action ) {
			if( IsDispatchingThread ) {
				action();
				return;
			}

			var wait = new Semaphore();
			var task = new TaskEntry<Functors.Action, Semaphore*> {
				P0 = action,
				P1 = &wait,
				Action = data => {
					var passedTask = ( TaskEntry<Functors.Action, Semaphore*>* ) data;
					passedTask->P0();
					passedTask->P1->Post(); // task completed
				}
			};

			Enqueue( &task );
			wait.Wait(); // wait for task completion
		}

		public void Invoke<T0>( Functors.Action<T0> action, T0 p0 ) {
			if( IsDispatchingThread ) {
				action( p0 );
				return;
			}

			var wait = new Semaphore();
			var task = new TaskEntry<Functors.Action<T0>, T0, Semaphore*> {
				P0 = action,
				P1 = p0,
				P2 = &wait,
				Action = data => {
					var passedTask = ( TaskEntry<Functors.Action<T0>, T0, Semaphore*>* ) data;
					passedTask->P0( passedTask->P1 );
					passedTask->P2->Post(); // task completed
				}
			};

			Enqueue( &task );
			wait.Wait(); // wait for task completion
		}

		public void Invoke( Delegates.Action action ) {
			if( IsDispatchingThread ) {
				action();
				return;
			}

			var wait = new Semaphore();
			var task = new TaskEntry<Delegates.Action, Semaphore*> {
				P0 = action,
				P1 = &wait,
				Action = data => {
					var passedTask = ( TaskEntry<Delegates.Action, Semaphore*>* ) data;
					passedTask->P0();
					passedTask->P1->Post(); // task completed
				}
			};

			Enqueue( &task );
			wait.Wait(); // wait for task completion
		}

		public void Invoke<T0>( Delegates.Action<T0> action, T0 p0 ) {
			if( IsDispatchingThread ) {
				action( p0 );
				return;
			}

			var wait = new Semaphore();
			var task = new TaskEntry<Delegates.Action<T0>, T0, Semaphore*> {
				P0 = action,
				P1 = p0,
				P2 = &wait,
				Action = data => {
					var passedTask = ( TaskEntry<Delegates.Action<T0>, T0, Semaphore*>* ) data;
					passedTask->P0( passedTask->P1 );
					passedTask->P2->Post(); // task completed
				}
			};

			Enqueue( &task );
			wait.Wait(); // wait for task completion
		}
	}
}