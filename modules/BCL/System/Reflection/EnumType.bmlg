//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System.Collections;
using System.Diagnostics;
using System.Runtime;

namespace System.Reflection {
	public partial struct EnumType : Type {
		public struct ElementAttribute {
			public int AttributeCount;
			public Attribute** Attributes;
			public bool IsDefined( [In] UserType& type ) { return GetAttribute( type ) != null; }
			public Attribute* GetAttribute( [In] UserType& type ) { return GetAttribute( Attributes, AttributeCount, type ); }
			public T* GetAttribute<T>() { return ( T* ) GetAttribute( typeof( T ) ); }
		}

		private EnumType() { }
		public static bool operator ==( [In] thistype& left, [In] thistype& right ) { return &left == &right; }
		public static bool operator !=( [In] thistype& left, [In] thistype& right ) { return &left != &right; }

		public Type& ElementType;

		public void* Values; // stored in sorted order
		public SbcsString* Names;

		public void* SortedIndices;

		// Generated for every enum which contains attributed elements. Names and attributes are separated from each other to:
		// 1. compact metadata size
		// 2. improve data locality
		// 3. provide efficient lookup
		public ElementAttribute* ElementAttributes;

		public Attribute** Attributes;
		public new bool IsDefined( [In] UserType& type ) { return GetAttribute( type ) != null; }
		public new Attribute* GetAttribute( [In] UserType& type ) { return GetAttribute( Attributes, AttributeCount, type ); }
		public new T* GetAttribute<T>() { return ( T* ) GetAttribute( typeof( T ) ); }

		public int AttributeCount;
		public int ElementCount;

		private T GetValueImpl<T>( int index ) {
			if( index < 0 | index >= ElementCount ) return default( T );
			return ( ( T* ) Values )[index];
		}

		private int GetIndexImpl<T>( T value ) {
			// if( ElementType.InstanceSize != sizeof( value ) ) return -1;
			return CommonCollectionOperations.BinarySearch<T>( ( T* ) Values, ElementCount, value );
		}

		public const string FlagEnumElementsSeparator = " | ";

		private string ToStringImpl<T>( T value ) {
			// if( ElementType.InstanceSize != sizeof( value ) ) return null;
			var values = ( T* ) Values;
			if( values == null || Names == null )
				return "<!enum info stripped!>";

			if( IsDefined( typeof( FlagsAttribute ) ) ) {
				if( value == 0 ) {
					if( ElementCount > 0 && values[0] == 0 ) return ( string ) Names[0];
					return "0";
				}

				var indices = stackalloc int[sizeof( T ) * 8];
				var indicesCount = 0;

				for( var i = ElementCount - 1; i >= 0 && value != 0; --i ) {
					if( values[i] == 0 ) break;

					if( BitOperations.MaskTest( value, values[i] ) ) {
						indices[indicesCount++] = i;
						value ^= values[i];
					}
				}

				using( var builder = StringBuilder.CachedBuilders.PopScoped() ) {
					for( var i = indicesCount - 1; i >= 0; --i ) {
						if( builder.Value.Length > 0 )
							builder.Value.Append( FlagEnumElementsSeparator );

						builder.Value.Append( Names[indices[i]] );
					}

					if( value != 0 ) {
						if( builder.Value.Length > 0 )
							builder.Value.Append( FlagEnumElementsSeparator );

						builder.Value.Append( value.ToString() );
					}

					return builder.Value.ToString();
				}
			}

			var index = GetIndexImpl<T>( value );
			if( index < 0 ) return value.ToString();

			return ( string ) Names[index];
		}

		private bool IsValidImpl<T>( T value ) {
			// if( ElementType.InstanceSize != sizeof( value ) ) return false;

			if( value != 0 && IsDefined( typeof( FlagsAttribute ) ) ) {
				var values = ( T* ) Values;

				for( var i = ElementCount - 1; i >= 0 && value != 0; --i ) {
					if( values[i] == 0 ) continue;
					if( ( value & values[i] ) == values[i] ) {
						value ^= values[i];
						i = -1;
					}
				}

				return value == 0;
			}

			return GetIndexImpl<T>( value ) != -1;
		}

		public byte GetUInt8Value( int index ) { return GetValueImpl<byte>( index ); }
		public ushort GetUInt16Value( int index ) { return GetValueImpl<ushort>( index ); }
		public uint GetUInt32Value( int index ) { return GetValueImpl<uint>( index ); }
		public ulong GetUInt64Value( int index ) { return GetValueImpl<ulong>( index ); }

		public bool IsValid( byte value ) { return IsValidImpl<byte>( value ); }
		public bool IsValid( ushort value ) { return IsValidImpl<ushort>( value ); }
		public bool IsValid( uint value ) { return IsValidImpl<uint>( value ); }
		public bool IsValid( ulong value ) { return IsValidImpl<ulong>( value ); }

		public int GetIndex( byte value ) { return GetIndexImpl<byte>( value ); }
		public int GetIndex( ushort value ) { return GetIndexImpl<ushort>( value ); }
		public int GetIndex( uint value ) { return GetIndexImpl<uint>( value ); }
		public int GetIndex( ulong value ) { return GetIndexImpl<ulong>( value ); }

		public string ToString( byte value ) { return ToStringImpl<byte>( value ); }
		public string ToString( ushort value ) { return ToStringImpl<ushort>( value ); }
		public string ToString( uint value ) { return ToStringImpl<uint>( value ); }
		public string ToString( ulong value ) { return ToStringImpl<ulong>( value ); }

		private int BinarySearch( CStringSpan value ) {
			if( ElementCount <= 255 ) {
				var remapping = ( byte* ) SortedIndices;
				var start = 0;
				var end = ElementCount - 1;

				while( start <= end ) {
					var median = ( start + end ) >> 1;
					var compareResult = Names[remapping[median]].CompareTo( value );

					if( compareResult == 0 ) return remapping[median];

					if( compareResult < 0 ) start = median + 1;
					else end = median - 1;
				}

				return -1;
			}
			else if( ElementCount <= 65535 ) {
				var remapping = ( ushort* ) SortedIndices;
				var start = 0;
				var end = ElementCount - 1;

				while( start <= end ) {
					var median = ( start + end ) >> 1;
					var compareResult = Names[remapping[median]].CompareTo( value );
					if( compareResult == 0 ) return remapping[median];

					if( compareResult < 0 ) start = median + 1;
					else end = median - 1;
				}

				return -1;
			}
			else {
				var remapping = ( int* ) SortedIndices;
				var start = 0;
				var end = ElementCount - 1;

				while( start <= end ) {
					var median = ( start + end ) >> 1;
					var compareResult = Names[remapping[median]].CompareTo( value );
					if( compareResult == 0 ) return remapping[median];

					if( compareResult < 0 ) start = median + 1;
					else end = median - 1;
				}

				return -1;
			}

			return -1;
		}

		public bool TryParse( CStringSpan name, void* result ) {
			var index = BinarySearch( name );
			if( index == -1 ) return false;

			switch( ElementType.InstanceSize ) {
				case 1: *( byte* ) result = cast<byte*>( Values )[index]; break;
				case 2: *( ushort* ) result = cast<ushort*>( Values )[index]; break;
				case 4: *( uint* ) result = cast<uint*>( Values )[index]; break;
				case 8: *( ulong* ) result = cast<ulong*>( Values )[index]; break;
			}

			return true;
		}

		public bool TryParse( CUtf8StringSpan name, void* result ) { return TryParse( ( CStringSpan ) name, result ); }
		public bool TryParse( CUtf16StringSpan name, void* result ) { return TryParse( SbcsString.FromUtf16( name ), result ); }
		public bool TryParse( CUtf32StringSpan name, void* result ) { return TryParse( SbcsString.FromUtf32( name ), result ); }
	}
}