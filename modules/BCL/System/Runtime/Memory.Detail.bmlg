//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System.Collections;

namespace System.Runtime {
	public static partial struct Memory {
		public const int DefaultAllocationAlignment = PlatformAllocationAlignment; // minimal alignment of memory segment returned by '_implAllocate'
		public const int DefaultPageSize = PlatformDefaultPageSize;

		public const int DefaultPageReserveSize = PlatformDefaultPageReserveSize; // aka allocation granularity in windows
		public const int DefaultPageReserveCount = PlatformDefaultPageReserveSize / PlatformDefaultPageSize;

		private const string TraceDefine = "MEMORY_TRACE";

		public const bool StackGrowsDown = true;
		public const bool StackGrowsUp = !StackGrowsDown;

		[System.Runtime.InteropServices.ExternLibrary]
		public static struct NativeMethods {
			[System.Runtime.InteropServices.BackendHintReadOnly]
			public extern static int memcmp( void* src1, void* src2, uintptr length );
		}

		[ExplicitSize( Size = PlatformDefaultPageSize )]
		[Alignment( Boundary = PlatformDefaultPageSize )]
		public struct Page {
		}

		// [ThreadStatic]
		public static bool EnableTracing = false;

		public static bool MultithreadedEnvironment = true;

		public struct BufferScope : IDisposable {
			public void* Location;
			public int Length;

			public void Dispose() {
				if( Length >= DefaultPageSize )
					Deallocate( Location );
				else
					CachedPages.Push( Location );
			}
		}

		public static BufferScope GetTemporary( int length ) {
			void* result;

			if( length >= DefaultPageSize )
				result = Allocate( length );
			else
				result = CachedPages.Pop();

			return new BufferScope {
				Location = result,
				Length = length
			};
		}

		[Conditional( ConditionString = TraceDefine )]
		private static void TrackAllocation( void* memory, uint length ) {
			if( !EnableTracing ) return;

			EnableTracing = false;
			Console.Write( "memory allocated: " );
			Console.Write( length );
			Console.Write( " bytes at " );
			Console.Write( memory );
			Console.WriteLine();
			EnableTracing = true;
		}

		[Conditional( ConditionString = TraceDefine )]
		private static void TrackDeallocation( void* memory ) {
			if( !EnableTracing ) return;

			EnableTracing = false;
			Console.Write( "memory free: at " );
			Console.Write( memory );
			Console.WriteLine();
			EnableTracing = true;
		}

		[Conditional( ConditionString = TraceDefine )]
		private static void TrackAlignedAllocation( void* memory, uint length, uint align ) {
			if( !EnableTracing ) return;

			EnableTracing = false;
			Console.Write( "memory allocated: " );
			Console.Write( length );
			Console.Write( " bytes at " );
			Console.Write( memory );
			Console.Write( " align " );
			Console.Write( align );
			Console.WriteLine();
			EnableTracing = true;
		}

		[Conditional( ConditionString = TraceDefine )]
		private static void TrackAlignedDeallocation( void* memory ) {
			if( !EnableTracing ) return;

			EnableTracing = false;
			Console.Write( "memory free: at " );
			Console.Write( memory );
			Console.Write( " aligned" );
			Console.WriteLine();
			EnableTracing = true;
		}

		public static uintptr ReadScatter( MemorySegment source, int& remainingDestinationIndex, uintptr& remainingDestinationOffset, vararg MemorySegment destination ) {
			if( source.Count == 0 || destination.Length == 0 ) return 0;
			uintptr result = 0;

			for( var i = 0U; i < destination.Length; ++i ) {
				var bytesToCopy = Math.Min( destination[i].Count, source.Count );
				System.Runtime.Memory.Copy( destination[i].Start, source.Start, bytesToCopy );
				result += bytesToCopy;

				source.Start = ( byte* ) source.Start + bytesToCopy;
				source.Count -= bytesToCopy;

				if( source.Count == 0 || i + 1 == destination.Length ) {
					if( i + 1 == destination.Length && bytesToCopy == destination[i].Count ) {
						remainingDestinationIndex = -1;
						remainingDestinationOffset = 0;
					}
					else {
						remainingDestinationIndex = ( int ) i;
						remainingDestinationOffset = bytesToCopy;
					}
				}
			}

			return result;
		}

		public static uintptr WriteGather( MemorySegment destination, int& remainingSourceIndex, uintptr& remainingSourceOffset, vararg MemorySegment source ) {
			if( destination.Count == 0 || source.Length == 0 ) return 0;
			uintptr result = 0;

			for( var i = 0U; i < source.Length; ++i ) {
				var bytesToCopy = Math.Min( destination.Count, source[i].Count );
				System.Runtime.Memory.Copy( destination.Start, source[i].Start, bytesToCopy );
				result += bytesToCopy;

				destination.Start = ( byte* ) destination.Start + bytesToCopy;
				destination.Count -= bytesToCopy;

				if( destination.Count == 0 || i + 1 == source.Length ) {
					if( i + 1 == source.Length && bytesToCopy == source[i].Count ) {
						remainingSourceIndex = -1;
						remainingSourceOffset = 0;
					}
					else {
						remainingSourceIndex = ( int ) i;
						remainingSourceOffset = bytesToCopy;
					}
				}
			}

			return result;
		}

		public static CachingStack<void*> CachedPages { get { return RuntimeObjectBase._cachedMemoryPages; } }
	}
}