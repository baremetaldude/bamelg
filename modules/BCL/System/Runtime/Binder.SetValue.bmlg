//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Serialization;

namespace System.Runtime {
	public partial class Binder {
		public void SetValue( Context& context, int index, bool value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, value ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, value ? ( sbyte ) 1 : ( sbyte ) 0 ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, value ? ( byte ) 1 : ( byte ) 0 ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, value ? ( short_littleendian ) 1 : ( short_littleendian ) 0 ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, value ? ( ushort_littleendian ) 1 : ( ushort_littleendian ) 0 ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, value ? ( short_bigendian ) 1 : ( short_bigendian ) 0 ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, value ? ( ushort_bigendian ) 1 : ( ushort_bigendian ) 0 ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, value ? ( int_littleendian ) 1 : ( int_littleendian ) 0 ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, value ? ( uint_littleendian ) 1 : ( uint_littleendian ) 0 ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, value ? ( int_bigendian ) 1 : ( int_bigendian ) 0 ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, value ? ( uint_bigendian ) 1 : ( uint_bigendian ) 0 ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value ? ( long_littleendian ) 1 : ( long_littleendian ) 0 ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, value ? ( ulong_littleendian ) 1 : ( ulong_littleendian ) 0 ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value ? ( long_bigendian ) 1 : ( long_bigendian ) 0 ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, value ? ( ulong_bigendian ) 1 : ( ulong_bigendian ) 0 ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, value ? ( float_littleendian ) 1 : ( float_littleendian ) 0 ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value ? ( double_littleendian ) 1 : ( double_littleendian ) 0 ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, value ? ( float_bigendian ) 1 : ( float_bigendian ) 0 ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value ? ( double_bigendian ) 1 : ( double_bigendian ) 0 ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
		}

		public void SetValue( Context& context, int index, sbyte value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, value != 0 ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, value ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, value > 0 ? ( byte ) value : ( byte ) 0 ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, value ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, value > 0 ? ( ushort_littleendian ) value : ( ushort_littleendian ) 0 ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, value ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, value > 0 ? ( ushort_bigendian ) value : ( ushort_bigendian ) 0 ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, value ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, value > 0 ? ( uint_littleendian ) value : ( uint_littleendian ) 0 ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, value ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, value > 0 ? ( uint_bigendian ) value : ( uint_bigendian ) 0 ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, value > 0 ? ( ulong_littleendian ) value : ( ulong_littleendian ) 0 ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, value > 0 ? ( ulong_bigendian ) value : ( ulong_bigendian ) 0 ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, value ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, value ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
		}

		public void SetValue( Context& context, int index, byte value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, value != 0 ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, ( sbyte ) Math.Clamp( ( byte ) 0, value, ( byte ) sbyte.MaxValue ) ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, value ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, value ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, value ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, value ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, value ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, value ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, value ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, value ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, value ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, value ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, value ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, value ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, value ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
		}

		public void SetValue( Context& context, int index, short value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, value != 0 ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, ( sbyte ) Math.Clamp( ( short ) sbyte.MinValue, value, ( short ) sbyte.MaxValue ) ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, ( byte ) Math.Clamp( ( short ) byte.MinValue, value, ( short ) byte.MaxValue ) ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, value ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, value > 0 ? ( ushort ) value : ( ushort ) 0 ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, value ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, value > 0 ? ( ushort ) value : ( ushort ) 0 ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, value ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, value > 0 ? ( uint ) value : ( uint ) 0 ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, value ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, value > 0 ? ( uint ) value : ( uint ) 0 ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, value > 0 ? ( ulong ) value : ( ulong ) 0 ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, value > 0 ? ( ulong ) value : ( ulong ) 0 ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, value ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, value ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
		}

		public void SetValue( Context& context, int index, ushort value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, value != 0 ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, value <= sbyte.MaxValue ? ( sbyte ) value : sbyte.MaxValue ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, value <= byte.MaxValue ? ( byte ) value : byte.MaxValue ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, value <= short.MaxValue ? ( short ) value : short.MaxValue ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, value ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, value <= short.MaxValue ? ( short ) value : short.MaxValue ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, value ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, value ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, value ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, value ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, value ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, value ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, value ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, value ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, value ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
		}

		public void SetValue( Context& context, int index, int value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, value != 0 ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, ( sbyte ) Math.Clamp( ( int ) sbyte.MinValue, value, ( int ) sbyte.MaxValue ) ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, ( byte ) Math.Clamp( ( int ) byte.MinValue, value, ( int ) sbyte.MaxValue ) ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, ( short ) Math.Clamp( ( int ) short.MinValue, value, ( int ) short.MaxValue ) ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, ( ushort ) Math.Clamp( ( int ) ushort.MinValue, value, ( int ) ushort.MaxValue ) ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, ( short ) Math.Clamp( ( int ) short.MinValue, value, ( int ) short.MaxValue ) ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, ( ushort ) Math.Clamp( ( int ) ushort.MinValue, value, ( int ) ushort.MaxValue ) ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, value ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, value > 0 ? ( uint ) value : ( uint ) 0 ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, value ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, value > 0 ? ( uint ) value : ( uint ) 0 ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, value > 0 ? ( ulong ) value : ( ulong ) 0 ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, value > 0 ? ( ulong ) value : ( ulong ) 0 ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, value ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, value ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
		}

		public void SetValue( Context& context, int index, uint value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, value != 0 ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, ( sbyte ) Math.Clamp( ( byte ) 0, value, ( byte ) sbyte.MaxValue ) ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, value <= byte.MaxValue ? ( byte ) value : byte.MaxValue ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, value <= short.MaxValue ? ( short ) value : short.MaxValue ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, value <= ushort.MaxValue ? ( ushort ) value : ushort.MaxValue ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, value <= short.MaxValue ? ( short ) value : short.MaxValue ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, value <= ushort.MaxValue ? ( ushort ) value : ushort.MaxValue ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, value <= int.MaxValue ? ( int ) value : int.MaxValue ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, value ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, value <= int.MaxValue ? ( int ) value : int.MaxValue ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, value ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, value ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, value ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, value ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, value ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
		}

		public void SetValue( Context& context, int index, long value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, value != 0 ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, ( sbyte ) Math.Clamp( ( long ) sbyte.MinValue, value, ( long ) sbyte.MaxValue ) ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, ( byte ) Math.Clamp( ( long ) byte.MinValue, value, ( long ) byte.MaxValue ) ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, ( short ) Math.Clamp( ( long ) short.MinValue, value, ( long ) short.MaxValue ) ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, ( ushort ) Math.Clamp( ( long ) ushort.MinValue, value, ( long ) ushort.MaxValue ) ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, ( short ) Math.Clamp( ( long ) short.MinValue, value, ( long ) short.MaxValue ) ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, ( ushort ) Math.Clamp( ( long ) ushort.MinValue, value, ( long ) ushort.MaxValue ) ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, ( int ) Math.Clamp( ( long ) int.MinValue, value, ( long ) int.MaxValue ) ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, ( uint ) Math.Clamp( ( long ) uint.MinValue, value, ( long ) uint.MaxValue ) ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, ( int ) Math.Clamp( ( long ) int.MinValue, value, ( long ) int.MaxValue ) ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, ( uint ) Math.Clamp( ( long ) uint.MinValue, value, ( long ) uint.MaxValue ) ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, value > 0 ? ( ulong ) value : ( ulong ) 0 ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, value > 0 ? ( ulong ) value : ( ulong ) 0 ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, value ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, value ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
		}

		public void SetValue( Context& context, int index, ulong value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, value != 0 ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, value <= ( ulong ) sbyte.MaxValue ? ( sbyte ) value : sbyte.MaxValue ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, value <= ( ulong ) byte.MaxValue ? ( byte ) value : byte.MaxValue ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, value <= ( ulong ) short.MaxValue ? ( short ) value : short.MaxValue ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, value <= ( ulong ) ushort.MaxValue ? ( ushort ) value : ushort.MaxValue ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, value <= ( ulong ) short.MaxValue ? ( short ) value : short.MaxValue ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, value <= ( ulong ) ushort.MaxValue ? ( ushort ) value : ushort.MaxValue ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, value <= ( ulong ) int.MaxValue ? ( int ) value : int.MaxValue ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, value <= ( ulong ) uint.MaxValue ? ( uint ) value : uint.MaxValue ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, value <= ( ulong ) int.MaxValue ? ( int ) value : int.MaxValue ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, value <= ( ulong ) uint.MaxValue ? ( uint ) value : uint.MaxValue ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value <= ( ulong ) long.MaxValue ? ( long ) value : long.MaxValue ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, value ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value <= ( ulong ) long.MaxValue ? ( long ) value : long.MaxValue ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, value ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, value ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, value ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
		}

		public void SetValue( Context& context, int index, float value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, !value.IsDenormalizedOrZero ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, ( sbyte ) Math.Clamp( ( float ) sbyte.MinValue, value, ( float ) sbyte.MaxValue ) ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, ( byte ) Math.Clamp( ( float ) byte.MinValue, value, ( float ) byte.MaxValue ) ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, ( short ) Math.Clamp( ( float ) short.MinValue, value, ( float ) short.MaxValue ) ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, ( ushort ) Math.Clamp( ( float ) ushort.MinValue, value, ( float ) ushort.MaxValue ) ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, ( short ) Math.Clamp( ( float ) short.MinValue, value, ( float ) short.MaxValue ) ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, ( ushort ) Math.Clamp( ( float ) ushort.MinValue, value, ( float ) ushort.MaxValue ) ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, ( int ) Math.Clamp( ( float ) int.MinValue, value, ( float ) int.MaxValue ) ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, ( uint ) Math.Clamp( ( float ) uint.MinValue, value, ( float ) uint.MaxValue ) ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, ( int ) Math.Clamp( ( float ) int.MinValue, value, ( float ) int.MaxValue ) ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, ( uint ) Math.Clamp( ( float ) uint.MinValue, value, ( float ) uint.MaxValue ) ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, ( long ) Math.Clamp( ( float ) long.MinValue, value, ( float ) long.MaxValue ) ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, ( ulong ) Math.Clamp( ( float ) ulong.MinValue, value, ( float ) ulong.MaxValue ) ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, ( long ) Math.Clamp( ( float ) long.MinValue, value, ( float ) long.MaxValue ) ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, ( ulong ) Math.Clamp( ( float ) ulong.MinValue, value, ( float ) ulong.MaxValue ) ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, value ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, value ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
		}

		public void SetValue( Context& context, int index, double value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, !value.IsDenormalizedOrZero ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, ( sbyte ) Math.Clamp( ( double ) sbyte.MinValue, value, ( double ) sbyte.MaxValue ) ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, ( byte ) Math.Clamp( ( double ) byte.MinValue, value, ( double ) byte.MaxValue ) ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, ( short ) Math.Clamp( ( double ) short.MinValue, value, ( double ) short.MaxValue ) ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, ( ushort ) Math.Clamp( ( double ) ushort.MinValue, value, ( double ) ushort.MaxValue ) ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, ( short ) Math.Clamp( ( double ) short.MinValue, value, ( double ) short.MaxValue ) ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, ( ushort ) Math.Clamp( ( double ) ushort.MinValue, value, ( double ) ushort.MaxValue ) ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, ( int ) Math.Clamp( ( double ) int.MinValue, value, ( double ) int.MaxValue ) ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, ( uint ) Math.Clamp( ( double ) uint.MinValue, value, ( double ) uint.MaxValue ) ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, ( int ) Math.Clamp( ( double ) int.MinValue, value, ( double ) int.MaxValue ) ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, ( uint ) Math.Clamp( ( double ) uint.MinValue, value, ( double ) uint.MaxValue ) ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, ( long ) Math.Clamp( ( double ) long.MinValue, value, ( double ) long.MaxValue ) ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, ( ulong ) Math.Clamp( ( double ) ulong.MinValue, value, ( double ) ulong.MaxValue ) ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, ( long ) Math.Clamp( ( float ) double.MinValue, value, ( double ) long.MaxValue ) ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, ( ulong ) Math.Clamp( ( float ) double.MinValue, value, ( double ) ulong.MaxValue ) ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, ( float ) value ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, ( float ) value ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
		}

		public void SetValue( Context& context, int index, SbcsString value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): { sbyte p; if( enumType.TryParse( value, &p ) ) column->SetValue<sbyte>( context.Object, p ); else goto parseError; return; }
					case typeof( byte ): { byte p; if( enumType.TryParse( value, &p ) ) column->SetValue<byte>( context.Object, p ); else goto parseError; return; }

					case typeof( short_littleendian ): { short_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ushort_littleendian ): { ushort_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( short_bigendian ): { short_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ushort_bigendian ): { ushort_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_bigendian>( context.Object, p ); else goto parseError; return; }

					case typeof( int_littleendian ): { int_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( uint_littleendian ): { uint_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( int_bigendian ): { int_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( uint_bigendian ): { uint_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_bigendian>( context.Object, p ); else goto parseError; return; }

					case typeof( long_littleendian ): { long_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ulong_littleendian ): { ulong_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( long_bigendian ): { long_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ulong_bigendian ): { ulong_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_bigendian>( context.Object, p ); else goto parseError; return; }
				}
			}

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( DateTime ): { DateTime p; if( DateTime.TryParse( value, p ) ) column->SetValue<DateTime>( context.Object, p ); else goto parseError; return; }
				case typeof( TimeSpan ): { TimeSpan p; if( TimeSpan.TryParse( value, p ) ) column->SetValue<TimeSpan>( context.Object, p ); else goto parseError; return; }
				case typeof( Guid ): { Guid p; if( Guid.TryParse( value, p ) ) column->SetValue<Guid>( context.Object, p ); else goto parseError; return; }

				case typeof( char ): if( !value.IsNullOrEmpty ) column->SetValue<char>( context.Object, cast<string>( value )[0] ); else column->SetValue<char>( context.Object, '\0' ); return;

				case typeof( bool ): { bool p; if( bool.TryParse( value, p ) ) column->SetValue<bool>( context.Object, p ); else goto parseError; return; }
				case typeof( sbyte ): { sbyte p; if( sbyte.TryParse( value, p ) ) column->SetValue<sbyte>( context.Object, p ); else goto parseError; return; }
				case typeof( byte ): { byte p; if( byte.TryParse( value, p ) ) column->SetValue<byte>( context.Object, p ); else goto parseError; return; }

				case typeof( short_littleendian ): { short p; if( short.TryParse( value, p ) ) column->SetValue<short_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ushort_littleendian ): { ushort p; if( ushort.TryParse( value, p ) ) column->SetValue<ushort_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( short_bigendian ): { short p; if( short.TryParse( value, p ) ) column->SetValue<short_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ushort_bigendian ): { ushort p; if( ushort.TryParse( value, p ) ) column->SetValue<ushort_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( int_littleendian ): { int p; if( int.TryParse( value, p ) ) column->SetValue<int_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( uint_littleendian ): { uint p; if( uint.TryParse( value, p ) ) column->SetValue<uint_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( int_bigendian ): { int p; if( int.TryParse( value, p ) ) column->SetValue<int_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( uint_bigendian ): { uint p; if( uint.TryParse( value, p ) ) column->SetValue<uint_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( long_littleendian ): { long p; if( long.TryParse( value, p ) ) column->SetValue<long_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ulong_littleendian ): { ulong p; if( ulong.TryParse( value, p ) ) column->SetValue<ulong_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( long_bigendian ): { long p; if( long.TryParse( value, p ) ) column->SetValue<long_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ulong_bigendian ): { ulong p; if( ulong.TryParse( value, p ) ) column->SetValue<ulong_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( float_littleendian ): { float p; if( float.TryParse( value, p ) ) column->SetValue<float_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( double_littleendian ): { double p; if( double.TryParse( value, p ) ) column->SetValue<double_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( float_bigendian ): { float p; if( float.TryParse( value, p ) ) column->SetValue<float_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( double_bigendian ): { double p; if( double.TryParse( value, p ) ) column->SetValue<double_bigendian>( context.Object, p ); else goto parseError; return; }
			
				case typeof( byte[] ): { byte[] p; if( PrimitiveTypesParser.TryParseByteArray( value.GetChars(), value.Length, p ) ) column->SetValue<byte[]>( context.Object, p ); else goto parseError; return; }
			}

			if( TryDeserializeText( context, type, column, value ) ) return;

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
			return;

		parseError:
			context.BinderEvent.ParseError( column );
			return;
		}

		public void SetValue( Context& context, int index, Utf8String value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): { sbyte p; if( enumType.TryParse( value, &p ) ) column->SetValue<sbyte>( context.Object, p ); else goto parseError; return; }
					case typeof( byte ): { byte p; if( enumType.TryParse( value, &p ) ) column->SetValue<byte>( context.Object, p ); else goto parseError; return; }

					case typeof( short_littleendian ): { short_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ushort_littleendian ): { ushort_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( short_bigendian ): { short_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ushort_bigendian ): { ushort_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_bigendian>( context.Object, p ); else goto parseError; return; }

					case typeof( int_littleendian ): { int_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( uint_littleendian ): { uint_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( int_bigendian ): { int_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( uint_bigendian ): { uint_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_bigendian>( context.Object, p ); else goto parseError; return; }

					case typeof( long_littleendian ): { long_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ulong_littleendian ): { ulong_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( long_bigendian ): { long_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ulong_bigendian ): { ulong_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_bigendian>( context.Object, p ); else goto parseError; return; }
				}
			}

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( DateTime ): { DateTime p; if( DateTime.TryParse( value, p ) ) column->SetValue<DateTime>( context.Object, p ); else goto parseError; return; }
				case typeof( TimeSpan ): { TimeSpan p; if( TimeSpan.TryParse( value, p ) ) column->SetValue<TimeSpan>( context.Object, p ); else goto parseError; return; }
				case typeof( Guid ): { Guid p; if( Guid.TryParse( value, p ) ) column->SetValue<Guid>( context.Object, p ); else goto parseError; return; }

				case typeof( char ): if( !value.IsNullOrEmpty ) column->SetValue<char>( context.Object, cast<string>( value )[0] ); else column->SetValue<char>( context.Object, '\0' ); return;

				case typeof( bool ): { bool p; if( bool.TryParse( value, p ) ) column->SetValue<bool>( context.Object, p ); else goto parseError; return; }
				case typeof( sbyte ): { sbyte p; if( sbyte.TryParse( value, p ) ) column->SetValue<sbyte>( context.Object, p ); else goto parseError; return; }
				case typeof( byte ): { byte p; if( byte.TryParse( value, p ) ) column->SetValue<byte>( context.Object, p ); else goto parseError; return; }

				case typeof( short_littleendian ): { short p; if( short.TryParse( value, p ) ) column->SetValue<short_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ushort_littleendian ): { ushort p; if( ushort.TryParse( value, p ) ) column->SetValue<ushort_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( short_bigendian ): { short p; if( short.TryParse( value, p ) ) column->SetValue<short_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ushort_bigendian ): { ushort p; if( ushort.TryParse( value, p ) ) column->SetValue<ushort_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( int_littleendian ): { int p; if( int.TryParse( value, p ) ) column->SetValue<int_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( uint_littleendian ): { uint p; if( uint.TryParse( value, p ) ) column->SetValue<uint_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( int_bigendian ): { int p; if( int.TryParse( value, p ) ) column->SetValue<int_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( uint_bigendian ): { uint p; if( uint.TryParse( value, p ) ) column->SetValue<uint_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( long_littleendian ): { long p; if( long.TryParse( value, p ) ) column->SetValue<long_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ulong_littleendian ): { ulong p; if( ulong.TryParse( value, p ) ) column->SetValue<ulong_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( long_bigendian ): { long p; if( long.TryParse( value, p ) ) column->SetValue<long_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ulong_bigendian ): { ulong p; if( ulong.TryParse( value, p ) ) column->SetValue<ulong_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( float_littleendian ): { float p; if( float.TryParse( value, p ) ) column->SetValue<float_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( double_littleendian ): { double p; if( double.TryParse( value, p ) ) column->SetValue<double_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( float_bigendian ): { float p; if( float.TryParse( value, p ) ) column->SetValue<float_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( double_bigendian ): { double p; if( double.TryParse( value, p ) ) column->SetValue<double_bigendian>( context.Object, p ); else goto parseError; return; }
				
				case typeof( byte[] ): { byte[] p; if( PrimitiveTypesParser.TryParseByteArray( value.GetChars(), value.Length, p ) ) column->SetValue<byte[]>( context.Object, p ); else goto parseError; return; }
			}

			if( TryDeserializeText( context, type, column, value ) ) return;

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
			return;

		parseError:
			context.BinderEvent.ParseError( column );
			return;
		}

		public void SetValue( Context& context, int index, string value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): { sbyte p; if( enumType.TryParse( value, &p ) ) column->SetValue<sbyte>( context.Object, p ); else goto parseError; return; }
					case typeof( byte ): { byte p; if( enumType.TryParse( value, &p ) ) column->SetValue<byte>( context.Object, p ); else goto parseError; return; }

					case typeof( short_littleendian ): { short_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ushort_littleendian ): { ushort_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( short_bigendian ): { short_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ushort_bigendian ): { ushort_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_bigendian>( context.Object, p ); else goto parseError; return; }

					case typeof( int_littleendian ): { int_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( uint_littleendian ): { uint_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( int_bigendian ): { int_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( uint_bigendian ): { uint_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_bigendian>( context.Object, p ); else goto parseError; return; }

					case typeof( long_littleendian ): { long_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ulong_littleendian ): { ulong_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( long_bigendian ): { long_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ulong_bigendian ): { ulong_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_bigendian>( context.Object, p ); else goto parseError; return; }
				}
			}

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( DateTime ): { DateTime p; if( DateTime.TryParse( value, p ) ) column->SetValue<DateTime>( context.Object, p ); else goto parseError; return; }
				case typeof( TimeSpan ): { TimeSpan p; if( TimeSpan.TryParse( value, p ) ) column->SetValue<TimeSpan>( context.Object, p ); else goto parseError; return; }
				case typeof( Guid ): { Guid p; if( Guid.TryParse( value, p ) ) column->SetValue<Guid>( context.Object, p ); else goto parseError; return; }

				case typeof( char ): if( !value.IsNullOrEmpty ) column->SetValue<char>( context.Object, value[0] ); else column->SetValue<char>( context.Object, '\0' ); return;

				case typeof( bool ): { bool p; if( bool.TryParse( value, p ) ) column->SetValue<bool>( context.Object, p ); else goto parseError; return; }
				case typeof( sbyte ): { sbyte p; if( sbyte.TryParse( value, p ) ) column->SetValue<sbyte>( context.Object, p ); else goto parseError; return; }
				case typeof( byte ): { byte p; if( byte.TryParse( value, p ) ) column->SetValue<byte>( context.Object, p ); else goto parseError; return; }

				case typeof( short_littleendian ): { short p; if( short.TryParse( value, p ) ) column->SetValue<short_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ushort_littleendian ): { ushort p; if( ushort.TryParse( value, p ) ) column->SetValue<ushort_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( short_bigendian ): { short p; if( short.TryParse( value, p ) ) column->SetValue<short_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ushort_bigendian ): { ushort p; if( ushort.TryParse( value, p ) ) column->SetValue<ushort_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( int_littleendian ): { int p; if( int.TryParse( value, p ) ) column->SetValue<int_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( uint_littleendian ): { uint p; if( uint.TryParse( value, p ) ) column->SetValue<uint_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( int_bigendian ): { int p; if( int.TryParse( value, p ) ) column->SetValue<int_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( uint_bigendian ): { uint p; if( uint.TryParse( value, p ) ) column->SetValue<uint_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( long_littleendian ): { long p; if( long.TryParse( value, p ) ) column->SetValue<long_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ulong_littleendian ): { ulong p; if( ulong.TryParse( value, p ) ) column->SetValue<ulong_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( long_bigendian ): { long p; if( long.TryParse( value, p ) ) column->SetValue<long_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ulong_bigendian ): { ulong p; if( ulong.TryParse( value, p ) ) column->SetValue<ulong_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( float_littleendian ): { float p; if( float.TryParse( value, p ) ) column->SetValue<float_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( double_littleendian ): { double p; if( double.TryParse( value, p ) ) column->SetValue<double_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( float_bigendian ): { float p; if( float.TryParse( value, p ) ) column->SetValue<float_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( double_bigendian ): { double p; if( double.TryParse( value, p ) ) column->SetValue<double_bigendian>( context.Object, p ); else goto parseError; return; }
				
				case typeof( byte[] ): { byte[] p; if( PrimitiveTypesParser.TryParseByteArray( value.GetChars(), value.Length, p ) ) column->SetValue<byte[]>( context.Object, p ); else goto parseError; return; }
			}

			if( TryDeserializeText( context, type, column, value ) ) return;

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
			return;

		parseError:
			context.BinderEvent.ParseError( column );
			return;
		}

		public void SetValue( Context& context, int index, StringBuilder value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			var span = value.GetTextSpan();

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): { sbyte p; if( enumType.TryParse( span, &p ) ) column->SetValue<sbyte>( context.Object, p ); else goto parseError; return; }
					case typeof( byte ): { byte p; if( enumType.TryParse( span, &p ) ) column->SetValue<byte>( context.Object, p ); else goto parseError; return; }

					case typeof( short_littleendian ): { short_littleendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<short_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ushort_littleendian ): { ushort_littleendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<ushort_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( short_bigendian ): { short_bigendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<short_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ushort_bigendian ): { ushort_bigendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<ushort_bigendian>( context.Object, p ); else goto parseError; return; }

					case typeof( int_littleendian ): { int_littleendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<int_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( uint_littleendian ): { uint_littleendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<uint_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( int_bigendian ): { int_bigendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<int_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( uint_bigendian ): { uint_bigendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<uint_bigendian>( context.Object, p ); else goto parseError; return; }

					case typeof( long_littleendian ): { long_littleendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<long_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ulong_littleendian ): { ulong_littleendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<ulong_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( long_bigendian ): { long_bigendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<long_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ulong_bigendian ): { ulong_bigendian p; if( enumType.TryParse( span, &p ) ) column->SetValue<ulong_bigendian>( context.Object, p ); else goto parseError; return; }				
				}
			}

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( DateTime ): { DateTime p; if( DateTime.TryParse( span, p ) ) column->SetValue<DateTime>( context.Object, p ); else goto parseError; return; }
				case typeof( TimeSpan ): { TimeSpan p; if( TimeSpan.TryParse( span, p ) ) column->SetValue<TimeSpan>( context.Object, p ); else goto parseError; return; }
				case typeof( Guid ): { Guid p; if( Guid.TryParse( span, p ) ) column->SetValue<Guid>( context.Object, p ); else goto parseError; return; }

				case typeof( char ): if( !value.IsNullOrEmpty ) column->SetValue<char>( context.Object, value[0] ); else column->SetValue<char>( context.Object, '\0' ); return;

				case typeof( bool ): { bool p; if( bool.TryParse( span, p ) ) column->SetValue<bool>( context.Object, p ); else goto parseError; return; }
				case typeof( sbyte ): { sbyte p; if( sbyte.TryParse( span, p ) ) column->SetValue<sbyte>( context.Object, p ); else goto parseError; return; }
				case typeof( byte ): { byte p; if( byte.TryParse( span, p ) ) column->SetValue<byte>( context.Object, p ); else goto parseError; return; }

				case typeof( short_littleendian ): { short p; if( short.TryParse( span, p ) ) column->SetValue<short_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ushort_littleendian ): { ushort p; if( ushort.TryParse( span, p ) ) column->SetValue<ushort_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( short_bigendian ): { short p; if( short.TryParse( span, p ) ) column->SetValue<short_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ushort_bigendian ): { ushort p; if( ushort.TryParse( span, p ) ) column->SetValue<ushort_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( int_littleendian ): { int p; if( int.TryParse( span, p ) ) column->SetValue<int_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( uint_littleendian ): { uint p; if( uint.TryParse( span, p ) ) column->SetValue<uint_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( int_bigendian ): { int p; if( int.TryParse( span, p ) ) column->SetValue<int_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( uint_bigendian ): { uint p; if( uint.TryParse( span, p ) ) column->SetValue<uint_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( long_littleendian ): { long p; if( long.TryParse( span, p ) ) column->SetValue<long_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ulong_littleendian ): { ulong p; if( ulong.TryParse( span, p ) ) column->SetValue<ulong_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( long_bigendian ): { long p; if( long.TryParse( span, p ) ) column->SetValue<long_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ulong_bigendian ): { ulong p; if( ulong.TryParse( span, p ) ) column->SetValue<ulong_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( float_littleendian ): { float p; if( float.TryParse( span, p ) ) column->SetValue<float_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( double_littleendian ): { double p; if( double.TryParse( span, p ) ) column->SetValue<double_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( float_bigendian ): { float p; if( float.TryParse( span, p ) ) column->SetValue<float_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( double_bigendian ): { double p; if( double.TryParse( span, p ) ) column->SetValue<double_bigendian>( context.Object, p ); else goto parseError; return; }
			
				case typeof( byte[] ): { byte[] p; if( PrimitiveTypesParser.TryParseByteArray( span.GetChars(), span.Length, p ) ) column->SetValue<byte[]>( context.Object, p ); else goto parseError; return; }
			}

			if( TryDeserializeText( context, type, column, value ) ) return;

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
			return;

		parseError:
			context.BinderEvent.ParseError( column );
			return;
		}

		public void SetValue( Context& context, int index, Utf32String value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): { sbyte p; if( enumType.TryParse( value, &p ) ) column->SetValue<sbyte>( context.Object, p ); else goto parseError; return; }
					case typeof( byte ): { byte p; if( enumType.TryParse( value, &p ) ) column->SetValue<byte>( context.Object, p ); else goto parseError; return; }

					case typeof( short_littleendian ): { short_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ushort_littleendian ): { ushort_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( short_bigendian ): { short_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ushort_bigendian ): { ushort_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_bigendian>( context.Object, p ); else goto parseError; return; }

					case typeof( int_littleendian ): { int_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( uint_littleendian ): { uint_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( int_bigendian ): { int_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( uint_bigendian ): { uint_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_bigendian>( context.Object, p ); else goto parseError; return; }

					case typeof( long_littleendian ): { long_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ulong_littleendian ): { ulong_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_littleendian>( context.Object, p ); else goto parseError; return; }
					case typeof( long_bigendian ): { long_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_bigendian>( context.Object, p ); else goto parseError; return; }
					case typeof( ulong_bigendian ): { ulong_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_bigendian>( context.Object, p ); else goto parseError; return; }
				}
			}

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value ); return;

				case typeof( DateTime ): { DateTime p; if( DateTime.TryParse( value, p ) ) column->SetValue<DateTime>( context.Object, p ); else goto parseError; return; }
				case typeof( TimeSpan ): { TimeSpan p; if( TimeSpan.TryParse( value, p ) ) column->SetValue<TimeSpan>( context.Object, p ); else goto parseError; return; }
				case typeof( Guid ): { Guid p; if( Guid.TryParse( value, p ) ) column->SetValue<Guid>( context.Object, p ); else goto parseError; return; }

				case typeof( char ): if( !value.IsNullOrEmpty ) column->SetValue<char>( context.Object, cast<string>( value )[0] ); else column->SetValue<char>( context.Object, '\0' ); return;

				case typeof( bool ): { bool p; if( bool.TryParse( value, p ) ) column->SetValue<bool>( context.Object, p ); else goto parseError; return; }
				case typeof( sbyte ): { sbyte p; if( sbyte.TryParse( value, p ) ) column->SetValue<sbyte>( context.Object, p ); else goto parseError; return; }
				case typeof( byte ): { byte p; if( byte.TryParse( value, p ) ) column->SetValue<byte>( context.Object, p ); else goto parseError; return; }

				case typeof( short_littleendian ): { short p; if( short.TryParse( value, p ) ) column->SetValue<short_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ushort_littleendian ): { ushort p; if( ushort.TryParse( value, p ) ) column->SetValue<ushort_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( short_bigendian ): { short p; if( short.TryParse( value, p ) ) column->SetValue<short_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ushort_bigendian ): { ushort p; if( ushort.TryParse( value, p ) ) column->SetValue<ushort_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( int_littleendian ): { int p; if( int.TryParse( value, p ) ) column->SetValue<int_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( uint_littleendian ): { uint p; if( uint.TryParse( value, p ) ) column->SetValue<uint_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( int_bigendian ): { int p; if( int.TryParse( value, p ) ) column->SetValue<int_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( uint_bigendian ): { uint p; if( uint.TryParse( value, p ) ) column->SetValue<uint_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( long_littleendian ): { long p; if( long.TryParse( value, p ) ) column->SetValue<long_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ulong_littleendian ): { ulong p; if( ulong.TryParse( value, p ) ) column->SetValue<ulong_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( long_bigendian ): { long p; if( long.TryParse( value, p ) ) column->SetValue<long_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( ulong_bigendian ): { ulong p; if( ulong.TryParse( value, p ) ) column->SetValue<ulong_bigendian>( context.Object, p ); else goto parseError; return; }

				case typeof( float_littleendian ): { float p; if( float.TryParse( value, p ) ) column->SetValue<float_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( double_littleendian ): { double p; if( double.TryParse( value, p ) ) column->SetValue<double_littleendian>( context.Object, p ); else goto parseError; return; }
				case typeof( float_bigendian ): { float p; if( float.TryParse( value, p ) ) column->SetValue<float_bigendian>( context.Object, p ); else goto parseError; return; }
				case typeof( double_bigendian ): { double p; if( double.TryParse( value, p ) ) column->SetValue<double_bigendian>( context.Object, p ); else goto parseError; return; }
				
				case typeof( byte[] ): { byte[] p; if( PrimitiveTypesParser.TryParseByteArray( value.GetChars(), value.Length, p ) ) column->SetValue<byte[]>( context.Object, p ); else goto parseError; return; }
			}

			if( TryDeserializeText( context, type, column, value ) ) return;

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
			return;

		parseError:
			context.BinderEvent.ParseError( column );
			return;
		}

		public void SetValue( Context& context, int index, BinaryReader value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): column->SetValue<sbyte>( context.Object, value.ReadInt8() ); return;
					case typeof( byte ): column->SetValue<byte>( context.Object, value.ReadUInt8() ); return;

					case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, value.ReadInt16() ); return;
					case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, value.ReadUInt16() ); return;
					case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, value.ReadInt16() ); return;
					case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, value.ReadUInt16() ); return;

					case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, value.ReadInt32() ); return;
					case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, value.ReadUInt32() ); return;
					case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, value.ReadInt32() ); return;
					case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, value.ReadUInt32() ); return;

					case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value.ReadInt64() ); return;
					case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, value.ReadUInt64() ); return;
					case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value.ReadInt64() ); return;
					case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, value.ReadUInt64() ); return;
				}
			}

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ReadSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ReadUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ReadUtf16String() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ReadUtf32String() ); return;

				case typeof( DateTime ): column->SetValue<DateTime>( context.Object, value.ReadDateTime() ); return;
				case typeof( TimeSpan ): column->SetValue<TimeSpan>( context.Object, value.ReadTimeSpan() ); return;
				case typeof( Guid ): column->SetValue<Guid>( context.Object, value.ReadGuid() ); return;

				case typeof( char ): column->SetValue<char>( context.Object, ( char ) value.ReadUInt16() ); return;

				case typeof( bool ): column->SetValue<bool>( context.Object, value.ReadBool() ); return;
				case typeof( sbyte ): column->SetValue<sbyte>( context.Object, value.ReadInt8() ); return;
				case typeof( byte ): column->SetValue<byte>( context.Object, value.ReadUInt8() ); return;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( context.Object, value.ReadInt16() ); return;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( context.Object, value.ReadUInt16() ); return;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( context.Object, value.ReadInt16() ); return;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( context.Object, value.ReadUInt16() ); return;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( context.Object, value.ReadInt32() ); return;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( context.Object, value.ReadUInt32() ); return;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( context.Object, value.ReadInt32() ); return;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( context.Object, value.ReadUInt32() ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value.ReadInt64() ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, value.ReadUInt64() ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value.ReadInt64() ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, value.ReadUInt64() ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, value.ReadFloat() ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value.ReadDouble() ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, value.ReadFloat() ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value.ReadDouble() ); return;
				
				case typeof( byte[] ): column->SetValue<byte[]>( context.Object, value.ReadByteArray() ); return;
			}

			if( TryDeserializeBinary( context, type, column, value ) ) return;

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
			return;
		}

		public void SetValue( Context& context, int index, ITextSerializable value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();
			using( var builder = StringBuilder.CachedBuilders.PopScoped() ) {
				value.Serialize( builder.Value, "", null );
				SetValue( context, index, builder.Value );
			}
		}

		public void SetValue( Context& context, int index, DateTime value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( DateTime ): column->SetValue<DateTime>( context.Object, value ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value.Ticks ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, ToUInt64( value.Ticks ) ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value.Ticks ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, ToUInt64( value.Ticks ) ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, ( float ) value.ToUnixSecondsFractional() ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value.ToUnixSecondsFractional() ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, ( float ) value.ToUnixSecondsFractional() ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value.ToUnixSecondsFractional() ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
			return;
		}

		public void SetValue( Context& context, int index, TimeSpan value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( TimeSpan ): column->SetValue<TimeSpan>( context.Object, value ); return;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( context.Object, value.Ticks ); return;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( context.Object, ToUInt64( value.Ticks ) ); return;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( context.Object, value.Ticks ); return;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( context.Object, ToUInt64( value.Ticks ) ); return;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( context.Object, ( float ) value.TotalSecondsFractional ); return;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( context.Object, value.TotalSecondsFractional ); return;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( context.Object, ( float ) value.TotalSecondsFractional ); return;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( context.Object, value.TotalSecondsFractional ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
			return;
		}

		public void SetValue( Context& context, int index, Guid value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, value.ToSbcsString() ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, value.ToUtf8String() ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, value.ToString() ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, value.ToUtf32String() ); return;

				case typeof( Guid ): column->SetValue<Guid>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
			return;
		}

		public void SetValue( Context& context, int index, byte[] value ) {
			var column = GetMapping( context, index );
			if( column == null ) return;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( context.Object, PrimitiveTypesFormatter.FormatMemoryHexSbcs( &value[0], ( uint ) value.Length, true ) ); return;
				case typeof( Utf8String ): column->SetValue<Utf8String>( context.Object, PrimitiveTypesFormatter.FormatMemoryHexUtf8( &value[0], ( uint ) value.Length, true ) ); return;
				case typeof( Utf16String ): column->SetValue<Utf16String>( context.Object, PrimitiveTypesFormatter.FormatMemoryHexUtf16( &value[0], ( uint ) value.Length, true ) ); return;
				case typeof( Utf32String ): column->SetValue<Utf32String>( context.Object, PrimitiveTypesFormatter.FormatMemoryHexUtf32( &value[0], ( uint ) value.Length, true ) ); return;

				case typeof( byte[] ): column->SetValue<byte[]>( context.Object, value ); return;
			}

			context.BinderEvent.IncompatibleMapping( column, typeof( value ) );
			return;
		}
	}
}