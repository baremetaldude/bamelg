//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Serialization;

namespace System.Runtime {
	public partial class Binder {
		public Convert.ConversionResult SetValue( void *object, uint index, bool value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( bool ): column->SetValue<bool>( object, value ); return Convert.ConversionResult.OK;
				case typeof( sbyte ): column->SetValue<sbyte>( object, value ? ( sbyte ) 1 : ( sbyte ) 0 ); return Convert.ConversionResult.OK;
				case typeof( byte ): column->SetValue<byte>( object, value ? ( byte ) 1 : ( byte ) 0 ); return Convert.ConversionResult.OK;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( object, value ? ( short_littleendian ) 1 : ( short_littleendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( object, value ? ( ushort_littleendian ) 1 : ( ushort_littleendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( object, value ? ( short_bigendian ) 1 : ( short_bigendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( object, value ? ( ushort_bigendian ) 1 : ( ushort_bigendian ) 0 ); return Convert.ConversionResult.OK;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( object, value ? ( int_littleendian ) 1 : ( int_littleendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( object, value ? ( uint_littleendian ) 1 : ( uint_littleendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( object, value ? ( int_bigendian ) 1 : ( int_bigendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( object, value ? ( uint_bigendian ) 1 : ( uint_bigendian ) 0 ); return Convert.ConversionResult.OK;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, value ? ( long_littleendian ) 1 : ( long_littleendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( object, value ? ( ulong_littleendian ) 1 : ( ulong_littleendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, value ? ( long_bigendian ) 1 : ( long_bigendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( object, value ? ( ulong_bigendian ) 1 : ( ulong_bigendian ) 0 ); return Convert.ConversionResult.OK;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, value ? ( float_littleendian ) 1 : ( float_littleendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value ? ( double_littleendian ) 1 : ( double_littleendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, value ? ( float_bigendian ) 1 : ( float_bigendian ) 0 ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value ? ( double_bigendian ) 1 : ( double_bigendian ) 0 ); return Convert.ConversionResult.OK;
				
				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, sbyte value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( bool ): column->SetValue<bool>( object, value != 0 ); return Convert.ConversionResult.OK;
				case typeof( sbyte ): column->SetValue<sbyte>( object, value ); return Convert.ConversionResult.OK;
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value ); return Convert.ConversionResult.OK;
			
				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, byte value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( bool ): column->SetValue<bool>( object, value != 0 ); return Convert.ConversionResult.OK;
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): column->SetValue<byte>( object, value ); return Convert.ConversionResult.OK;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, short value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( bool ): column->SetValue<bool>( object, value != 0 ); return Convert.ConversionResult.OK;
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, ushort value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( bool ): column->SetValue<bool>( object, value != 0 ); return Convert.ConversionResult.OK;
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, int value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( bool ): column->SetValue<bool>( object, value != 0 ); return Convert.ConversionResult.OK;
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, uint value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( bool ): column->SetValue<bool>( object, value != 0 ); return Convert.ConversionResult.OK;
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_littleendian>( object, converted ); return result; }
				case typeof( int_bigendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_bigendian>( object, converted ); return result; }
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, long value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( bool ): column->SetValue<bool>( object, value != 0 ); return Convert.ConversionResult.OK;
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_littleendian>( object, converted ); return result; }
				case typeof( int_bigendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_bigendian>( object, converted ); return result; }
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, ulong value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( bool ): column->SetValue<bool>( object, value != 0 ); return Convert.ConversionResult.OK;
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_littleendian>( object, converted ); return result; }
				case typeof( int_bigendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_bigendian>( object, converted ); return result; }
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_littleendian>( object, converted ); return result; }
				case typeof( long_bigendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_bigendian>( object, converted ); return result; }
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, float value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( bool ): { bool converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<bool>( object, converted ); return result; }
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_littleendian>( object, converted ); return result; }
				case typeof( int_bigendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_bigendian>( object, converted ); return result; }
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_littleendian>( object, converted ); return result; }
				case typeof( long_bigendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_bigendian>( object, converted ); return result; }
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, double value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( bool ): { bool converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<bool>( object, converted ); return result; }
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_littleendian>( object, converted ); return result; }
				case typeof( int_bigendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_bigendian>( object, converted ); return result; }
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_littleendian>( object, converted ); return result; }
				case typeof( long_bigendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_bigendian>( object, converted ); return result; }
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_littleendian>( object, converted ); return result; }
				case typeof( float_bigendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_bigendian>( object, converted ); return result; }
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value ); return Convert.ConversionResult.OK;

				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, SbcsString value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): { sbyte p; if( enumType.TryParse( value, &p ) ) column->SetValue<sbyte>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( byte ): { byte p; if( enumType.TryParse( value, &p ) ) column->SetValue<byte>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( short_littleendian ): { short_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ushort_littleendian ): { ushort_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( short_bigendian ): { short_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ushort_bigendian ): { ushort_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( int_littleendian ): { int_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( uint_littleendian ): { uint_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( int_bigendian ): { int_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( uint_bigendian ): { uint_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( long_littleendian ): { long_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ulong_littleendian ): { ulong_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( long_bigendian ): { long_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ulong_bigendian ): { ulong_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				}
			}

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( DateTime ): { DateTime p; if( DateTime.TryParse( value, p ) ) column->SetValue<DateTime>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( DateTimeUTC ): { DateTimeUTC p; if( DateTimeUTC.TryParse( value, p ) ) column->SetValue<DateTimeUTC>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( TimeSpan ): { TimeSpan p; if( TimeSpan.TryParse( value, p ) ) column->SetValue<TimeSpan>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( Guid ): { Guid converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Guid>( object, converted ); return result; }

				case typeof( char ): if( !value.IsNullOrEmpty ) column->SetValue<char>( object, cast<string>( value )[0] ); else column->SetValue<char>( object, '\0' ); return Convert.ConversionResult.OK;

				case typeof( bool ): { bool p; if( bool.TryParse( value, p ) ) column->SetValue<bool>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_littleendian>( object, converted ); return result; }
				case typeof( int_bigendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_bigendian>( object, converted ); return result; }
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_littleendian>( object, converted ); return result; }
				case typeof( long_bigendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_bigendian>( object, converted ); return result; }
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_littleendian>( object, converted ); return result; }
				case typeof( float_bigendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_bigendian>( object, converted ); return result; }
				case typeof( double_littleendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_littleendian>( object, converted ); return result; }
				case typeof( double_bigendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_bigendian>( object, converted ); return result; }

				case typeof( byte[] ): { byte[] p; if( PrimitiveTypesParser.TryParseByteArray( value.GetChars(), value.Length, p ) ) column->SetValue<byte[]>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
			}

			return TryDeserializeText( object, type, column, value );

		parseError:
			return Convert.ConversionResult.IncompatibleValue;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, Utf8String value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): { sbyte p; if( enumType.TryParse( value, &p ) ) column->SetValue<sbyte>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( byte ): { byte p; if( enumType.TryParse( value, &p ) ) column->SetValue<byte>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( short_littleendian ): { short_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ushort_littleendian ): { ushort_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( short_bigendian ): { short_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ushort_bigendian ): { ushort_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( int_littleendian ): { int_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( uint_littleendian ): { uint_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( int_bigendian ): { int_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( uint_bigendian ): { uint_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( long_littleendian ): { long_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ulong_littleendian ): { ulong_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( long_bigendian ): { long_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ulong_bigendian ): { ulong_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				}
			}

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( DateTime ): { DateTime p; if( DateTime.TryParse( value, p ) ) column->SetValue<DateTime>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( DateTimeUTC ): { DateTimeUTC p; if( DateTimeUTC.TryParse( value, p ) ) column->SetValue<DateTimeUTC>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( TimeSpan ): { TimeSpan p; if( TimeSpan.TryParse( value, p ) ) column->SetValue<TimeSpan>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( Guid ): { Guid converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Guid>( object, converted ); return result; }

				case typeof( char ): if( !value.IsNullOrEmpty ) column->SetValue<char>( object, cast<string>( value )[0] ); else column->SetValue<char>( object, '\0' ); return Convert.ConversionResult.OK;

				case typeof( bool ): { bool p; if( bool.TryParse( value, p ) ) column->SetValue<bool>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_littleendian>( object, converted ); return result; }
				case typeof( int_bigendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_bigendian>( object, converted ); return result; }
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_littleendian>( object, converted ); return result; }
				case typeof( long_bigendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_bigendian>( object, converted ); return result; }
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_littleendian>( object, converted ); return result; }
				case typeof( float_bigendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_bigendian>( object, converted ); return result; }
				case typeof( double_littleendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_littleendian>( object, converted ); return result; }
				case typeof( double_bigendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_bigendian>( object, converted ); return result; }

				case typeof( byte[] ): { byte[] p; if( PrimitiveTypesParser.TryParseByteArray( value.GetChars(), value.Length, p ) ) column->SetValue<byte[]>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
			}

			return TryDeserializeText( object, type, column, value );

		parseError:
			return Convert.ConversionResult.IncompatibleValue;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, string value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): { sbyte p; if( enumType.TryParse( value, &p ) ) column->SetValue<sbyte>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( byte ): { byte p; if( enumType.TryParse( value, &p ) ) column->SetValue<byte>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( short_littleendian ): { short_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ushort_littleendian ): { ushort_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( short_bigendian ): { short_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ushort_bigendian ): { ushort_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( int_littleendian ): { int_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( uint_littleendian ): { uint_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( int_bigendian ): { int_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( uint_bigendian ): { uint_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( long_littleendian ): { long_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ulong_littleendian ): { ulong_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( long_bigendian ): { long_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ulong_bigendian ): { ulong_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				}
			}

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( DateTime ): { DateTime p; if( DateTime.TryParse( value, p ) ) column->SetValue<DateTime>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( DateTimeUTC ): { DateTimeUTC p; if( DateTimeUTC.TryParse( value, p ) ) column->SetValue<DateTimeUTC>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( TimeSpan ): { TimeSpan p; if( TimeSpan.TryParse( value, p ) ) column->SetValue<TimeSpan>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( Guid ): { Guid converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Guid>( object, converted ); return result; }

				case typeof( char ): if( !value.IsNullOrEmpty ) column->SetValue<char>( object, value[0] ); else column->SetValue<char>( object, '\0' ); return Convert.ConversionResult.OK;

				case typeof( bool ): { bool p; if( bool.TryParse( value, p ) ) column->SetValue<bool>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_littleendian>( object, converted ); return result; }
				case typeof( int_bigendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_bigendian>( object, converted ); return result; }
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_littleendian>( object, converted ); return result; }
				case typeof( long_bigendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_bigendian>( object, converted ); return result; }
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_littleendian>( object, converted ); return result; }
				case typeof( float_bigendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_bigendian>( object, converted ); return result; }
				case typeof( double_littleendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_littleendian>( object, converted ); return result; }
				case typeof( double_bigendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_bigendian>( object, converted ); return result; }

				case typeof( byte[] ): { byte[] p; if( PrimitiveTypesParser.TryParseByteArray( value.GetChars(), value.Length, p ) ) column->SetValue<byte[]>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
			}

			return TryDeserializeText( object, type, column, value );

		parseError:
			return Convert.ConversionResult.IncompatibleValue;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, Utf32String value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): { sbyte p; if( enumType.TryParse( value, &p ) ) column->SetValue<sbyte>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( byte ): { byte p; if( enumType.TryParse( value, &p ) ) column->SetValue<byte>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( short_littleendian ): { short_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ushort_littleendian ): { ushort_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( short_bigendian ): { short_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ushort_bigendian ): { ushort_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( int_littleendian ): { int_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( uint_littleendian ): { uint_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( int_bigendian ): { int_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( uint_bigendian ): { uint_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( long_littleendian ): { long_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ulong_littleendian ): { ulong_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( long_bigendian ): { long_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ulong_bigendian ): { ulong_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				}
			}

			switch( type ) {
				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value ); return Convert.ConversionResult.OK;

				case typeof( DateTime ): { DateTime p; if( DateTime.TryParse( value, p ) ) column->SetValue<DateTime>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( DateTimeUTC ): { DateTimeUTC p; if( DateTimeUTC.TryParse( value, p ) ) column->SetValue<DateTimeUTC>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( TimeSpan ): { TimeSpan p; if( TimeSpan.TryParse( value, p ) ) column->SetValue<TimeSpan>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( Guid ): { Guid converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Guid>( object, converted ); return result; }

				case typeof( char ): if( !value.IsNullOrEmpty ) column->SetValue<char>( object, cast<string>( value )[0] ); else column->SetValue<char>( object, '\0' ); return Convert.ConversionResult.OK;

				case typeof( bool ): { bool p; if( bool.TryParse( value, p ) ) column->SetValue<bool>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_littleendian>( object, converted ); return result; }
				case typeof( int_bigendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_bigendian>( object, converted ); return result; }
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_littleendian>( object, converted ); return result; }
				case typeof( long_bigendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_bigendian>( object, converted ); return result; }
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_littleendian>( object, converted ); return result; }
				case typeof( float_bigendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_bigendian>( object, converted ); return result; }
				case typeof( double_littleendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_littleendian>( object, converted ); return result; }
				case typeof( double_bigendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_bigendian>( object, converted ); return result; }

				case typeof( byte[] ): { byte[] p; if( PrimitiveTypesParser.TryParseByteArray( value.GetChars(), value.Length, p ) ) column->SetValue<byte[]>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
			}

			return TryDeserializeText( object, type, column, value );

		parseError:
			return Convert.ConversionResult.IncompatibleValue;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, CUtf16StringSpan value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): { sbyte p; if( enumType.TryParse( value, &p ) ) column->SetValue<sbyte>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( byte ): { byte p; if( enumType.TryParse( value, &p ) ) column->SetValue<byte>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( short_littleendian ): { short_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ushort_littleendian ): { ushort_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( short_bigendian ): { short_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<short_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ushort_bigendian ): { ushort_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ushort_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( int_littleendian ): { int_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( uint_littleendian ): { uint_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( int_bigendian ): { int_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<int_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( uint_bigendian ): { uint_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<uint_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }

					case typeof( long_littleendian ): { long_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ulong_littleendian ): { ulong_littleendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_littleendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( long_bigendian ): { long_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<long_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
					case typeof( ulong_bigendian ): { ulong_bigendian p; if( enumType.TryParse( value, &p ) ) column->SetValue<ulong_bigendian>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				}
			}

			switch( type ) {
				case typeof( SbcsString ): { SbcsString converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<SbcsString>( object, converted ); return result; }
				case typeof( Utf8String ): { Utf8String converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Utf8String>( object, converted ); return result; }
				case typeof( Utf16String ): { Utf16String converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Utf16String>( object, converted ); return result; }
				case typeof( Utf32String ): { Utf32String converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Utf32String>( object, converted ); return result; }

				case typeof( DateTime ): { DateTime converted; if( DateTime.TryParse( value, converted ) ) column->SetValue<DateTime>( object, converted ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( DateTimeUTC ): { DateTimeUTC converted; if( DateTimeUTC.TryParse( value, converted ) ) column->SetValue<DateTimeUTC>( object, converted ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( TimeSpan ): { TimeSpan converted; if( TimeSpan.TryParse( value, converted ) ) column->SetValue<TimeSpan>( object, converted ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( Guid ): { Guid converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Guid>( object, converted ); return result; }

				// case typeof( char ): if( !span.IsNullOrEmpty ) column->SetValue<char>( object, value[0] ); else column->SetValue<char>( object, '\0' ); return Convert.ConversionResult.OK;

				case typeof( bool ): { bool p; if( bool.TryParse( value, p ) ) column->SetValue<bool>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_littleendian>( object, converted ); return result; }
				case typeof( int_bigendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_bigendian>( object, converted ); return result; }
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_littleendian>( object, converted ); return result; }
				case typeof( long_bigendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_bigendian>( object, converted ); return result; }
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_littleendian>( object, converted ); return result; }
				case typeof( float_bigendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_bigendian>( object, converted ); return result; }
				case typeof( double_littleendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_littleendian>( object, converted ); return result; }
				case typeof( double_bigendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_bigendian>( object, converted ); return result; }

				case typeof( byte[] ): { byte[] p; if( PrimitiveTypesParser.TryParseByteArray( value.GetChars(), value.Length, p ) ) column->SetValue<byte[]>( object, p ); else goto parseError; return Convert.ConversionResult.OK; }
			}

			return TryDeserializeText( object, type, column, value );

		parseError:
			return Convert.ConversionResult.IncompatibleValue;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, DateTime value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( sbyte ): column->SetValue<sbyte>( object, sbyte.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( byte ): column->SetValue<byte>( object, byte.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( object, short.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( object, short.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( object, ushort.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( object, ushort.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( object, int.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( object, int.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( object, uint.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( object, uint.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, long.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, long.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( object, ulong.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( object, ulong.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( DateTime ): column->SetValue<DateTime>( object, value ); return Convert.ConversionResult.OK;
				case typeof( DateTimeUTC ): column->SetValue<DateTimeUTC>( object, new DateTimeUTC( ( ulong ) value.ToUniversalTime().Ticks ) ); return Convert.ConversionResult.OK;
				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, ( float ) value.ToUnixSecondsFractional() ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value.ToUnixSecondsFractional() ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, ( float ) value.ToUnixSecondsFractional() ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value.ToUnixSecondsFractional() ); return Convert.ConversionResult.OK;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, TimeSpan value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( sbyte ): column->SetValue<sbyte>( object, sbyte.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( byte ): column->SetValue<byte>( object, byte.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( object, short.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( object, short.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( object, ushort.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( object, ushort.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( object, int.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( object, int.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( object, uint.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( object, uint.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, long.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, long.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( object, ulong.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( object, ulong.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				// case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, value.Ticks ); return Convert.ConversionResult.OK;
				// case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, value.Ticks ); return Convert.ConversionResult.OK;
				// case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( object, ToUInt64( value.Ticks ) ); return Convert.ConversionResult.OK;
				// case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( object, ToUInt64( value.Ticks ) ); return Convert.ConversionResult.OK;

				case typeof( SbcsString ): column->SetValue<SbcsString>( object, value.ToSbcsString() ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, value.ToUtf8String() ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, value.ToString() ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, value.ToUtf32String() ); return Convert.ConversionResult.OK;

				case typeof( TimeSpan ): column->SetValue<TimeSpan>( object, value ); return Convert.ConversionResult.OK;
				case typeof( Guid ): column->SetValue<Guid>( object, Guid.Empty ); return Convert.ConversionResult.IncompatibleType;

				case typeof( float_littleendian ): column->SetValue<float_littleendian>( object, ( float ) value.TotalSecondsFractional ); return Convert.ConversionResult.OK;
				case typeof( double_littleendian ): column->SetValue<double_littleendian>( object, value.TotalSecondsFractional ); return Convert.ConversionResult.OK;
				case typeof( float_bigendian ): column->SetValue<float_bigendian>( object, ( float ) value.TotalSecondsFractional ); return Convert.ConversionResult.OK;
				case typeof( double_bigendian ): column->SetValue<double_bigendian>( object, value.TotalSecondsFractional ); return Convert.ConversionResult.OK;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, Guid value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( sbyte ): column->SetValue<sbyte>( object, sbyte.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( byte ): column->SetValue<byte>( object, byte.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( short_littleendian ): column->SetValue<short_littleendian>( object, short.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( object, short.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( object, ushort.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( object, ushort.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( int_littleendian ): column->SetValue<int_littleendian>( object, int.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( int_bigendian ): column->SetValue<int_bigendian>( object, int.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( object, uint.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( object, uint.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, long.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, long.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( object, ulong.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( object, ulong.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( SbcsString ): { SbcsString converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<SbcsString>( object, converted ); return result; }
				case typeof( Utf8String ): { Utf8String converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Utf8String>( object, converted ); return result; }
				case typeof( Utf16String ): { Utf16String converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Utf16String>( object, converted ); return result; }
				case typeof( Utf32String ): { Utf32String converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Utf32String>( object, converted ); return result; }

				case typeof( Guid ): column->SetValue<Guid>( object, value ); return Convert.ConversionResult.OK;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, byte[] value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();

			switch( type ) {
				case typeof( sbyte ): column->SetValue<sbyte>( object, sbyte.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( byte ): column->SetValue<byte>( object, byte.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( short_littleendian ): column->SetValue<short_littleendian>( object, short.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( short_bigendian ): column->SetValue<short_bigendian>( object, short.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( object, ushort.MaxValue ); return Convert.ConversionResult.IncompatibleType;
				case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( object, ushort.MaxValue ); return Convert.ConversionResult.IncompatibleType;

				case typeof( SbcsString ): column->SetValue<SbcsString>( object, PrimitiveTypesFormatter.FormatMemoryHexSbcs( &value[0], value.Length, true ) ); return Convert.ConversionResult.OK;
				case typeof( Utf8String ): column->SetValue<Utf8String>( object, PrimitiveTypesFormatter.FormatMemoryHexUtf8( &value[0], value.Length, true ) ); return Convert.ConversionResult.OK;
				case typeof( Utf16String ): column->SetValue<Utf16String>( object, PrimitiveTypesFormatter.FormatMemoryHexUtf16( &value[0], value.Length, true ) ); return Convert.ConversionResult.OK;
				case typeof( Utf32String ): column->SetValue<Utf32String>( object, PrimitiveTypesFormatter.FormatMemoryHexUtf32( &value[0], value.Length, true ) ); return Convert.ConversionResult.OK;

				case typeof( byte[] ): column->SetValue<byte[]>( object, value ); return Convert.ConversionResult.OK;
			}

			return Convert.ConversionResult.IncompatibleType;
		}

		public Convert.ConversionResult SetValue( void *object, uint index, BinaryReader value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();
			var& enumType = column->GetDirectType().AsEnum;

			if( enumType != nullref ) {
				switch( enumType.ElementType ) {
					case typeof( sbyte ): column->SetValue<sbyte>( object, value.ReadInt8() ); return Convert.ConversionResult.OK;
					case typeof( byte ): column->SetValue<byte>( object, value.ReadUInt8() ); return Convert.ConversionResult.OK;

					case typeof( short_littleendian ): column->SetValue<short_littleendian>( object, value.ReadInt16() ); return Convert.ConversionResult.OK;
					case typeof( ushort_littleendian ): column->SetValue<ushort_littleendian>( object, value.ReadUInt16() ); return Convert.ConversionResult.OK;
					case typeof( short_bigendian ): column->SetValue<short_bigendian>( object, value.ReadInt16() ); return Convert.ConversionResult.OK;
					case typeof( ushort_bigendian ): column->SetValue<ushort_bigendian>( object, value.ReadUInt16() ); return Convert.ConversionResult.OK;

					case typeof( int_littleendian ): column->SetValue<int_littleendian>( object, value.ReadInt32() ); return Convert.ConversionResult.OK;
					case typeof( int_bigendian ): column->SetValue<int_bigendian>( object, value.ReadInt32() ); return Convert.ConversionResult.OK;
					case typeof( uint_littleendian ): column->SetValue<uint_littleendian>( object, value.ReadUInt32() ); return Convert.ConversionResult.OK;
					case typeof( uint_bigendian ): column->SetValue<uint_bigendian>( object, value.ReadUInt32() ); return Convert.ConversionResult.OK;

					case typeof( long_littleendian ): column->SetValue<long_littleendian>( object, value.ReadInt64() ); return Convert.ConversionResult.OK;
					case typeof( ulong_littleendian ): column->SetValue<ulong_littleendian>( object, value.ReadUInt64() ); return Convert.ConversionResult.OK;
					case typeof( long_bigendian ): column->SetValue<long_bigendian>( object, value.ReadInt64() ); return Convert.ConversionResult.OK;
					case typeof( ulong_bigendian ): column->SetValue<ulong_bigendian>( object, value.ReadUInt64() ); return Convert.ConversionResult.OK;
				}
			}

			switch( type ) {
				case typeof( SbcsString ): { SbcsString converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<SbcsString>( object, converted ); return result; }
				case typeof( Utf8String ): { Utf8String converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Utf8String>( object, converted ); return result; }
				case typeof( Utf16String ): { Utf16String converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Utf16String>( object, converted ); return result; }
				case typeof( Utf32String ): { Utf32String converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Utf32String>( object, converted ); return result; }

				case typeof( DateTime ): column->SetValue<DateTime>( object, value.ReadDateTime() ); return Convert.ConversionResult.OK;
				case typeof( DateTimeUTC ): column->SetValue<DateTimeUTC>( object, value.ReadDateTimeUTC() ); return Convert.ConversionResult.OK;
				case typeof( TimeSpan ): column->SetValue<TimeSpan>( object, value.ReadTimeSpan() ); return Convert.ConversionResult.OK;
				case typeof( Guid ): { Guid converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<Guid>( object, converted ); return result; }

				case typeof( char ): column->SetValue<char>( object, ( char ) value.ReadUInt16() ); return Convert.ConversionResult.OK;

				case typeof( bool ): { bool converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<bool>( object, converted ); return result; }
				case typeof( sbyte ): { sbyte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<sbyte>( object, converted ); return result; }
				case typeof( byte ): { byte converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<byte>( object, converted ); return result; }

				case typeof( short_littleendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_littleendian>( object, converted ); return result; }
				case typeof( short_bigendian ): { short converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<short_bigendian>( object, converted ); return result; }
				case typeof( ushort_littleendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_littleendian>( object, converted ); return result; }
				case typeof( ushort_bigendian ): { ushort converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ushort_bigendian>( object, converted ); return result; }

				case typeof( int_littleendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_littleendian>( object, converted ); return result; }
				case typeof( int_bigendian ): { int converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<int_bigendian>( object, converted ); return result; }
				case typeof( uint_littleendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_littleendian>( object, converted ); return result; }
				case typeof( uint_bigendian ): { uint converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<uint_bigendian>( object, converted ); return result; }

				case typeof( long_littleendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_littleendian>( object, converted ); return result; }
				case typeof( long_bigendian ): { long converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<long_bigendian>( object, converted ); return result; }
				case typeof( ulong_littleendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_littleendian>( object, converted ); return result; }
				case typeof( ulong_bigendian ): { ulong converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<ulong_bigendian>( object, converted ); return result; }

				case typeof( float_littleendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_littleendian>( object, converted ); return result; }
				case typeof( float_bigendian ): { float converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<float_bigendian>( object, converted ); return result; }
				case typeof( double_littleendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_littleendian>( object, converted ); return result; }
				case typeof( double_bigendian ): { double converted; var result = Convert.TryConvert( &converted, value ); column->SetValue<double_bigendian>( object, converted ); return result; }

				case typeof( byte[] ): column->SetValue<byte[]>( object, value.ReadUInt8Array() ); return Convert.ConversionResult.OK;
			}

			return TryDeserializeBinary( object, type, column, value );
		}

		public Convert.ConversionResult SetValue( void *object, uint index, ITextSerializable value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();
			using( var builder = StringBuilder.CachedBuilders.PopScoped() ) {
				value.Serialize( builder.Value, "", null );
				return SetValue( object, index, builder.Value );
			}
		}

		public Convert.ConversionResult SetValue( void *object, uint index, StringBuilder value ) {
			var column = GetMapping( index );
			if( column == null ) return Convert.ConversionResult.MissedMapping;

			var& type = column->GetType();
			if( value != null ) return SetValue( object, index, value.GetTextSpan() );
			else return SetValue( object, index, default( CUtf16StringSpan ) );
		}
	}
}