//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//
// Various functions used by backend. Some older or non-*nix platforms may not have them
//

using System.Runtime.InteropServices;

namespace System.Runtime {
	public static partial class Backend {
		/// \return 'value' in power of 'power'
		[BackendHintKeep]
		[BackendSymbol( Name = "__powidf2" )]
		private static double __powidf2( double value, int power ) {
			var reciprocal = power < 0;
			var r = 1.0;

			while( true ) {
				if( ( power & 1 ) == 1 )
					r *= value;

				power /= 2;

				if( power == 0 )
					break;

				value *= value;
			}

			return reciprocal ? 1 / r : r;
		}

		[BackendHintKeep]
		[BackendSymbol( Name = "__sync_fetch_and_add_8" )]
		private static ulong __sync_fetch_and_add_8( ulong* target, ulong value ) {
			var result = *target;

			while( !AtomicOperations.TryCompareExchange( target, result, result + value ) )
				result = *target;

			return result;
		}

		[BackendHintKeep]
		[BackendSymbol( Name = "__sync_fetch_and_sub_8" )]
		private static ulong __sync_fetch_and_sub_8( ulong* target, ulong value ) {
			var result = *target;

			while( !AtomicOperations.TryCompareExchange( target, result, result - value ) )
				result = *target;

			return result;
		}

		[BackendHintKeep]
		[BackendSymbol( Name = "__sync_fetch_and_and_8" )]
		private static ulong __sync_fetch_and_and_8( ulong* target, ulong value ) {
			var result = *target;

			while( !AtomicOperations.TryCompareExchange( target, result, result & value ) )
				result = *target;

			return result;
		}

		[BackendHintKeep]
		[BackendSymbol( Name = "__sync_fetch_and_xor_8" )]
		private static ulong __sync_fetch_and_xor_8( ulong* target, ulong value ) {
			var result = *target;

			while( !AtomicOperations.TryCompareExchange( target, result, result ^ value ) )
				result = *target;

			return result;
		}

		[BackendHintKeep]
		[BackendSymbol( Name = "__sync_fetch_and_nand_8" )]
		private static ulong __sync_fetch_and_nand_8( ulong* target, ulong value ) {
			var result = *target;

			while( !AtomicOperations.TryCompareExchange( target, result, ~( result & value ) ) )
				result = *target;

			return result;
		}

		[BackendHintKeep]
		[BackendSymbol( Name = "__sync_fetch_and_or_8" )]
		private static ulong __sync_fetch_and_or_8( ulong* target, ulong value ) {
			var result = *target;

			while( !AtomicOperations.TryCompareExchange( target, result, result | value ) )
				result = *target;

			return result;
		}

		[BackendHintKeep]
		[BackendSymbol( Name = "__sync_lock_test_and_set_1" )]
		private static byte __sync_lock_test_and_set_1( byte* target, byte value ) {
			return AtomicOperations.Exchange( target, value );
		}

		[BackendHintKeep]
		[BackendSymbol( Name = "__sync_lock_test_and_set_2" )]
		private static ushort __sync_lock_test_and_set_2( ushort* target, ushort value ) {
			return AtomicOperations.Exchange( target, value );
		}

		[BackendHintKeep]
		[BackendSymbol( Name = "__sync_lock_test_and_set_4" )]
		private static uint __sync_lock_test_and_set_4( uint* target, uint value ) {
			return AtomicOperations.Exchange( target, value );
		}

		[BackendHintKeep]
		[BackendSymbol( Name = "__sync_lock_test_and_set_8" )]
		private static ulong __sync_lock_test_and_set_8( ulong* target, ulong value ) {
			//			return AtomicOperations.Exchange( target, value ); this calls __sync_lock_test_and_set_8 recursively on x86
			var result = *target;

			while( !AtomicOperations.TryCompareExchange( target, result, value ) )
				result = *target;

			return result;
		}

		/// \return 'value' in power of 'power'
		[BackendHintKeep]
		[BackendSymbol( Name = "__powisf2" )]
		private static float __powisf2( float value, int power ) {
			var recip = power < 0;
			var r = 1f;

			while( true ) {
				if( ( power & 1 ) == 1 )
					r *= value;

				power /= 2;

				if( power == 0 )
					break;

				value *= value;
			}

			return recip ? 1 / r : r;
		}

		/// '( float value ) => ( ulong ) value'
		/// Rounding toward zero, e.g. Math.Floor( value )
		[BackendHintWeak]
		[BackendSymbol( Name = "__fixunssfdi" )]
		private static ulong __fixunssfdi( float value ) {
			var bits = bitcast<int>( value );
			if( bits < 0 ) return 0;

			var exponent = cast<int>( bits >> float.MantissaBits ) - float.ExponentBias; // masking of sign is unnecessary
			if( exponent < 0 ) return 0;

			var result = ( ulong )( ( bits & float.MantissaMask ) | ( float.MantissaMask + 1 ) );

			if( exponent > float.MantissaBits )
				result <<= exponent - float.MantissaBits;
			else
				result >>= float.MantissaBits - exponent;

			return result;
		}

		/// '( double value ) => ( ulong ) value'
		/// Rounding toward zero, e.g. Math.Floor( value )
		[BackendHintWeak]
		[BackendSymbol( Name = "__fixunsdfdi" )]
		private static ulong __fixunsdfdi( double value ) {
			var bits = bitcast<long>( value );
			if( bits < 0 ) return 0;

			var exponent = ( int )( bits >> double.MantissaBits ) - double.ExponentBias; // masking of sign is unnecessary
			if( exponent < 0 ) return 0;

			var result = ( ulong ) bits;
			result &= double.MantissaMask;
			result |= double.MantissaMask + 1;

			if( exponent > double.MantissaBits )
				result <<= exponent - double.MantissaBits;
			else
				result >>= double.MantissaBits - exponent;

			return result;
		}

		/// '( long a, long b ) => { long r; overflow = checkwrap( r = a * b ); return r; }'
		[BackendHintKeep]
		[BackendSymbol( Name = "__mulodi4" )]
		private static long __mulodi4( long a, long b, Boolean32& overflow ) {
			var bits = sizeof( long ) * 8;
			var result = a * b;

			if( a == long.MinValue ) {
				overflow = bitcast<ulong>( b ) > 1;
				return result;
			}

			if( b == long.MinValue ) {
				overflow = bitcast<ulong>( a ) > 1;
				return result;
			}

			var abs_a = Math.Abs( a );
			var abs_b = Math.Abs( b );

			if( abs_a <= 1 | abs_b <= 1 ) {
				overflow = false;
				return result;
			}

			if( ( a ^ b ) >= 0 )
				overflow = abs_a > long.MaxValue / abs_b;
			else
				overflow = abs_a > long.MinValue / -abs_b;

			return result;
		}


		[UnitTest]
		private static void UnitTest() {
			Assert.AreEqual( 64.0, __powidf2( 4.0, 3 ) );
			Assert.AreEqual( 64f, __powisf2( 4f, 3 ) );

			Assert.AreEqual( 1UL, __fixunssfdi( 1f ) );
			Assert.AreEqual( 1UL, __fixunsdfdi( 1.0 ) );

			Assert.AreEqual( 1UL, __fixunssfdi( 1.5f ) );
			Assert.AreEqual( 1UL, __fixunsdfdi( 1.5 ) );

			Assert.AreEqual( 1UL, __fixunssfdi( 1.9f ) );
			Assert.AreEqual( 1UL, __fixunsdfdi( 1.9 ) );

			Assert.AreEqual( 64UL, __fixunssfdi( 64.999f ) );
			Assert.AreEqual( 64UL, __fixunsdfdi( 64.999 ) );

			Assert.AreEqual( 0UL, __fixunssfdi( -64.9999f ) );
			Assert.AreEqual( 0UL, __fixunsdfdi( -64.9999 ) );
		}
	}
}