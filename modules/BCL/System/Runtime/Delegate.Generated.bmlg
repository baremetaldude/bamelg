//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

namespace System.Runtime {
	public partial class Delegate {
		public void InvokeVoid() {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*>>( current->MethodAddress )( current->Target );
				else
					bitcast<System.Functors.Action>( current->MethodAddress )();
			}
		}

		public void InvokeVoid<T0>( T0 p0 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0>>( current->MethodAddress )( current->Target, p0 );
				else
					bitcast<System.Functors.Action<T0>>( current->MethodAddress )( p0 );
			}
		}

		public void InvokeVoid<T0, T1>( T0 p0, T1 p1 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1>>( current->MethodAddress )( current->Target, p0, p1 );
				else
					bitcast<System.Functors.Action<T0, T1>>( current->MethodAddress )( p0, p1 );
			}
		}

		public void InvokeVoid<T0, T1, T2>( T0 p0, T1 p1, T2 p2 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2>>( current->MethodAddress )( current->Target, p0, p1, p2 );
				else
					bitcast<System.Functors.Action<T0, T1, T2>>( current->MethodAddress )( p0, p1, p2 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3>( T0 p0, T1 p1, T2 p2, T3 p3 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3>>( current->MethodAddress )( current->Target, p0, p1, p2, p3 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3>>( current->MethodAddress )( p0, p1, p2, p3 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4>>( current->MethodAddress )( p0, p1, p2, p3, p4 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4, T5>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4, T5>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4, T5>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4, T5, T6>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4, T5, T6>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4, T5, T6>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4, T5, T6, T7>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4, T5, T6, T7>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4, T5, T6, T7>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4, T5, T6, T7, T8>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4, T5, T6, T7, T8>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14 );
			}
		}

		public void InvokeVoid<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15 ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.Action<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 );
				else
					bitcast<System.Functors.Action<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 );
			}
		}

		public void InvokeVoidVararg<TVararg>( vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, TVararg>>( current->MethodAddress )( current->Target, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<TVararg>>( current->MethodAddress )( vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, TVararg>( T0 p0, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, TVararg>>( current->MethodAddress )( current->Target, p0, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, TVararg>>( current->MethodAddress )( p0, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, TVararg>( T0 p0, T1 p1, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, TVararg>>( current->MethodAddress )( current->Target, p0, p1, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, TVararg>>( current->MethodAddress )( p0, p1, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, TVararg>( T0 p0, T1 p1, T2 p2, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, TVararg>>( current->MethodAddress )( p0, p1, p2, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, T5, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, T5, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, T5, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, T5, T6, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, T5, T6, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, T5, T6, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, T5, T6, T7, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, T5, T6, T7, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, T5, T6, T7, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, vararg( parameters, parameters.Length ) );
			}
		}

		public void InvokeVoidVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TVararg>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					bitcast<System.Functors.VarargAction<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TVararg>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, vararg( parameters, parameters.Length ) );
				else
					bitcast<System.Functors.VarargAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TVararg>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, vararg( parameters, parameters.Length ) );
			}
		}

		public TResult Invoke<TResult>() {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, TResult>>( current->MethodAddress )( current->Target );
				else
					result = bitcast<System.Functors.Func<TResult>>( current->MethodAddress )();
			}

			return result;
		}

		public TResult Invoke<T0, TResult>( T0 p0 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, TResult>>( current->MethodAddress )( current->Target, p0 );
				else
					result = bitcast<System.Functors.Func<T0, TResult>>( current->MethodAddress )( p0 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, TResult>( T0 p0, T1 p1 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, TResult>>( current->MethodAddress )( current->Target, p0, p1 );
				else
					result = bitcast<System.Functors.Func<T0, T1, TResult>>( current->MethodAddress )( p0, p1 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, TResult>( T0 p0, T1 p1, T2 p2 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, TResult>>( current->MethodAddress )( p0, p1, p2 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, TResult>( T0 p0, T1 p1, T2 p2, T3 p3 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, TResult>>( current->MethodAddress )( p0, p1, p2, p3 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, T5, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, T5, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, T5, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, T5, T6, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, T5, T6, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, T5, T6, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, T5, T6, T7, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, T5, T6, T7, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, T5, T6, T7, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14 );
			}

			return result;
		}

		public TResult Invoke<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15 ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.Func<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 );
				else
					result = bitcast<System.Functors.Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 );
			}

			return result;
		}

		public TResult InvokeVararg<TVararg, TResult>( vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, TVararg, TResult>>( current->MethodAddress )( current->Target, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<TVararg, TResult>>( current->MethodAddress )( vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, TVararg, TResult>( T0 p0, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, TVararg, TResult>>( current->MethodAddress )( p0, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, TVararg, TResult>( T0 p0, T1 p1, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, TVararg, TResult>>( current->MethodAddress )( p0, p1, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, TVararg, TResult>( T0 p0, T1 p1, T2 p2, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, T5, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, T5, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, T5, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, T5, T6, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, T5, T6, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, T5, T6, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, T5, T6, T7, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, T5, T6, T7, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, T5, T6, T7, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, T5, T6, T7, T8, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, vararg( parameters, parameters.Length ) );
			}

			return result;
		}

		public TResult InvokeVararg<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TVararg, TResult>( T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7, T8 p8, T9 p9, T10 p10, T11 p11, T12 p12, T13 p13, T14 p14, T15 p15, vararg TVararg parameters ) {
			AddReference(); finally { ReleaseReference(); }

			var result = default( TResult );
			var current = GetItems();
			for( var i = 0U; i < _itemCount; ++i, ++current ) {
				EnsureTargetAlive( current );
				if( current->TargetType != null )
					result = bitcast<System.Functors.VarargFunc<void*, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TVararg, TResult>>( current->MethodAddress )( current->Target, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, vararg( parameters, parameters.Length ) );
				else
					result = bitcast<System.Functors.VarargFunc<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TVararg, TResult>>( current->MethodAddress )( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, vararg( parameters, parameters.Length ) );
			}

			return result;
		}
	}
}