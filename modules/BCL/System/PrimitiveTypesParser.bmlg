//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

namespace System {
	public static struct PrimitiveTypesParser {
		public static uint SkipWhitespace<TElement>( TElement* buffer, uint length, uint offset, bool condition ) {
			if( offset >= length ) return length;
			if( !condition ) return offset;

			for( uint i = offset; i < length; ++i ) {
				switch( ( uint ) buffer[i] ) {
					// whitespace
					case '\x0085': [DisableWarningUnreachable] if( sizeof( TElement ) > 1 ) goto case ' '; goto default;
					case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':
					case '\x00A0':
					case '\x1680':
					case '\x180E':
					case '\x2000': case '\x2001': case '\x2002': case '\x2003': case '\x2004': case '\x2005': case '\x2006': case '\x2007': case '\x2008': case '\x2009':
					case '\x200A':
					case '\x2028': case '\x2029':
					case '\x202F': case '\x205F':
					case '\x3000':
						continue;

					default: return i;
				}
			}

			return length;
		}

		// NOTE for fetch methods:
		// if 'readen' == nullref trying to parse entrire string
		// if 'readen' != nullref trying to parse at least start of string
		private static TextParsingStatus TryFetchBool<TElement>( TElement* buffer, uint length, bool& parsedResult, uint& readen = nullref, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) {
			var result = true;

			var start = SkipWhitespace<TElement>( buffer, length, 0U, trimLeadingWhitespace );
			var text = buffer + start;
			var textLength = length - start;

			if( textLength >= 4 && ( text[0] == 'T' || text[0] == 't' ) ) {
				result &= text[1] == 'R' || text[1] == 'r';
				result &= text[2] == 'U' || text[2] == 'u';
				result &= text[3] == 'E' || text[3] == 'e';

				parsedResult = true;
				var end = SkipWhitespace<TElement>( text, textLength, 4, trimTrailingWhitespace );

				if( result && readen != nullref )
					readen = end;
				else
					result &= end == length;
			}
			else if( textLength >= 5 && ( text[0] == 'F' || text[0] == 'f' ) ) {
				result &= text[1] == 'A' || text[1] == 'a';
				result &= text[2] == 'L' || text[2] == 'l';
				result &= text[3] == 'S' || text[3] == 's';
				result &= text[4] == 'E' || text[4] == 'e';

				parsedResult = false;
				var end = SkipWhitespace<TElement>( text, textLength, 5, trimTrailingWhitespace );
				if( result && readen != nullref )
					readen = end;
				else
					result &= end == length;
			}
			else {
				parsedResult = false;
				result = false;
			}

			if( !result && readen != nullref ) readen = 0;

			return result ? TextParsingStatus.OK : TextParsingStatus.Format;
		}

		private static TextParsingStatus TryFetchSignedInt<TElement, TInteger>( TElement* buffer, uint length, TInteger& parsedResult, uint& readen = nullref, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) {
			if( readen != nullref ) readen = length;

			var digitsStarted = false;
			var trailingWhitespaceStarted = false;
			var minusSpecified = false;
			var maxReached = false;
			TInteger result = 0;

			for( uint i = 0; i < length; ++i ) {
				switch( ( uint ) buffer[i] ) {
					// whitespace
					case '\x0085': [DisableWarningUnreachable] if( sizeof( TElement ) > 1 ) goto case ' '; goto default;
					case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':
					case '\x00A0':
					case '\x1680':
					case '\x180E':
					case '\x2000': case '\x2001': case '\x2002': case '\x2003': case '\x2004': case '\x2005': case '\x2006': case '\x2007': case '\x2008': case '\x2009':
					case '\x200A':
					case '\x2028': case '\x2029':
					case '\x202F': case '\x205F':
					case '\x3000':
						if( !digitsStarted & !trimLeadingWhitespace ) goto default;
						if( digitsStarted & !trimTrailingWhitespace ) goto default;

						trailingWhitespaceStarted = digitsStarted;
						continue;

					case '-':
						if( digitsStarted | minusSpecified ) goto default;

						minusSpecified = true;
						continue;

					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						if( trailingWhitespaceStarted ) goto default;
						if( maxReached ) goto overflow_detected;

						digitsStarted = true;

						if( result > TInteger.MaxValue / 10 )
							goto overflow_detected;

						var digit = cast<TInteger>( buffer[i] - '0' );

						if( result == TInteger.MaxValue / 10 ) {
							if( minusSpecified ) {
								if( ( digit > TInteger.MaxValue % 10 ) && ( digit > TInteger.MaxValue % 10 + 1 ) )
									goto overflow_detected;

								result = result * cast<TInteger>( -10 ) - digit;
							}
							else {
								if( digit > TInteger.MaxValue % 10 )
									goto overflow_detected;

								result = result * cast<TInteger>( 10 ) + digit;
							}

							maxReached = true;
							continue;
						}

						result = result * 10 + digit;
						continue;

					default:
						if( readen != nullref && digitsStarted ) {
							readen = i;
							parsedResult = minusSpecified ? -result : result;
							return TextParsingStatus.OK;
						}

						parsedResult = 0;
						return TextParsingStatus.Format;
				}
			}

			if( digitsStarted ) {
				parsedResult = minusSpecified ? -result : result;
				return TextParsingStatus.OK;
			}

			parsedResult = 0;

			if( readen != nullref ) readen = 0;
			return TextParsingStatus.Format;

		overflow_detected:
			if( readen != nullref ) readen = 0;
			return TextParsingStatus.Overflow;
		}

		public static TextParsingStatus TryFetchUnsignedInt<TElement, TInteger>( TElement* buffer, uint length, TInteger& parsedResult, uint& readen = nullref, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) {
			if( readen != nullref ) readen = length;

			var digitsStarted = false;
			var trailingWhitespaceStarted = false;
			var maxReached = false;
			TInteger result = cast<TInteger>( 0 );

			for( uint i = 0; i < length; ++i ) {
				switch( ( uint ) buffer[i] ) {
					// whitespace
					case '\x0085': [DisableWarningUnreachable] if( sizeof( TElement ) > 1 ) goto case ' '; goto default;
					case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':
					case '\x00A0':
					case '\x1680':
					case '\x180E':
					case '\x2000': case '\x2001': case '\x2002': case '\x2003': case '\x2004': case '\x2005': case '\x2006': case '\x2007': case '\x2008': case '\x2009':
					case '\x200A':
					case '\x2028': case '\x2029':
					case '\x202F': case '\x205F':
					case '\x3000':
						if( !digitsStarted & !trimLeadingWhitespace ) goto default;
						if( digitsStarted & !trimTrailingWhitespace ) goto default;

						trailingWhitespaceStarted = digitsStarted;
						continue;

					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						if( trailingWhitespaceStarted ) goto default;
						if( maxReached ) goto overflow_detected;

						digitsStarted = true;

						if( result > TInteger.MaxValue / cast<TInteger>( 10 ) ) {
							goto overflow_detected;
						}

						TElement digit = buffer[i] - '0';

						if( result == TInteger.MaxValue / cast<TInteger>( 10 ) ) {
							if( digit > TInteger.MaxValue % cast<TInteger>( 10 ) )
								goto overflow_detected;

							result = result * 10 + cast<TInteger>( digit );
							maxReached = true;
							continue;
						}

						result = result * cast<TInteger>( 10 ) + cast<TInteger>( digit );
						continue;

					default:
						if( readen != nullref && digitsStarted ) {
							readen = i;
							parsedResult = result;
							return TextParsingStatus.OK;
						}

						parsedResult = 0;
						return TextParsingStatus.Format;
				}
			}

			if( digitsStarted ) {
				parsedResult = result;
				return TextParsingStatus.OK;
			}

			parsedResult = 0;

			if( readen != nullref ) readen = 0;
			return TextParsingStatus.Format;

		overflow_detected:
			if( readen != nullref ) readen = 0;
			return TextParsingStatus.Overflow;
		}

		private static TextParsingStatus TryFetchHexInt<TElement, TInteger>( TElement* buffer, uint length, TInteger& parsedResult, uint& readen = nullref, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) {
			var digitsStarted = false;
			var trailingWhitespaceStarted = false;

			var maxDigits = sizeof( TInteger ) * 2;
			var digits = 0;

			TInteger result = cast<TInteger>( 0 );
			TElement digit;

			var start = SkipWhitespace<TElement>( buffer, length, 0U, trimLeadingWhitespace );

			for( uint i = start; i < length; ++i ) {
				switch( ( uint ) buffer[i] ) {
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						digit = buffer[i] - '0';
						goto got_digit;

					case 'a':
					case 'b':
					case 'c':
					case 'd':
					case 'e':
					case 'f':
						digit = buffer[i] - 'a' + 10;
						goto got_digit;

					case 'A':
					case 'B':
					case 'C':
					case 'D':
					case 'E':
					case 'F':
						digit = buffer[i] - 'A' + 10;
						goto got_digit;

					default:
						if( digitsStarted ) {
							var end = SkipWhitespace<TElement>( buffer, length, i, trimTrailingWhitespace );

							if( readen != nullref ) {
								readen = end;

								parsedResult = result;
								return TextParsingStatus.OK;
							}
							else if( end != length ) {
								parsedResult = 0;
								return TextParsingStatus.Format;
							}
						}

						parsedResult = 0;
						return TextParsingStatus.Format;
				}

			got_digit:
				if( result != 0 ) ++digits;

				if( trailingWhitespaceStarted ) return TextParsingStatus.Format;
				if( digits > maxDigits ) return TextParsingStatus.Overflow;

				digitsStarted = true;

				result <<= 4;
				result |= cast<TInteger>( digit );

				continue;
			}

			if( digitsStarted ) {
				if( readen != nullref ) readen = length;

				parsedResult = result;
				return TextParsingStatus.OK;
			}

			if( readen != nullref ) readen = 0;
			parsedResult = 0;
			return TextParsingStatus.Format;
		}

		private static TextParsingStatus GetHexArrayLength<TElement>( TElement* buffer, uint length, uint& arrayLength, uint& readen = nullref, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) {
			if( buffer == null || length == 0 ) return TextParsingStatus.Format;

			var trailingWhitespaceStarted = false;

			var digits = 0;
			arrayLength = 0;
			TElement digit;

			var start = SkipWhitespace<TElement>( buffer, length, 0U, trimLeadingWhitespace );

			for( uint i = start; i < length; ++i ) {
				switch( ( uint ) buffer[i] ) {
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
					case 'a':
					case 'b':
					case 'c':
					case 'd':
					case 'e':
					case 'f':
					case 'A':
					case 'B':
					case 'C':
					case 'D':
					case 'E':
					case 'F':
						++arrayLength;
						if( trailingWhitespaceStarted ) return TextParsingStatus.Format;
						continue;

					default:
						if( arrayLength > 0 ) {
							var end = SkipWhitespace<TElement>( buffer, length, i, trimTrailingWhitespace );

							if( readen != nullref ) {
								readen = end;

								var result = TextParsingStatus.OK;
								if( ( arrayLength & 1 ) != 0 ) { result = TextParsingStatus.Format; arrayLength = 0; }
								else arrayLength /= 2;
								return result;
							}
							else if( end != length ) {
								arrayLength = 0;
								return TextParsingStatus.Format;
							}
						}

						arrayLength = 0;
						return TextParsingStatus.Format;
				}
			}

			if( arrayLength > 0 ) {
				if( readen != nullref ) readen = length;

				var result = TextParsingStatus.OK;
				if( ( arrayLength & 1 ) != 0 ) { result = TextParsingStatus.Format; arrayLength = 0; }
				else arrayLength /= 2;
				return result;
			}

			if( readen != nullref ) readen = 0;
			arrayLength = 0;
			return TextParsingStatus.Format;
		}

		private static TextParsingStatus TryFetchHexArray<TElement>( TElement* buffer, uint length, byte[]& parsedResult, uint& readen = nullref, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) {
			if( buffer == null || length == 0 ) return TextParsingStatus.Format;

			uint arrayLength;
			var status = GetHexArrayLength<TElement>( buffer, length, arrayLength, readen, trimLeadingWhitespace, trimTrailingWhitespace );
			if( !status ) return status;

			int digits = 0;
			var trailingWhitespaceStarted = false;

			byte digit;
			parsedResult = new[arrayLength] byte;
			if( parsedResult == null ) return TextParsingStatus.Format;

			var start = SkipWhitespace<TElement>( buffer, length, 0U, trimLeadingWhitespace );

			for( uint i = start; i < length; ++i ) {
				switch( ( uint ) buffer[i] ) {
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						digit = ( byte )( buffer[i] - '0' );
						goto got_digit;

					case 'a':
					case 'b':
					case 'c':
					case 'd':
					case 'e':
					case 'f':
						digit = ( byte )( buffer[i] - 'a' + 10 );
						goto got_digit;

					case 'A':
					case 'B':
					case 'C':
					case 'D':
					case 'E':
					case 'F':
						digit = ( byte )( buffer[i] - 'A' + 10 );
						goto got_digit;

					default:
						if( digits > 0 ) {
							var end = SkipWhitespace<TElement>( buffer, length, i, trimTrailingWhitespace );

							if( readen != nullref ) {
								readen = end;

								return TextParsingStatus.OK;
							}
							else if( end != length ) {
								parsedResult = null;
								return TextParsingStatus.Format;
							}
						}

						parsedResult = null;
						return TextParsingStatus.Format;
				}

			got_digit:
				if( trailingWhitespaceStarted ) return TextParsingStatus.Format;

				if( ( digits & 1 ) == 0 ) parsedResult[i / 2] = digit << 4;
				else parsedResult[i / 2] |= digit;

				++digits;
				continue;
			}

			if( digits > 0 ) {
				if( readen != nullref ) readen = length;
				return TextParsingStatus.OK;
			}

			if( readen != nullref ) readen = 0;
			parsedResult = null;
			return TextParsingStatus.Format;
		}

		public static TextParsingStatus TryFetchWhitespace( byte*& buffer, uint& remaining ) { var end = SkipWhitespace<byte>( buffer, remaining, 0, true ); buffer += end; remaining -= end; return end != 0 ? TextParsingStatus.OK : TextParsingStatus.Format; }
		public static TextParsingStatus TryFetchWhitespace( char*& buffer, uint& remaining ) { var end = SkipWhitespace<char>( buffer, remaining, 0, true ); buffer += end; remaining -= end; return end != 0 ? TextParsingStatus.OK : TextParsingStatus.Format; }
		public static TextParsingStatus TryFetchWhitespace( uint*& buffer, uint& remaining ) { var end = SkipWhitespace<uint>( buffer, remaining, 0, true ); buffer += end; remaining -= end; return end != 0 ? TextParsingStatus.OK : TextParsingStatus.Format; }

		public static TextParsingStatus TryFetchSpecificChar( byte*& buffer, uint& remaining, char value ) { if( remaining == 0 ) return TextParsingStatus.Format; var result = *buffer == value; if( result ) { ++buffer; --remaining; } return result ? TextParsingStatus.OK : TextParsingStatus.Format; }
		public static TextParsingStatus TryFetchSpecificChar( char*& buffer, uint& remaining, char value ) { if( remaining == 0 ) return TextParsingStatus.Format; var result = *buffer == value; if( result ) { ++buffer; --remaining; } return result ? TextParsingStatus.OK : TextParsingStatus.Format; }
		public static TextParsingStatus TryFetchSpecificChar( uint*& buffer, uint& remaining, char value ) { if( remaining == 0 ) return TextParsingStatus.Format; var result = *buffer == value; if( result ) { ++buffer; --remaining; } return result ? TextParsingStatus.OK : TextParsingStatus.Format; }

		/// @{ parse 1-byte strings
		public static TextParsingStatus TryFetchBool( byte*& buffer, uint& remaining, bool& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchBool<byte>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryFetchInt8( byte*& buffer, uint& remaining, sbyte& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<byte, sbyte>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchInt16( byte*& buffer, uint& remaining, short& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<byte, short>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchInt32( byte*& buffer, uint& remaining, int& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<byte, int>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchInt64( byte*& buffer, uint& remaining, long& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<byte, long>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryFetchUInt8( byte*& buffer, uint& remaining, byte& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<byte, byte>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchUInt16( byte*& buffer, uint& remaining, ushort& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<byte, ushort>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchUInt32( byte*& buffer, uint& remaining, uint& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<byte, uint>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchUInt64( byte*& buffer, uint& remaining, ulong& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<byte, ulong>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryFetchHexUInt8( byte*& buffer, uint& remaining, byte& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<byte, byte>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchHexUInt16( byte*& buffer, uint& remaining, ushort& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<byte, ushort>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchHexUInt32( byte*& buffer, uint& remaining, uint& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<byte, uint>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchHexUInt64( byte*& buffer, uint& remaining, ulong& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<byte, ulong>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryParseBool( byte* buffer, uint length, bool& parsedResult ) { return TryFetchBool<byte>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseInt8( byte* buffer, uint length, sbyte& parsedResult ) { return TryFetchSignedInt<byte, sbyte>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseInt16( byte* buffer, uint length, short& parsedResult ) { return TryFetchSignedInt<byte, short>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseInt32( byte* buffer, uint length, int& parsedResult ) { return TryFetchSignedInt<byte, int>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseInt64( byte* buffer, uint length, long& parsedResult ) { return TryFetchSignedInt<byte, long>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseUInt8( byte* buffer, uint length, byte& parsedResult ) { return TryFetchUnsignedInt<byte, byte>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseUInt16( byte* buffer, uint length, ushort& parsedResult ) { return TryFetchUnsignedInt<byte, ushort>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseUInt32( byte* buffer, uint length, uint& parsedResult ) { return TryFetchUnsignedInt<byte, uint>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseUInt64( byte* buffer, uint length, ulong& parsedResult ) { return TryFetchUnsignedInt<byte, ulong>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseHexUInt8( byte* buffer, uint length, byte& parsedResult ) { return TryFetchHexInt<byte, byte>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseHexUInt16( byte* buffer, uint length, ushort& parsedResult ) { return TryFetchHexInt<byte, ushort>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseHexUInt32( byte* buffer, uint length, uint& parsedResult ) { return TryFetchHexInt<byte, uint>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseHexUInt64( byte* buffer, uint length, ulong& parsedResult ) { return TryFetchHexInt<byte, ulong>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseSingleIEEE754( byte* buffer, uint length, float& parsedResult ) { return TryParseSingleIEEE754<byte>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseDoubleIEEE754( byte* buffer, uint length, double& parsedResult ) { return TryParseIEEE754<byte>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseByteArray( byte* buffer, uint length, byte[]& parsedResult ) { return TryFetchHexArray<byte>( buffer, length, parsedResult ); }
		public static byte[] ParseByteArray( byte* buffer, uint length ) { byte[] parsedResult; var status = TryParseByteArray( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static bool ParseBool( byte* buffer, uint length ) { bool parsedResult; var status = TryParseBool( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static sbyte ParseInt8( byte* buffer, uint length ) { sbyte parsedResult; var status = TryParseInt8( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static short ParseInt16( byte* buffer, uint length ) { short parsedResult; var status = TryParseInt16( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static int ParseInt32( byte* buffer, uint length ) { int parsedResult; var status = TryParseInt32( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static long ParseInt64( byte* buffer, uint length ) { long parsedResult; var status = TryParseInt64( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static byte ParseUInt8( byte* buffer, uint length ) { byte parsedResult; var status = TryParseUInt8( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static ushort ParseUInt16( byte* buffer, uint length ) { ushort parsedResult; var status = TryParseUInt16( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static uint ParseUInt32( byte* buffer, uint length ) { uint parsedResult; var status = TryParseUInt32( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static ulong ParseUInt64( byte* buffer, uint length ) { ulong parsedResult; var status = TryParseUInt64( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static byte ParseHexUInt8( byte* buffer, uint length ) { byte parsedResult; var status = TryParseHexUInt8( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static ushort ParseHexUInt16( byte* buffer, uint length ) { ushort parsedResult; var status = TryParseHexUInt16( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static uint ParseHexUInt32( byte* buffer, uint length ) { uint parsedResult; var status = TryParseHexUInt32( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static ulong ParseHexUInt64( byte* buffer, uint length ) { ulong parsedResult; var status = TryParseHexUInt64( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static float ParseSingleIEEE754( byte* buffer, uint length ) { float parsedResult; var status = TryParseSingleIEEE754( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static double ParseDoubleIEEE754( byte* buffer, uint length ) { double parsedResult; var status = TryParseDoubleIEEE754( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		/// @}

		/// @{ parse 2-byte strings
		public static TextParsingStatus TryFetchBool( char*& buffer, uint& remaining, bool& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchBool<char>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryFetchInt8( char*& buffer, uint& remaining, sbyte& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<char, sbyte>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchInt16( char*& buffer, uint& remaining, short& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<char, short>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchInt32( char*& buffer, uint& remaining, int& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<char, int>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchInt64( char*& buffer, uint& remaining, long& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<char, long>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryFetchUInt8( char*& buffer, uint& remaining, byte& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<char, byte>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchUInt16( char*& buffer, uint& remaining, ushort& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<char, ushort>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchUInt32( char*& buffer, uint& remaining, uint& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<char, uint>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchUInt64( char*& buffer, uint& remaining, ulong& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<char, ulong>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryFetchHexUInt8( char*& buffer, uint& remaining, byte& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<char, byte>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchHexUInt16( char*& buffer, uint& remaining, ushort& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<char, ushort>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchHexUInt32( char*& buffer, uint& remaining, uint& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<char, uint>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchHexUInt64( char*& buffer, uint& remaining, ulong& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<char, ulong>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryParseBool( char* buffer, uint length, bool& parsedResult ) { return TryFetchBool<char>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseInt8( char* buffer, uint length, sbyte& parsedResult ) { return TryFetchSignedInt<char, sbyte>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseInt16( char* buffer, uint length, short& parsedResult ) { return TryFetchSignedInt<char, short>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseInt32( char* buffer, uint length, int& parsedResult ) { return TryFetchSignedInt<char, int>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseInt64( char* buffer, uint length, long& parsedResult ) { return TryFetchSignedInt<char, long>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseUInt8( char* buffer, uint length, byte& parsedResult ) { return TryFetchUnsignedInt<char, byte>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseUInt16( char* buffer, uint length, ushort& parsedResult ) { return TryFetchUnsignedInt<char, ushort>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseUInt32( char* buffer, uint length, uint& parsedResult ) { return TryFetchUnsignedInt<char, uint>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseUInt64( char* buffer, uint length, ulong& parsedResult ) { return TryFetchUnsignedInt<char, ulong>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseHexUInt8( char* buffer, uint length, byte& parsedResult ) { return TryFetchHexInt<char, byte>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseHexUInt16( char* buffer, uint length, ushort& parsedResult ) { return TryFetchHexInt<char, ushort>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseHexUInt32( char* buffer, uint length, uint& parsedResult ) { return TryFetchHexInt<char, uint>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseHexUInt64( char* buffer, uint length, ulong& parsedResult ) { return TryFetchHexInt<char, ulong>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseSingleIEEE754( char* buffer, uint length, float& parsedResult ) { return TryParseSingleIEEE754<char>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseDoubleIEEE754( char* buffer, uint length, double& parsedResult ) { return TryParseIEEE754<char>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseByteArray( char* buffer, uint length, byte[]& parsedResult ) { return TryFetchHexArray<char>( buffer, length, parsedResult ); }
		public static byte[] ParseByteArray( char* buffer, uint length ) { byte[] parsedResult; var status = TryParseByteArray( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static bool ParseBool( char* buffer, uint length ) { bool parsedResult; var status = TryParseBool( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static sbyte ParseInt8( char* buffer, uint length ) { sbyte parsedResult; var status = TryParseInt8( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static short ParseInt16( char* buffer, uint length ) { short parsedResult; var status = TryParseInt16( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static int ParseInt32( char* buffer, uint length ) { int parsedResult; var status = TryParseInt32( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static long ParseInt64( char* buffer, uint length ) { long parsedResult; var status = TryParseInt64( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static byte ParseUInt8( char* buffer, uint length ) { byte parsedResult; var status = TryParseUInt8( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static ushort ParseUInt16( char* buffer, uint length ) { ushort parsedResult; var status = TryParseUInt16( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static uint ParseUInt32( char* buffer, uint length ) { uint parsedResult; var status = TryParseUInt32( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static ulong ParseUInt64( char* buffer, uint length ) { ulong parsedResult; var status = TryParseUInt64( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static float ParseSingleIEEE754( char* buffer, uint length ) { float parsedResult; var status = TryParseSingleIEEE754( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static double ParseDoubleIEEE754( char* buffer, uint length ) { double parsedResult; var status = TryParseDoubleIEEE754( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		/// @}

		/// @{ parse 4-byte strings
		public static TextParsingStatus TryFetchBool( uint*& buffer, uint& remaining, bool& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchBool<uint>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryFetchInt8( uint*& buffer, uint& remaining, sbyte& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<uint, sbyte>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchInt16( uint*& buffer, uint& remaining, short& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<uint, short>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchInt32( uint*& buffer, uint& remaining, int& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<uint, int>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchInt64( uint*& buffer, uint& remaining, long& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchSignedInt<uint, long>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryFetchUInt8( uint*& buffer, uint& remaining, byte& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<uint, byte>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchUInt16( uint*& buffer, uint& remaining, ushort& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<uint, ushort>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchUInt32( uint*& buffer, uint& remaining, uint& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<uint, uint>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchUInt64( uint*& buffer, uint& remaining, ulong& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchUnsignedInt<uint, ulong>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryFetchHexUInt8( uint*& buffer, uint& remaining, byte& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<uint, byte>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchHexUInt16( uint*& buffer, uint& remaining, ushort& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<uint, ushort>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchHexUInt32( uint*& buffer, uint& remaining, uint& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<uint, uint>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }
		public static TextParsingStatus TryFetchHexUInt64( uint*& buffer, uint& remaining, ulong& parsedResult, bool trimLeadingWhitespace = true, bool trimTrailingWhitespace = true ) { uint readen; var result = TryFetchHexInt<uint, ulong>( buffer, remaining, parsedResult, readen, trimLeadingWhitespace, trimTrailingWhitespace ); if( result ) { buffer += readen; remaining -= readen; } return result; }

		public static TextParsingStatus TryParseBool( uint* buffer, uint length, bool& parsedResult ) { return TryFetchBool<uint>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseInt8( uint* buffer, uint length, sbyte& parsedResult ) { return TryFetchSignedInt<uint, sbyte>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseInt16( uint* buffer, uint length, short& parsedResult ) { return TryFetchSignedInt<uint, short>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseInt32( uint* buffer, uint length, int& parsedResult ) { return TryFetchSignedInt<uint, int>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseInt64( uint* buffer, uint length, long& parsedResult ) { return TryFetchSignedInt<uint, long>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseUInt8( uint* buffer, uint length, byte& parsedResult ) { return TryFetchUnsignedInt<uint, byte>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseUInt16( uint* buffer, uint length, ushort& parsedResult ) { return TryFetchUnsignedInt<uint, ushort>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseUInt32( uint* buffer, uint length, uint& parsedResult ) { return TryFetchUnsignedInt<uint, uint>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseUInt64( uint* buffer, uint length, ulong& parsedResult ) { return TryFetchUnsignedInt<uint, ulong>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseHexUInt8( uint* buffer, uint length, byte& parsedResult ) { return TryFetchHexInt<uint, byte>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseHexUInt16( uint* buffer, uint length, ushort& parsedResult ) { return TryFetchHexInt<uint, ushort>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseHexUInt32( uint* buffer, uint length, uint& parsedResult ) { return TryFetchHexInt<uint, uint>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseHexUInt64( uint* buffer, uint length, ulong& parsedResult ) { return TryFetchHexInt<uint, ulong>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseSingleIEEE754( uint* buffer, uint length, float& parsedResult ) { return TryParseSingleIEEE754<uint>( buffer, length, parsedResult ); }
		public static TextParsingStatus TryParseDoubleIEEE754( uint* buffer, uint length, double& parsedResult ) { return TryParseIEEE754<uint>( buffer, length, parsedResult ); }

		public static TextParsingStatus TryParseByteArray( uint* buffer, uint length, byte[]& parsedResult ) { return TryFetchHexArray<uint>( buffer, length, parsedResult ); }
		public static byte[] ParseByteArray( uint* buffer, uint length ) { byte[] parsedResult; var status = TryParseByteArray( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static bool ParseBool( uint* buffer, uint length ) { bool parsedResult; var status = TryParseBool( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static sbyte ParseInt8( uint* buffer, uint length ) { sbyte parsedResult; var status = TryParseInt8( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static short ParseInt16( uint* buffer, uint length ) { short parsedResult; var status = TryParseInt16( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static int ParseInt32( uint* buffer, uint length ) { int parsedResult; var status = TryParseInt32( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static long ParseInt64( uint* buffer, uint length ) { long parsedResult; var status = TryParseInt64( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static byte ParseUInt8( uint* buffer, uint length ) { byte parsedResult; var status = TryParseUInt8( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static ushort ParseUInt16( uint* buffer, uint length ) { ushort parsedResult; var status = TryParseUInt16( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static uint ParseUInt32( uint* buffer, uint length ) { uint parsedResult; var status = TryParseUInt32( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static ulong ParseUInt64( uint* buffer, uint length ) { ulong parsedResult; var status = TryParseUInt64( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }

		public static float ParseSingleIEEE754( uint* buffer, uint length ) { float parsedResult; var status = TryParseSingleIEEE754( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		public static double ParseDoubleIEEE754( uint* buffer, uint length ) { double parsedResult; var status = TryParseDoubleIEEE754( buffer, length, parsedResult ); BclErrorHandler.ParserException( status ); return parsedResult; }
		/// @}

		private static readonly int[15] ExponentBias = new int[15] { 4, 7, 10, 14, 17, 20, 24, 27, 30, 34, 37, 40, 44, 47, 50 };
		private static readonly ulong[15] MantissaPower10 = new ulong[15] { 0xA000000000000000, 0xC800000000000000, 0xFA00000000000000, 0x9C40000000000000, 0xC350000000000000, 0xF424000000000000, 0x9896800000000000, 0xBEBC200000000000, 0xEE6B280000000000, 0x9502F90000000000, 0xBA43B74000000000, 0xE8D4A51000000000, 0x9184E72A00000000, 0xB5E620F480000000, 0xE35FA931A0000000 };
		private static readonly ulong[15] MantissaPower01 = new ulong[15] { 0xCCCCCCCCCCCCCCCD, 0xA3D70A3D70A3D70B, 0x83126E978D4FDF3C, 0xD1B71758E219652E, 0xA7C5AC471B478425, 0x8637BD05AF6C69B7, 0xD6BF94D5E57A42BE, 0xABCC77118461CEFF, 0x89705F4136B4A599, 0xDBE6FECEBDEDD5C2, 0xAFEBFF0BCB24AB02, 0x8CBCCC096F5088CF, 0xE12E13424BB40E18, 0xB424DC35095CD813, 0x901D7CF73AB0ACDC };

		private static readonly int[21] ExponentBias16 = new int[21] { 54, 107, 160, 213, 266, 319, 373, 426, 479, 532, 585, 638, 691, 745, 798, 851, 904, 957, 1010, 1064, 1117 };
		private static readonly ulong[21] MantissaPower10By16 = new ulong[21] { 0x8E1BC9BF04000000, 0x9DC5ADA82B70B59E, 0xAF298D050E4395D6, 0xC2781F49FFCFA6D4, 0xD7E77A8F87DAF7FA, 0xEFB3AB16C59B14A0, 0x850FADC09923329C, 0x93BA47C980E98CDE, 0xA402B9C5A8D3A6E6, 0xB616A12B7FE617A8, 0xCA28A291859BBF90, 0xE070F78D39275566, 0xF92E0C3537826140, 0x8A5296FFE33CC92C, 0x9991A6F3D6BF1762, 0xAA7EEBFB9DF9DE8A, 0xBD49D14AA79DBC7E, 0xD226FC195C6A2F88, 0xE950DF20247C83F8, 0x81842F29F2CCE373, 0x8FCAC257558EE4E2 };
		private static readonly ulong[21] MantissaPower01By16 = new ulong[21] { 0xE69594BEC44DE160, 0xCFB11EAD453994C3, 0xBB127C53B17EC165, 0xA87FEA27A539E9B3, 0x97C560BA6B0919B5, 0x88B402F7FD7553AB, 0xF64335BCF065D3A0, 0xDDD0467C64BCE4C4, 0xC7CABA6E7C5382ED, 0xB3F4E093DB73A0B7, 0xA21727DB38CB0053, 0x91FF83775423CC29, 0x8380DEA93DA4BC82, 0xECE53CEC4A314F00, 0xD5605FCDCF32E217, 0xC0314325637A1978, 0xAD1C8EAB5EE43BA2, 0x9BECCE62836AC5B0, 0x8C71DCD9BA0B495C, 0xFD00B89747823938, 0xE3E27A444D8D991A };

		private static TextParsingStatus TryParseSingleIEEE754<TElement>( TElement* text, uint length, float& parsedResult ) {
			double result;
			var status = TryParseIEEE754<TElement>( text, length, result );
			if( status ) {
				if( !result.IsSpecial )
					if( result < float.MinValue || result > float.MaxValue )
						return TextParsingStatus.Overflow;

				parsedResult = ( float ) result;
			}

			return status;
		}

		private static TextParsingStatus TryParseIEEE754<TElement>( TElement* text, uint length, double& parsedResult ) {
			var mainDoublePart = 0UL;
			var mainPartDigits = 0;

			var longValue = 0UL;

			var auxillaryDoublePart = 0UL;
			var auxillaryPartDigits = 0;

			var exponentPart = 0;
			var initialExponent = 0;

			var readIndex = 0U;
			var maxReached = false;
			var minusSpecified = false;

			// handle leading whitespaces
			for( ; readIndex < length; ++readIndex ) {
				switch( ( uint ) text[readIndex] ) {
					// whitespace
					case '\x0085': [DisableWarningUnreachable] if( sizeof( TElement ) > 1 ) goto case ' '; goto default;
					case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':
					case '\x00A0':
					case '\x1680':
					case '\x180E':
					case '\x2000': case '\x2001': case '\x2002': case '\x2003': case '\x2004': case '\x2005': case '\x2006': case '\x2007': case '\x2008': case '\x2009':
					case '\x200A':
					case '\x2028': case '\x2029':
					case '\x202F': case '\x205F':
					case '\x3000':
						if( minusSpecified ) return TextParsingStatus.Format;
						continue;

					case '-':
						if( minusSpecified ) return TextParsingStatus.Format;
						minusSpecified = true;
						continue;
					default: goto fetchIntegerPart;
				}
			}

		fetchIntegerPart:
			if( readIndex < length )
				switch( text[readIndex] ) {
					case '\0': break;

					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						if( text[readIndex] == '0' && mainPartDigits == 0 ) {
							++readIndex;
							goto fetchIntegerPart;
						}

						if( mainPartDigits < 9 ) {
							mainDoublePart *= 10;
							mainDoublePart += ( int ) text[readIndex] - '0';
							++mainPartDigits;
						}
						else if( auxillaryPartDigits < 9 ) {
							auxillaryDoublePart *= 10;
							auxillaryDoublePart += ( int ) text[readIndex] - '0';
							++auxillaryPartDigits;
						}
						else {
							++initialExponent;
						}

						++readIndex;
						goto fetchIntegerPart;
				}

			if( readIndex < length )
				if( text[readIndex] == '.' ) {
					++readIndex;

				fetchFractionalPart:
					if( readIndex < length )
						switch( text[readIndex] ) {
							case '\0': break;

							case '0':
							case '1':
							case '2':
							case '3':
							case '4':
							case '5':
							case '6':
							case '7':
							case '8':
							case '9':
								if( mainPartDigits < 9 ) {
									mainDoublePart *= 10;
									mainDoublePart += ( int ) text[readIndex] - '0';
									++mainPartDigits;
								}
								else if( auxillaryPartDigits < 9 ) {
									auxillaryDoublePart *= 10;
									auxillaryDoublePart += ( int ) text[readIndex] - '0';
									++auxillaryPartDigits;
								}
								// skip non-important digits
								else {
									++readIndex;
									goto fetchFractionalPart;
								}

								--initialExponent;
								++readIndex;
								goto fetchFractionalPart;
						}
				}

			// scientific notation
			if( readIndex < length )
				switch( ( uint ) text[readIndex] ) {
					case '\0': break;

					// whitespace
					case '\x0085':
					case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':
					case '\x00A0':
					case '\x1680':
					case '\x180E':
					case '\x2000': case '\x2001': case '\x2002': case '\x2003': case '\x2004': case '\x2005': case '\x2006': case '\x2007': case '\x2008': case '\x2009':
					case '\x200A':
					case '\x2028': case '\x2029':
					case '\x202F': case '\x205F':
					case '\x3000':
						break;

					case 'e':
					case 'E': {
							++readIndex;
							if( readIndex >= length ) return TextParsingStatus.Format;

							var isNegativeExponent = false;

							if( text[readIndex] == '-' || text[readIndex] == '+' ) {
								isNegativeExponent = text[readIndex] == '-';
								++readIndex;
								if( readIndex >= length ) return TextParsingStatus.Format;
							}

							if( cast<char>( text[readIndex] ).IsDigit ) {
								while( cast<char>( text[readIndex] ).IsDigit ) {
									exponentPart *= 10;
									exponentPart += ( int )( text[readIndex] - '0' );
									++readIndex;
									if( readIndex >= length ) break;
								}
							}
							else {
								return TextParsingStatus.Format;
							}

							if( isNegativeExponent )
								exponentPart = -exponentPart;
						} break;
					default:
						return TextParsingStatus.Format;
				}

			// handle trailing whitespaces
			for( ; readIndex < length; ++readIndex ) {
				switch( ( uint ) text[readIndex] ) {
					case '\0': break;

					// whitespace
					case '\x0085': [DisableWarningUnreachable] if( sizeof( TElement ) > 1 ) goto case ' '; goto default;
					case ' ': case '\t': case '\n': case '\v': case '\f': case '\r':
					case '\x00A0':
					case '\x1680':
					case '\x180E':
					case '\x2000': case '\x2001': case '\x2002': case '\x2003': case '\x2004': case '\x2005': case '\x2006': case '\x2007': case '\x2008': case '\x2009':
					case '\x200A':
					case '\x2028': case '\x2029':
					case '\x202F': case '\x205F':
					case '\x3000':
						continue;

					default: return TextParsingStatus.Format;
				}
			}

			var doubleValue = 0.0;

			var biasedExponent = 64;
			var mantissa = mainDoublePart;

			if( auxillaryPartDigits > 0 )
				mantissa = mantissa * ( uint )( MantissaPower10[auxillaryPartDigits - 1] >> 64 - ExponentBias[auxillaryPartDigits - 1] ) + auxillaryDoublePart;

			var power10 = exponentPart + initialExponent;
			var absolutePower10 = Math.Abs( power10 );
			bool isPowerNegative = power10 < 0;

			if( absolutePower10 > ( ExponentBias.Length + 1 ) * ( ExponentBias16.Length + 1 ) ) {
				if( power10 > 0 )
					doubleValue = double.PositiveInfinity;

				goto doubleValueComputed;
			}

			if( mantissa == 0 ) {
				doubleValue = 0;
				goto doubleValueComputed;
			}

			var mantissaShift = mantissa;

			mantissaShift |= mantissaShift >> 1;
			mantissaShift |= mantissaShift >> 2;
			mantissaShift |= mantissaShift >> 4;
			mantissaShift |= mantissaShift >> 8;
			mantissaShift |= mantissaShift >> 16;
			mantissaShift |= mantissaShift >> 32;
			mantissaShift -= ( mantissaShift >> 1 ) & 0x5555555555555555UL;
			mantissaShift = ( ( mantissaShift >> 2 ) & 0x3333333333333333UL ) + ( mantissaShift & 0x3333333333333333UL );
			mantissaShift = ( ( mantissaShift >> 4 ) + mantissaShift ) & 0x0F0F0F0F0F0F0F0FUL;
			mantissaShift += mantissaShift >> 8;
			mantissaShift += mantissaShift >> 16;
			mantissaShift += mantissaShift >> 32;
			mantissaShift = mantissaShift & 0x7F;

			mantissa <<= 64 - ( int ) mantissaShift;
			biasedExponent -= 64 - ( int ) mantissaShift;

			var mantissaValues = isPowerNegative ? MantissaPower01 : MantissaPower10;
			var mantissa16Values = isPowerNegative ? MantissaPower01By16 : MantissaPower10By16;

			var mantissaElementIndex = absolutePower10 & 0xF;
			if( mantissaElementIndex != 0 ) {
				biasedExponent += isPowerNegative ? -ExponentBias[mantissaElementIndex - 1] + 1 : ExponentBias[mantissaElementIndex - 1];
				MultiplyMantissa( mantissa, mantissaValues[mantissaElementIndex - 1], biasedExponent );
			}

			mantissaElementIndex = absolutePower10 >> 4;
			if( mantissaElementIndex != 0 ) {
				biasedExponent += isPowerNegative ? -ExponentBias16[mantissaElementIndex - 1] + 1 : ExponentBias16[mantissaElementIndex - 1];
				MultiplyMantissa( mantissa, mantissa16Values[mantissaElementIndex - 1], biasedExponent );
			}

			if( ( ( uint ) mantissa & ( 1 << 10 ) ) != 0 ) {
				var roundedMantissa = mantissa + 0x3FF + ( ( mantissa >> 11 ) & 1 );

				if( roundedMantissa < mantissa ) {
					roundedMantissa = ( roundedMantissa >> 1 ) | 0x8000000000000000;
					biasedExponent += 1;
				}

				mantissa = roundedMantissa;
			}

			mantissa >>= 11;
			biasedExponent += 0x3FE;

			if( biasedExponent <= -52 )
				*( ulong* ) &doubleValue = 0;
			else if( biasedExponent <= 0 )
				*( ulong* ) &doubleValue >>= -biasedExponent + 1;
			else if( biasedExponent >= 0x7FF )
				*( ulong* ) &doubleValue = 0x7FF0000000000000UL;
			else
				*( ulong* ) &doubleValue = ( ( ulong ) biasedExponent << 52 ) + ( mantissa & 0x000FFFFFFFFFFFFF );

		doubleValueComputed:
			parsedResult = minusSpecified ? -doubleValue : doubleValue;
			return TextParsingStatus.OK;
		}

		private static void MultiplyMantissa( ulong& mantissa, ulong value, int& biasedExponent ) {
			mantissa = ( ( mantissa >> 32 ) * ( value >> 32 ) ) + ( ( mantissa >> 32 ) * ( uint ) value >> 32 ) + ( ( uint ) mantissa * ( value >> 32 ) >> 32 );

			if( ( mantissa & 0x8000000000000000 ) == 0 ) {
				mantissa <<= 1;
				biasedExponent -= 1;
			}
		}

		[UnitTest]
		public static void ParseTest() {
			Assert.AreEqual( sbyte.MinValue, sbyte.Parse( sbyte.MinValue.ToString() ) );
			Assert.AreEqual( sbyte.MaxValue, sbyte.Parse( sbyte.MaxValue.ToString() ) );
			Assert.AreEqual( short.MinValue, short.Parse( short.MinValue.ToString() ) );
			Assert.AreEqual( short.MaxValue, short.Parse( short.MaxValue.ToString() ) );
			Assert.AreEqual( int.MinValue, int.Parse( int.MinValue.ToString() ) );
			Assert.AreEqual( int.MaxValue, int.Parse( int.MaxValue.ToString() ) );
			Assert.AreEqual( long.MinValue, long.Parse( long.MinValue.ToString() ) );
			Assert.AreEqual( long.MaxValue, long.Parse( long.MaxValue.ToString() ) );

			Assert.AreEqual( byte.MinValue, byte.Parse( byte.MinValue.ToString() ) );
			Assert.AreEqual( byte.MaxValue, byte.Parse( byte.MaxValue.ToString() ) );
			Assert.AreEqual( ushort.MinValue, ushort.Parse( ushort.MinValue.ToString() ) );
			Assert.AreEqual( ushort.MaxValue, ushort.Parse( ushort.MaxValue.ToString() ) );
			Assert.AreEqual( uint.MinValue, uint.Parse( uint.MinValue.ToString() ) );
			Assert.AreEqual( uint.MaxValue, uint.Parse( uint.MaxValue.ToString() ) );
			Assert.AreEqual( ulong.MinValue, ulong.Parse( ulong.MinValue.ToString() ) );
			Assert.AreEqual( ulong.MaxValue, ulong.Parse( ulong.MaxValue.ToString() ) );

			Assert.AreEqual( 123456789.12345, double.Parse( "123456789.12345" ) ); // 15-digit precision
		}
	}
}