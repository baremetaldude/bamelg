//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System.Diagnostics;

namespace System {
	public sealed partial struct TimeSpan {
		public long Ticks;

		public TimeSpan( long ticks ) { Ticks = ticks; }

		public TimeSpan( int hours, int minutes, int seconds ) { Assert.IsTrue( TryTimeToTicks( Ticks, hours, minutes, seconds ) ); }
		public TimeSpan( int days, int hours, int minutes, int seconds ) { Assert.IsTrue( TryTimeToTicks( Ticks, days, hours, minutes, seconds ) ); }
		public TimeSpan( int days, int hours, int minutes, int seconds, int milliseconds ) { Assert.IsTrue( TryTimeToTicks( Ticks, days, hours, minutes, seconds, milliseconds ) ); }

		internal static bool TryTimeToTicks( long& result, int hour, int minute, int second ) {
			if( checkwrap( result = hour * ( 60L * 60 ) * TicksPerSecond + minute * 60L * TicksPerSecond + second * TicksPerSecond ) ) { result = long.MaxValue; return false; }
			return true;
		}

		internal static bool TryTimeToTicks( long& result, int days, int hour, int minute, int second ) {
			if( checkwrap( result = days * ( 24L * 60 * 60 ) * TicksPerSecond + hour * ( 60L * 60 ) * TicksPerSecond + minute * 60L * TicksPerSecond + second * TicksPerSecond ) ) { result = long.MaxValue; return false; }
			return true;
		}

		internal static bool TryTimeToTicks( long& result, int days, int hour, int minute, int second, int millisecond ) {
			if( checkwrap( result = days * ( 24L * 60 * 60 * 1000 ) * TicksPerMillisecond + hour * ( 60L * 60 * 1000 ) * TicksPerMillisecond + minute * 60L * 1000 * TicksPerMillisecond + second * 1000L * TicksPerMillisecond + millisecond * TicksPerMillisecond ) ) { result = long.MaxValue; return false; }
			return true;
		}

		public static bool TryAddTicks( long& result, long ticks, long value ) {
			return !checkwrap( result = ticks + value );
		}

		public static bool TrySubtractTicks( long& result, long ticks, long value ) {
			return !checkwrap( result = ticks - value );
		}

		public TimeSpan Add( TimeSpan ts ) {
			long ticks;
			if( Assert.IsTrue( TryAddTicks( ticks, Ticks, ts.Ticks ) ) ) return new TimeSpan( ticks );

			return ts.Ticks >= 0 ? MaxValue : MinValue;
		}

		public TimeSpan Subtract( TimeSpan ts ) {
			long ticks;
			if( Assert.IsTrue( TrySubtractTicks( ticks, Ticks, ts.Ticks ) ) ) return new TimeSpan( ticks );

			return ts.Ticks >= 0 ? MaxValue : MinValue;
		}

		public bool TryNegate() {
			if( Ticks == long.MinValue ) { Ticks = ~Ticks; return false; }
			Ticks = -Ticks;
			return true;
		}

		public static TimeSpan operator %( TimeSpan t1, TimeSpan t2 ) { return new TimeSpan( t1.Ticks % t2.Ticks ); }

		public static TimeSpan operator *( TimeSpan t1, int t2 ) { return new TimeSpan( t1.Ticks * t2 ); }
		public static TimeSpan operator /( TimeSpan t1, int t2 ) { return new TimeSpan( t1.Ticks / t2 ); }

		public static TimeSpan operator *( TimeSpan t1, double t2 ) { return new TimeSpan( Math.RoundToInt64( t1.Ticks * t2 ) ); }
		public static TimeSpan operator /( TimeSpan t1, double t2 ) { return new TimeSpan( Math.RoundToInt64( t1.Ticks / t2 ) ); }

		public static thistype operator +( thistype t1, thistype t2 ) { thistype result; if( TryAddTicks( result.Ticks, t1.Ticks, t2.Ticks ) ) return result; return t1.Ticks >= 0 ? MaxValue : MinValue; }
		public static thistype operator -( thistype t1, thistype t2 ) { thistype result; if( TrySubtractTicks( result.Ticks, t1.Ticks, t2.Ticks ) ) return result; return t1.Ticks >= 0 ? MaxValue : MinValue; }

		public static bool operator ==( [In] TimeSpan& t1, [In] TimeSpan& t2 ) { return t1.Ticks == t2.Ticks; }
		public static bool operator !=( [In] TimeSpan& t1, [In] TimeSpan& t2 ) { return t1.Ticks != t2.Ticks; }

		public static bool operator >( [In] TimeSpan& t1, [In] TimeSpan& t2 ) { return t1.Ticks > t2.Ticks; }
		public static bool operator <( [In] TimeSpan& t1, [In] TimeSpan& t2 ) { return t1.Ticks < t2.Ticks; }

		public static bool operator >=( [In] TimeSpan& t1, [In] TimeSpan& t2 ) { return t1.Ticks >= t2.Ticks; }
		public static bool operator <=( [In] TimeSpan& t1, [In] TimeSpan& t2 ) { return t1.Ticks <= t2.Ticks; }

		public static bool operator ==( TimeSpan t1, TimeDuration t2 ) { return t1.Ticks == t2.Ticks; }
		public static bool operator ==( TimeDuration t1, TimeSpan t2 ) { return t1.Ticks == t2.Ticks; }
		public static bool operator !=( TimeSpan t1, TimeDuration t2 ) { return t1.Ticks != t2.Ticks; }
		public static bool operator !=( TimeDuration t1, TimeSpan t2 ) { return t1.Ticks != t2.Ticks; }

		public static bool operator >( TimeSpan t1, TimeDuration t2 ) { return t1.Ticks > t2.Ticks; }
		public static bool operator >( TimeDuration t1, TimeSpan t2 ) { return t1.Ticks > t2.Ticks; }
		public static bool operator <( TimeSpan t1, TimeDuration t2 ) { return t1.Ticks < t2.Ticks; }
		public static bool operator <( TimeDuration t1, TimeSpan t2 ) { return t1.Ticks < t2.Ticks; }

		public static bool operator >=( TimeSpan t1, TimeDuration t2 ) { return t1.Ticks >= t2.Ticks; }
		public static bool operator >=( TimeDuration t1, TimeSpan t2 ) { return t1.Ticks >= t2.Ticks; }
		public static bool operator <=( TimeSpan t1, TimeDuration t2 ) { return t1.Ticks <= t2.Ticks; }
		public static bool operator <=( TimeDuration t1, TimeSpan t2 ) { return t1.Ticks <= t2.Ticks; }

		public TimeSpan operator +() { return this; }

		public TimeSpan operator -() {
			if( Ticks == long.MinValue ) return MaxValue;
			return new TimeSpan( -Ticks );
		}

		public TimeDuration Duration() {
			if( Ticks == long.MinValue ) return TimeDuration.MaxValue;

			if( Ticks < 0 ) return new TimeDuration( ( ulong ) -Ticks );
			return new TimeDuration( ( ulong ) Ticks );
		}

		public int Days { get { return ( int )( Ticks / 864000000000 ); } }
		public int Hours { get { return ( int )( ( Ticks / 36000000000 ) % 24 ); } }
		public int Minutes { get { return ( int )( ( Ticks / 600000000 ) % 60 ); } }
		public int Seconds { get { return ( int )( ( Ticks / 10000000 ) % 60 ); } }
		public int Milliseconds { get { return ( int )( Ticks / 10000 % 1000 ); } }
		public int Microseconds { get { return ( int )( Ticks / 10 % 1000 ); } }
		// public int MicrosecondsWithMilliseconds { get { return ( int )( ( Ticks / 10 ) % 1000000UL ); } }

		public long TotalMilliseconds { get { return Ticks / ( 1000L * 10 ); } }
		public long TotalSeconds { get { return Ticks / ( 1000L * 1000 * 10 ); } }
		public long TotalMinutes { get { return Ticks / ( 60L * 1000 * 1000 * 10 ); } }
		public long TotalHours { get { return Ticks / ( 60L * 60 * 1000 * 1000 * 10 ); } }
		public long TotalDays { get { return Ticks / ( 24L * 60 * 60 * 1000 * 1000 * 10 ); } }

		public double TotalMillisecondsFractional { get { return Ticks / ( 1000.0 * 10 ); } }
		public double TotalSecondsFractional { get { return Ticks / ( 1000.0 * 1000 * 10 ); } }
		public double TotalMinutesFractional { get { return Ticks / ( 60.0 * 1000 * 1000 * 10 ); } }
		public double TotalHoursFractional { get { return Ticks / ( 60.0 * 60 * 1000 * 1000 * 10 ); } }
		public double TotalDaysFractional { get { return Ticks / ( 24.0 * 60 * 60 * 1000 * 1000 * 10 ); } }

		private static TimeSpan Interval( double value, int scale ) {
			if( !Assert.IsFalse( value.IsNaN ) )
				return new TimeSpan( 0 );

			var totalMilliseconds = Math.RoundHalfAwayFromZeroToInt64( value * scale );

			if( !Assert.IsFalse( totalMilliseconds > 922337203685477 || totalMilliseconds < -922337203685477 ) )
				return new TimeSpan( 0 );

			return new TimeSpan( 10L * 1000L * totalMilliseconds );
		}

		private static TimeSpan Interval( long value, int scale ) {
			long totalMilliseconds;
			if( !Assert.IsFalse( checkwrap( totalMilliseconds = value * scale ) ) )
				return new TimeSpan( 0 );

			if( !Assert.IsFalse( totalMilliseconds > 922337203685477 || totalMilliseconds < -922337203685477 ) )
				return new TimeSpan( 0 );

			return new TimeSpan( 10L * 1000L * totalMilliseconds );
		}

		public static TimeSpan FromMicroseconds( long value ) {
			if( !Assert.IsFalse( value > 922337203685477000 || value < -922337203685477000 ) )
				return new TimeSpan( 0 );

			return new TimeSpan( 10L * value );
		}

		public static TimeSpan FromTicks( long value ) {
			return new TimeSpan { Ticks = value };
		}

		public static TimeSpan FromDays( double value ) { return Interval( value, 0x5265C00 ); }
		public static TimeSpan FromHours( double value ) { return Interval( value, 3600000 ); }
		public static TimeSpan FromMinutes( double value ) { return Interval( value, 60000 ); }
		public static TimeSpan FromSeconds( double value ) { return Interval( value, 1000 ); }
		public static TimeSpan FromMilliseconds( double value ) { return Interval( value, 1 ); }

		public static TimeSpan FromDays( long value ) { return Interval( value, 0x5265C00 ); }
		public static TimeSpan FromHours( long value ) { return Interval( value, 3600000 ); }
		public static TimeSpan FromMinutes( long value ) { return Interval( value, 60000 ); }
		public static TimeSpan FromSeconds( long value ) { return Interval( value, 1000 ); }
		public static TimeSpan FromMilliseconds( long value ) { return Interval( value, 1 ); }

		public const long TicksPerDay = 10L * 1000 * 1000 * 60 * 60 * 24;
		public const long TicksPerHour = 10L * 1000 * 1000 * 60 * 60;
		public const long TicksPerMinute = 10L * 1000 * 1000 * 60;
		public const long TicksPerSecond = 10L * 1000 * 1000;
		public const long TicksPerMillisecond = 10L * 1000;
		public const long TicksPerMicrosecond = 10L;

		public const long Ticks_1601_1_1 = 504911232000000000;
		public const long Ticks_1970_1_1 = 621355968000000000;

		public static readonly TimeSpan Zero = new TimeSpan { Ticks = 0 };
		public static readonly TimeSpan MaxValue = new TimeSpan { Ticks = long.MaxValue };
		public static readonly TimeSpan MinValue = new TimeSpan { Ticks = long.MinValue };

		public uint GetHashCode() { return Ticks.GetHashCode(); }

		public const int MaxDays = ( int )( long.MaxValue / ( long ) TicksPerDay );

		public static thistype Parse( CString input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf8String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf16String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf32String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }

		public static thistype Parse( CStringSpan input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf8StringSpan input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf16StringSpan input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( CUtf32StringSpan input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }

		public static thistype Parse( SbcsString input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( Utf8String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( Utf16String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }
		public static thistype Parse( Utf32String input, System.Runtime.CompilerServices.CallerContext& callercontext = nullref ) { thistype result; var status = TryParse( input, result ); BclErrorHandler.ConvertException( status, callercontext ); return result; }

		public static Convert.ConversionResult TryParse( CString input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<byte>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( CUtf8String input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<byte>( input.GetChars(), input.ByteLength, value ); }
		public static Convert.ConversionResult TryParse( CUtf16String input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<char>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( CUtf32String input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<uint>( input.GetChars(), input.Length, value ); }

		public static Convert.ConversionResult TryParse( CStringSpan input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<byte>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( CUtf8StringSpan input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<byte>( input.GetChars(), input.ByteLength, value ); }
		public static Convert.ConversionResult TryParse( CUtf16StringSpan input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<char>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( CUtf32StringSpan input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<uint>( input.GetChars(), input.Length, value ); }

		public static Convert.ConversionResult TryParse( SbcsString input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<byte>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( Utf8String input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<byte>( input.GetChars(), input.ByteLength, value ); }
		public static Convert.ConversionResult TryParse( Utf16String input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<char>( input.GetChars(), input.Length, value ); }
		public static Convert.ConversionResult TryParse( Utf32String input, thistype& value ) { return PrimitiveTypesParser.TryParseTimeSpan<uint>( input.GetChars(), input.Length, value ); }
	}
}