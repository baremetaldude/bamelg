//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

using Platform.Libc;

namespace Platform.IO {
	// Event loop is a heart of event-driven application
	public partial class EventLoop : System.Threading.Dispatcher {
		protected bool _quitRequest;

		/// @{ Events
		public KQueueHandle KQueue = new KQueueHandle();

		private List<kevent> _signalledEvents = new List<kevent>();

		internal int _eventChangeVersion = 1;
		internal List<kevent> _eventChangeList = new List<kevent>();

		internal HashSet<uintptr> _eventIds = new HashSet<uintptr>();

		[Conditional( ConditionString = "DEBUG" )]
		private void EnsureEventUnique( kevent& @event, bool ensureNonBlocking ) {
			switch( @event.filter ) {
				case KEventFilter.EVFILT_READ:
				case KEventFilter.EVFILT_WRITE:
					if( !_eventIds.Add( @event.ident ) )
						Assert.Fail( string.Format( "Event with identifier '{0}' already present in change list", @event.ident ) );

					if( ensureNonBlocking && !bitcast<IOHandle>( ( uint ) @event.ident ).IsNonBlocking )
						Assert.Fail( string.Format( "Handle {0}: event loop designed to be used with non-blocking handles", @event.ident ) );

					break;
			}
		}

		public int AddEvent( kevent& @event, bool ensureNonBlocking = true ) {
			var index = _eventChangeList.Count;

			EnsureEventUnique( @event, ensureNonBlocking );
			_eventChangeList.Add( @event );

			return index;
		}

		public void ModifyEvent( int index, kevent& @event ) {
			_eventChangeList[index] = @event;
		}

		public void AddOrModifyEvent( int& index, int& eventListVersion, kevent& @event, bool ensureNonBlocking = true ) {
			if( eventListVersion == _eventChangeVersion ) {
				ModifyEvent( index, @event );
			}
			else {
				index = AddEvent( @event, ensureNonBlocking );
				eventListVersion = _eventChangeVersion;
			}
		}

		public void FlushEvents() {
			TraceChangeList( _eventChangeList );

			var polledDescriptors = LibcApi.kevent( KQueue, _eventChangeList.GetBuffer(), _eventChangeList.Count, null, 0, nullref );
			_eventChangeList.Clear();
			_eventIds.Clear();

			++_eventChangeVersion;
		}

		/// @}

		private bool _fiberDispatch = false;
		private NotificationEmitter _notificationEmitter = new NotificationEmitter( this );

		public EventLoop( bool enableFibers = true ) {
			_notificationEmitter.Register();

			if( enableFibers && !Fiber.Enabled ) {
				_fiberDispatch = true;
				Fiber.RuntimeInitialize();
				Fiber.FiberManager.Attach( this );
			}

			_dispatchThread = pthread_t.CurrentThread;

			FlushEvents();
		}

		public override void Dispose() {
			ExecuteTasks();

			KQueue.Close();

			foreach( var eventSink in _eventSinks ) eventSink.Dispose();
			_eventSinks.Clear();

			if( _fiberDispatch ) {
				Fiber.RuntimeShutdown();
				_fiberDispatch = false;
			}
		}

		internal HashSet<EventSink> _eventSinks = new HashSet<EventSink>();

		public int EventSinkCount { get { return _eventSinks.Count; } }

		/// @{ Dispatching
		private pthread_t _dispatchThread;

		public void Dispatch() {
			TraceDispatchStarted();

			if( _signalledEvents.Capacity < _eventSinks.Count )
				_signalledEvents.Capacity = ( int )( _eventSinks.Count * 1.3 );

			var waitBufferLength = _signalledEvents.Capacity;
			var waitBuffer = _signalledEvents.GetBuffer();

			for( ; ; ) {
				if( _quitRequest ) {
					if( Fiber.FiberManager != null && Fiber.FiberManager.FiberCount > 0 )
						Fiber.FiberManager.CancelAllFibers();
					else
						break;
				}

				TraceChangeList( _eventChangeList );

				int polledDescriptors;

				var timeout = GetWaitTime();
				if( timeout == TimeSpan.MaxValue )
					polledDescriptors = LibcApi.kevent( KQueue, _eventChangeList.GetBuffer(), _eventChangeList.Count, waitBuffer, waitBufferLength, nullref );
				else
					polledDescriptors = LibcApi.kevent( KQueue, _eventChangeList.GetBuffer(), _eventChangeList.Count, waitBuffer, waitBufferLength, new timespec( timeout ) );

				_eventChangeList.Clear();
				_eventIds.Clear();
				++_eventChangeVersion;

				if( polledDescriptors < 0 ) {
					switch( LibcApi.LastError ) {
						case SystemError.EINTR: continue;
						default: LibcApi.Assert( polledDescriptors ); continue;
					}
				}

				NotificationStartTime = DateTime.UnbiasedNow;
				NotificationStartTimeUtc = DateTime.UtcNow;
				TraceEventsArrived( polledDescriptors );

				OnUtcAlarm();
				OnUnbiasedAlarm();

				for( var i = 0; i < polledDescriptors; ++i ) {
					var& @event = waitBuffer[i];
					var& eventSink = *bitcast<EventSink*>( &@event.udata ); // dont touch refcount

					TraceEventSink( @event, eventSink );
					eventSink.EnsureEventSinkRegistered();

					eventSink.OnEvent( @event );
				}
			}

			TraceDispatchFinished();
			Dispose();
		}

		/// @}

		// It can be implemented as interface, but class provides faster access to fields
		public abstract class EventSink {
			public EventLoop Parent;

			public abstract void OnEvent( kevent& @event );

			public EventSink( EventLoop parent ) {
				// *( void** ) &Parent = bitcast<void*>( parent );
				Parent = parent;
			}

			public override void Dispose() {
				// *( void** ) &Parent = null;
				Parent = null;

				base.Dispose();
			}

			public sealed override uint GetHashCode() { return base.GetHashCode(); }

			/// @{
			public virtual bool Register() {
				if( Parent._eventSinks.Add( this ) ) {
					TraceEventSinkRegistered( this );

					return true;
				}
				else {
					Assert.Fail( string.Format( "EventSink '{0}' {1} already registered!", GetType(), bitcast<void*>( this ) ) );
					return false;
				}
			}


			public virtual bool Unregister() {
				var retainer = this;
				if( Parent._eventSinks.Remove( this ) ) {
					TraceEventSinkUnregistered( this );

					return true;
				}
				else {
					Assert.Fail( string.Format( "EventSink '{0}' {1} not registered!", GetType(), bitcast<void*>( this ) ) );
					return false;
				}
			}
			/// @}

			[Conditional( ConditionString = "DEBUG" )]
			internal void EnsureEventSinkRegistered() {
				if( !Parent._eventSinks.Contains( this ) )
					Assert.Fail( "EventSink not registered!" );
			}
		}

		public class SignalEventSink : EventSink {
			private sigset_t _signals;

			public SignalEventSink( EventLoop parent, sigset_t& signals )
				: base( parent ) {
				_signals = signals;
			}

			public sealed override void OnEvent( kevent& @event ) {
				OnRaised();
			}

			public virtual void OnRaised() {
				Parent.RequestExit();
			}

			public override bool Register() {
				if( !base.Register() ) return false;

				foreach( var signal in _signals )
					Parent.AddEvent( new kevent( signal, KEventAction.EV_ADD, bitcast<void*>( this ) ) );

				return true;
			}

			public override bool Unregister() {
				foreach( var signal in _signals )
					Parent.AddEvent( new kevent( signal, KEventAction.EV_DELETE, bitcast<void*>( this ) ) );

				return base.Unregister();
			}
		}

		public abstract class TimerEventSink : EventSink {
			private int _index;
			private int _version;

			public TimerEventSink( EventLoop parent )
				: base( parent ) {
			}

			public sealed override void OnEvent( kevent& @event ) {
				OnRaised( @event.data );
			}

			public abstract void OnRaised( long expirations );

			public void SetInterval( TimeSpan value ) {
				Parent.AddOrModifyEvent( _index, _version, new kevent( bitcast<uintptr>( this ), value, KEventAction.EV_ADD, bitcast<void*>( this ) ) );
			}

			public void Stop() {
				Parent.AddOrModifyEvent( _index, _version, new kevent( bitcast<uintptr>( this ), TimeSpan.Zero, KEventAction.EV_DELETE, bitcast<void*>( this ) ) );
			}
		}

		public void CatchExitSignals( sigset_t& signals ) {
			var eventSink = new SignalEventSink( this, signals );
			eventSink.Register();
		}

		public void CatchExitSignals() {
			LibcApi.signal( SignalCode.SIGPIPE, LibcApi.SIG_IGN );

			var signalSet = new sigset_t( SignalCode.SIGINT, SignalCode.SIGQUIT, SignalCode.SIGTERM, SignalCode.SIGHUP, SignalCode.SIGABRT );
			LibcApi.AssertErrno( LibcApi.sigprocmask( ApplySignalCommand.SIG_BLOCK, &signalSet, null ) );
			CatchExitSignals( signalSet );
		}

		// used for internal purposes
		private class NotificationEmitter : EventSink {
			private enum NotificationCommand : int {
				NewDispatcherTasks,
				Exit, // exit from event loop
			}

			private bool _exitRequestPending, _newDispatcherTasks;

			public NotificationEmitter( EventLoop parent )
				: base( parent ) {
			}

			public override void OnEvent( kevent& @event ) {
				switch( ( NotificationCommand ) @event.data ) {
					case NotificationCommand.NewDispatcherTasks:
						_newDispatcherTasks = false;
						Parent.ExecuteTasks();
						break;

					case NotificationCommand.Exit:
						Parent._quitRequest = true;
						break;
				}
			}

			private void SendCommand( NotificationCommand command ) {
				var @event = new kevent( 0, KEventFilter.EVFILT_USER, ( KEventAction ) 0, KEventUserFilterFlags.NOTE_TRIGGER, command, bitcast<void*>( this ) );
				Parent.KQueue.Modify( @event );
			}

			public void RequestExit() { if( !atomic( _exitRequestPending = true ) ) SendCommand( NotificationCommand.Exit ); } // dont overwhelm pipe
			public void NotifyNewDispatcherTasks() { if( !atomic( _newDispatcherTasks = true ) ) SendCommand( NotificationCommand.NewDispatcherTasks ); } // dont overwhelm pipe

			public override bool Register() {
				if( !base.Register() ) return false;

				Parent.AddEvent( new kevent( 0, KEventFilter.EVFILT_USER, KEventAction.EV_ADD | KEventAction.EV_CLEAR, 0, 0, bitcast<void*>( this ) ) );
				return true;
			}

			public override bool Unregister() {
				Parent.AddEvent( new kevent( 0, KEventFilter.EVFILT_USER, KEventAction.EV_DELETE, 0, 0, bitcast<void*>( this ) ) );

				return base.Unregister();
			}
		}

		public void RequestExit() { _notificationEmitter.RequestExit(); }
		protected override void NotifyNewDispatcherTasks() { _notificationEmitter.NotifyNewDispatcherTasks(); }

		public abstract class AcceptSocketEventSink : EventSink {
			protected SocketHandle _socket;

			public AcceptSocketEventSink( EventLoop parent, SocketHandle socket )
				: base( parent ) {
				_socket = socket;
			}

			~AcceptSocketEventSink() {
				_socket.Close();
			}

			public override bool Register() {
				if( !base.Register() ) return false;

				Parent.AddEvent( new kevent( _socket, KEventFilter.EVFILT_READ, KEventAction.EV_ADD, bitcast<void*>( this ) ) );

				return true;
			}

			public override bool Unregister() {
				Parent.AddEvent( new kevent( _socket, KEventFilter.EVFILT_READ, KEventAction.EV_DELETE, bitcast<void*>( this ) ) );

				return base.Unregister();
			}
		}

		public abstract class AcceptSocketTCP4EventSink : AcceptSocketEventSink {
			public AcceptSocketTCP4EventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( kevent& @event ) {
				sockaddr_in clientSocketInfo;
				SocketHandleTCP clientSocketHandle;

				while( ( clientSocketHandle = bitcast<SocketHandleTCP>( LibcApi.accept( _socket, &clientSocketInfo, sizeof( clientSocketInfo ) ) ) ).IsValid ) {
					clientSocketHandle.IsNonBlocking = true;
					OnAccepted( clientSocketHandle, clientSocketInfo );
				}
			}

			protected abstract void OnAccepted( SocketHandleTCP socket, sockaddr_in& socketInfo );
		}

		public abstract class AcceptSocketTCP6EventSink : AcceptSocketEventSink {
			public AcceptSocketTCP6EventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( kevent& @event ) {
				sockaddr_in6 clientSocketInfo;
				SocketHandleTCP clientSocketHandle;

				while( ( clientSocketHandle = bitcast<SocketHandleTCP>( LibcApi.accept( _socket, &clientSocketInfo, sizeof( clientSocketInfo ) ) ) ).IsValid ) {
					clientSocketHandle.IsNonBlocking = true;
					OnAccepted( clientSocketHandle, clientSocketInfo );
				}
			}

			protected abstract void OnAccepted( SocketHandleTCP socket, sockaddr_in6& socketInfo );
		}

		public abstract class AcceptSocketUnixEventSink : AcceptSocketEventSink {
			public AcceptSocketUnixEventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( kevent& @event ) {
				sockaddr_un clientSocketInfo;
				SocketHandleLocal clientSocketHandle;

				while( ( clientSocketHandle = bitcast<SocketHandleLocal>( LibcApi.accept( _socket, &clientSocketInfo, sizeof( clientSocketInfo ) ) ) ).IsValid ) {
					clientSocketHandle.IsNonBlocking = true;
					OnAccepted( clientSocketHandle, clientSocketInfo );
				}
			}

			protected abstract void OnAccepted( SocketHandleLocal socket, sockaddr_un& socketInfo );
		}

		public abstract class AcceptSocketAnyEventSink : AcceptSocketEventSink {
			public AcceptSocketAnyEventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( kevent& @event ) {
				SocketHandle clientSocketHandle;

				while( ( clientSocketHandle = LibcApi.accept( _socket, null, 0 ) ).IsValid ) {
					clientSocketHandle.IsNonBlocking = true;
					OnAccepted( clientSocketHandle );
				}
			}

			protected abstract void OnAccepted( SocketHandle socket );
		}

		#region Dispatcher

		protected override void SetAlarm( AlarmKind kind, TimeSpan time ) { }
		protected override void StopAlarm( AlarmKind kind ) { }
		protected override bool IsDispatchingThread { get { return _dispatchThread.IsCurrent; } }

		#endregion

		/// @{ Tracing
		private const string TraceConditionString = "TRACE_EVENT_LOOP";

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceDispatchStarted() {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, "EventLoop dispatch started: {0}", DateTime.UtcNow );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceDispatchFinished() {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, "EventLoop dispatch finished: {0}", DateTime.UtcNow );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private void TraceEventsArrived( int polledDescriptors ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, "EventLoop: kevent() count={0} at {1}", polledDescriptors, NotificationStartTime );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceEventSink( kevent& @event, EventSink eventSink ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, " notify '{0}'({1}) with event='{2}'", eventSink != null ? eventSink.GetType() : typeof( void ), bitcast<void*>( eventSink ), @event );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceChangeList( List<kevent> _eventChangeList ) {
			if( _eventChangeList.Count > 0 ) {
				Trace.Write( new Console.OutputAttributes() {
					BackgroundColor = RgbColor.Blue
				}, "Apply kevent modifications: Count={0}", _eventChangeList.Count );

				foreach( var ev in _eventChangeList )
					Trace.Write( new Console.OutputAttributes() { Thin = true }, " {0}", ev );
			}
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceEventSinkRegistered( EventSink eventSink ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, "EventSink '{0}'({1}) registered", eventSink.GetType(), bitcast<void*>( eventSink ) );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceEventSinkUnregistered( EventSink eventSink ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, "EventSink '{0}'({1}) unregistered", eventSink.GetType(), bitcast<void*>( eventSink ) );
		}
		/// @}
	}
}