//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//
// Notification functionality
//

using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Threading;

using Platform.IO;
using Platform.Libc;

namespace System.IO {
	public partial struct Fiber {
		internal partial struct FiberInfo {
			private IOHandle _waitHandle;
			private KEventFilter _waitFilter;
			private KEventAction _waitFlags;
			private SystemError _waitErrno;

			private Dispatcher.AlarmUnbiased* _alarmID;

			internal partial class Manager {
				private System.Threading.Mutex _readyListAsyncLock = new System.Threading.Mutex();
				private List<FiberInfo*> _readyListAsync = new List<FiberInfo*>();

				public KQueueHandle KQueue = new KQueueHandle();
				public KQueueHandle NotifyQueue = KQueueHandle.Invalid;

				private List<kevent> _signalledEvents = new List<kevent>( 32 );
				private List<kevent> _pendingEvents = new List<kevent>( 32 );

				public EventLoop CurrentEventLoop;

				private void OnBeforeDispatch() {
					_fiberReadyEventSink.OnDispatch();
				}

				private void OnAfterDispatch() {
					LibcApi.kevent( KQueue, _pendingEvents.GetBuffer(), _pendingEvents.Count, null, 0, nullref );
					_pendingEvents.Clear();
				}

				public void OnEvent() {
					if( _signalledEvents.Capacity < _fibers.Count )
						_signalledEvents.Capacity = ( int )( _fibers.Count * 1.3 );

					var waitBufferLength = _signalledEvents.Capacity;
					var waitBuffer = _signalledEvents.GetBuffer();

					while( true ) {
						var polledHandles = LibcApi.kevent( KQueue, null, 0, &waitBuffer[0], waitBufferLength, nullref );
						if( polledHandles == 0 ) return;

						TraceIOEvents( polledHandles );
						if( polledHandles < 0 ) {
							switch( LibcApi.LastError ) {
								case SystemError.EINTR: continue;
								default: LibcApi.AssertErrno( polledHandles ); continue;
							}
						}

						for( var i = 0; i < polledHandles; ++i ) {
							var& currentEvent = waitBuffer[i];
							var fiber = ( FiberInfo* ) currentEvent.udata;

							TraceIONotify( fiber, currentEvent );

							fiber->_waitFilter = ( KEventFilter ) currentEvent.filter;
							fiber->_waitFlags = ( KEventAction ) currentEvent.flags;

							if( ( currentEvent.flags & KEventAction.EV_ERROR ) != 0 ) fiber->_waitErrno = ( SystemError ) currentEvent.data;
							else if( ( currentEvent.flags & KEventAction.EV_EOF ) != 0 ) fiber->_waitErrno = SystemError.ECONNRESET;
							else fiber->_waitErrno = SystemError.None;

							ReadyIO( fiber );
						}

						Dispatch();
						break; // we need to dispatch from outer loop
					}
				}

				private Dispatcher.AlarmUnbiased* BeginTimeout( TimeSpan interval, Functors.Action<void*> action, void* data ) {
					return CurrentEventLoop.ScheduleUnbiased( interval, action, data );
				}

				private void EndTimeout( Dispatcher.AlarmUnbiased* alarmId ) {
					CurrentEventLoop.RemoveAlarm( alarmId );
				}

				private void ReadyIO( FiberInfo* fiber ) {
					if( fiber->_isReady | !fiber->_isAlive ) return;

					TraceReady( fiber );

					_readyList.Add( fiber );
					fiber->_isReady = true;
				}

				// MT-unsafe
				public void Ready( FiberInfo* fiber ) {
					if( fiber->_isReady | !fiber->_isAlive ) return;

					TraceReady( fiber );

					_fiberReadyEventSink.Notify();

					_readyList.Add( fiber );
					fiber->_isReady = true;
				}

				// MT-safe
				public void ReadyAsync( FiberInfo* fiber ) {
					TraceReadyAsync( fiber );

					using( _readyListAsyncLock.LockRegion() )
						_readyListAsync.Add( fiber );

					_fiberReadyEventSink.NotifyAsync();
				}

				private SystemError Wait( TimeSpan timeout, IOHandle handle, KEventFilter eventFilter ) {
					CurrentFiber->_waitHandle = handle;
					_pendingEvents.Add( new kevent( handle, eventFilter, KEventAction.EV_ADD | KEventAction.EV_ONESHOT, CurrentFiber ) );

					BeginTimeout( timeout );

					Suspend();
					CurrentFiber->_waitHandle = IOHandle.Invalid;

					if( EndTimeout( timeout ) ) {
						_pendingEvents.Add( new kevent( handle, eventFilter, KEventAction.EV_DELETE, CurrentFiber ) );
						return SystemError.ETIMEDOUT;
					}

					if( CurrentFiber->IsCancelled ) return SystemError.EINTR;
					return CurrentFiber->_waitErrno;
				}

				public SystemError WaitForConnect( TimeSpan timeout, SocketHandle handle ) {
					TraceWait( CurrentFiber, thismethod, timeout );

					return Wait( timeout, handle, KEventFilter.EVFILT_WRITE );
				}

				public SystemError WaitForConnectWithData( TimeSpan timeout, SocketHandle handle ) {
					TraceWait( CurrentFiber, thismethod, timeout );

					return Wait( timeout, handle, KEventFilter.EVFILT_READ );
				}

				// \return
				//  'SystemError.None' if IO-event successfully arrived
				//  'SystemError.ETIMEDOUT' if wait timed out
				//  'SystemError.ECONNRESET' on bad epoll notification
				public SystemError WaitForRead( TimeSpan timeout, IOHandle handle ) {
					TraceWait( CurrentFiber, thismethod, timeout );

					return Wait( timeout, handle, KEventFilter.EVFILT_READ );
				}

				public SystemError WaitForWrite( TimeSpan timeout, IOHandle handle ) {
					TraceWait( CurrentFiber, thismethod, timeout );

					return Wait( timeout, handle, KEventFilter.EVFILT_WRITE );
				}

				/// @{ IO completion. Designed to work with non-blocking handles. Blocks fiber until completion or timeout

				public SystemError ConnectNonBlocking( TimeSpan timeout, SocketHandle socket, sockaddr* address, int addressLength ) {
					socket.EnsureNonBlocking();

				restart:
					var result = LibcApi.connect( socket, address, addressLength );
					if( result == 0 ) return SystemError.None;

					var errno = LibcApi.LastError;
					TraceSocketConnect( socket, errno );

					switch( errno ) {
						case SystemError.EAGAIN:
						case SystemError.EINPROGRESS:
							return WaitForConnect( timeout, socket );
					}

					return errno;
				}

				public SystemError WriteNonBlocking( TimeSpan timeout, IOHandle socket, void* buffer, int count ) {
					socket.EnsureNonBlocking();

					intptr totalWritten = 0;

				restart:
					var written = LibcApi.write( socket, buffer, count );

					if( written < 0 ) {
						var errno = LibcApi.LastError;
						TraceNonBlockingWrite( socket, errno, written, count, totalWritten );

						switch( errno ) {
							case SystemError.EINTR: goto restart;

							case SystemError.EAGAIN:
							case SystemError.EINPROGRESS:
								var waitResult = WaitForWrite( timeout, socket );
								if( waitResult != SystemError.None ) return waitResult;

								goto restart;

							default:
								return errno;
						}
					}
					else {
						TraceNonBlockingWrite( socket, SystemError.None, written, count, totalWritten );

						totalWritten += written;
						count -= ( int ) written;
						if( count > 0 && written > 0 ) goto restart; // ensure all bytes are send

						return SystemError.None;
					}
				}

				public SystemError WriteNonBlocking( TimeSpan timeout, IOHandle socket, iovec* segments, int segmentsCount ) {
					socket.EnsureNonBlocking();

					intptr totalWritten = 0;

				restart:
					var written = LibcApi.writev( socket, segments, segmentsCount );
					if( written < 0 ) {
						var errno = LibcApi.LastError;

						switch( errno ) {
							case SystemError.EINTR: goto restart;

							case SystemError.EAGAIN:
							case SystemError.EINPROGRESS:
								var waitResult = WaitForWrite( timeout, socket );
								if( waitResult != SystemError.None ) return waitResult;

								goto restart;

							default:
								return errno;
						}
					}
					else {
						totalWritten += written;
						if( written > 0 ) {
							while( segmentsCount > 0 ) {
								if( segments[0].iov_len > ( uint ) written ) {
									segments[0].iov_len -= written;
									break;
								}

								written -= ( int ) segments[0].iov_len;
								++segments;
								--segmentsCount;
							}

							if( segmentsCount > 0 ) goto restart; // ensure all bytes are send
						}

						return SystemError.None;
					}
				}

				public SystemError ReadNonBlocking( TimeSpan timeout, IOHandle socket, void* buffer, int count, int& totalReceived ) {
					socket.EnsureNonBlocking();

				restart:
					var readen = LibcApi.read( socket, buffer, count );

					if( readen < 0 ) {
						var errno = LibcApi.LastError;
						TraceNonBlockingRead( socket, errno, readen, count, totalReceived );

						switch( errno ) {
							case SystemError.EINTR:
								goto restart;

							case SystemError.EAGAIN:
							case SystemError.EINPROGRESS: {
									if( readen == -1 ) {
										var waitResult = WaitForRead( timeout, socket );
										if( waitResult != SystemError.None ) return waitResult;

										goto restart;
									}

									totalReceived += ( int ) readen;
									return SystemError.None;
								}

							default:
								return errno;
						}
					}
					else {
						TraceNonBlockingRead( socket, SystemError.None, readen, count, totalReceived );

						totalReceived += ( int ) readen;
						return SystemError.None;
					}
				}

				/// @}

				/// @{ EventLoop support

				private FiberReadyEventSink _fiberReadyEventSink;
				private FiberIOEventSink _fiberIOEventSink;

				public void Attach( EventLoop eventLoop ) {
					if( !Assert.IsTrue( _fiberReadyEventSink == null ) ) return;
					CurrentEventLoop = eventLoop;
					NotifyQueue = eventLoop.KQueue;

					_fiberReadyEventSink = new FiberReadyEventSink( this );
					_fiberReadyEventSink.Register();

					_fiberIOEventSink = new FiberIOEventSink( this );
					_fiberIOEventSink.Register();
				}

				public void Detach( EventLoop eventLoop ) {
					if( !Assert.IsTrue( _fiberReadyEventSink != null ) ) return;
					NotifyQueue = KQueueHandle.Invalid;

					_fiberReadyEventSink.Unregister();
					_fiberIOEventSink.Unregister();
				}

				private sealed class FiberIOEventSink : EventLoop.EventSink {
					private declaringtype _manager;

					public FiberIOEventSink( declaringtype manager )
						: base( manager.CurrentEventLoop ) {
						_manager = manager;
					}

					public override void Dispose() {
						_manager = null;

						base.Dispose();
					}

					public override void OnEvent( kevent& @event ) {
						_manager.OnEvent();
					}

					public override bool Register() {
						if( !base.Register() ) return false;

						_manager.CurrentEventLoop.AddEvent( new kevent( _manager.KQueue, KEventFilter.EVFILT_READ, KEventAction.EV_ADD, bitcast<void*>( this ) ), false );

						return true;
					}

					public override bool Unregister() {
						_manager.CurrentEventLoop.AddEvent( new kevent( _manager.KQueue, KEventFilter.EVFILT_READ, KEventAction.EV_DELETE, bitcast<void*>( this ) ), false );

						return base.Unregister();
					}
				}

				private sealed class FiberReadyEventSink : EventLoop.EventSink {
					private declaringtype _manager;
					private bool _isFiberReady = false;
					private bool _isFiberReadyAsync;
					private uint _id;

					public FiberReadyEventSink( declaringtype manager )
						: base( manager.CurrentEventLoop ) {
						_manager = manager;

						atomic( _isFiberReadyAsync = false );
					}

					public override void Dispose() {
						_manager = null;

						base.Dispose();
					}

					public override void OnEvent( kevent& @event ) {
						_manager.Dispatch();
					}

					public void OnDispatch() {
						_isFiberReady = false;
						atomic( _isFiberReadyAsync = false );
					}

					public void Notify() {
						if( _isFiberReady ) return;
						_isFiberReady = true;

						var @event = new kevent( _id, KEventFilter.EVFILT_USER, ( KEventAction ) 0, KEventUserFilterFlags.NOTE_TRIGGER, 0, bitcast<void*>( this ) );
						_manager.CurrentEventLoop.AddEvent( @event );
					}

					public void NotifyAsync() {
						if( !atomic( _isFiberReadyAsync = true ) ) {
							var @event = new kevent( _id, KEventFilter.EVFILT_USER, ( KEventAction ) 0, KEventUserFilterFlags.NOTE_TRIGGER, 0, bitcast<void*>( this ) );
							_manager.CurrentEventLoop.KQueue.Modify( @event );
						}
					}

					public override bool Register() {
						if( !base.Register() ) return false;

						_id = Parent.UserFilterId++;
						_manager.CurrentEventLoop.AddEvent( new kevent( _id, KEventFilter.EVFILT_USER, KEventAction.EV_ADD | KEventAction.EV_CLEAR, 0, 0, bitcast<void*>( this ) ) );
						return true;
					}

					public override bool Unregister() {
						_manager.CurrentEventLoop.AddEvent( new kevent( _id, KEventFilter.EVFILT_USER, KEventAction.EV_DELETE, 0, 0, bitcast<void*>( this ) ) );

						return base.Unregister();
					}
				}

				/// @}

				/// @{ Tracing

				[Conditional( ConditionString = TraceConditionString )]
				private static void TraceIONotify( FiberInfo* fiber, kevent& @event ) {
					Trace.Write( "Fiber: Event for fiber [{0}]: {1}", *fiber, @event );
				}

				[Conditional( ConditionString = TraceConditionString )]
				private void TraceSocketConnect( SocketHandle socket, SystemError errno ) {
					Trace.Write( "Fiber: [{0:D2}] Socket {1} connect: errno={2}", *CurrentFiber, socket.ID, errno );
				}

				[Conditional( ConditionString = TraceConditionString )]
				private void TraceNonBlockingWrite( IOHandle socket, SystemError errno, intptr written, int count, intptr bytesSended ) {
					Trace.Write( "Fiber: [{0:D2}] Handle {1} write: errno={2} written={3} count={4} total={5}", *CurrentFiber, socket.ID, errno, written, count, bytesSended );
				}

				[Conditional( ConditionString = TraceConditionString )]
				private void TraceNonBlockingRead( IOHandle socket, SystemError errno, intptr readen, int count, int bytesReceived ) {
					Trace.Write( "Fiber: [{0:D2}] Handle {1} read: errno={2} readen={3} count={4} avail={5} total={6}", *CurrentFiber, socket.ID, errno, readen, count, socket.AvailableBytes, bytesReceived );
				}

				/// @}
			}
		}
	}
}