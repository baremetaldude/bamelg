//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.IO;
using System.Net;

using Platform.IO;

namespace Platform.Libc {
	// http://www.freebsd.org/cgi/man.cgi?query=tcp&sektion=4&apropos=0&manpath=FreeBSD+8.2-RELEASE
	public struct SocketHandleTCP : SocketHandle, IFormattable {
		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		// nonblocking for fibers
		public SocketHandleTCP( ProtocolFamily protocolFamily = ProtocolFamily.PF_INET )
			: this( protocolFamily, Fiber.IsFiberExecuting ) {
		}

		public SocketHandleTCP( ProtocolFamily protocolFamily, bool nonBlocking ) {
			LibcApi.Assert( this = bitcast<SocketHandleTCP>( LibcApi.socket( protocolFamily, SocketType.SOCK_STREAM, IPProtocol.IPPROTO_TCP ) ) );
			if( nonBlocking ) IsNonBlocking = true;
		}

		public SystemError Connect( IPv4Endpoint& endpoint ) {
			var nativeEndpoint = ( sockaddr_in ) endpoint;
			return ConnectNonBlocking( TimeSpan.Zero, ( sockaddr* ) &nativeEndpoint, sizeof( nativeEndpoint ) );
		}

		public SystemError Connect( IPv6Endpoint& endpoint ) {
			var nativeEndpoint = ( sockaddr_in6 ) endpoint;
			return ConnectNonBlocking( TimeSpan.Zero, ( sockaddr* ) &nativeEndpoint, sizeof( nativeEndpoint ) );
		}

		public bool BindIPv4( ushort port ) { return Bind( new IPv4Endpoint( IPv4Address.AllInterfaces, port ) ); }
		public bool Bind( IPv4Endpoint& endpoint ) {
			var nativeEndpoint = ( sockaddr_in ) endpoint;
			return LibcApi.bind( this, ( sockaddr* ) &nativeEndpoint, sizeof( nativeEndpoint ) ) == 0;
		}

		public bool BindIPv6( ushort port ) { return Bind( new IPv6Endpoint( IPv6Address.AllInterfaces, port ) ); }
		public bool Bind( IPv6Endpoint& endpoint ) {
			var nativeEndpoint = ( sockaddr_in6 ) endpoint;
			return LibcApi.bind( this, ( sockaddr* ) &nativeEndpoint, sizeof( nativeEndpoint ) ) == 0;
		}

		public static bool IsIPv4PortFree( ushort port ) { return IsIPv4PortFree( new IPv4Endpoint( IPv4Address.AllInterfaces, port ) ); }
		public static bool IsIPv4PortFree( IPv4Endpoint& endpoint ) {
			using( var handle = new SocketHandleTCP( ProtocolFamily.PF_INET ) ) {
				handle.ReuseAddress = true;

				return handle.Bind( endpoint );
			}
		}

		public static bool IsIPv6PortFree( ushort port ) { return IsIPv6PortFree( new IPv6Endpoint( IPv6Address.AllInterfaces, port ) ); }
		public static bool IsIPv6PortFree( IPv6Endpoint& endpoint ) {
			using( var handle = new SocketHandleTCP( ProtocolFamily.PF_INET6 ) ) {
				handle.ReuseAddress = true;

				return handle.Bind( endpoint );
			}
		}

		// If true - send first packet immediately and fill buffer until acknowledgment is received
		public bool ImmediateDelivery {
			get {
				Boolean32 result = false; // for some reason I got VG warning here
				LibcApi.Assert( LibcApi.getsockopt( this, ( SocketPropertyGroup ) IPProtocol.IPPROTO_TCP, SocketPropertyTcp.TCP_NODELAY, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Boolean32 result = value;
				LibcApi.Assert( LibcApi.setsockopt( this, ( SocketPropertyGroup ) IPProtocol.IPPROTO_TCP, SocketPropertyTcp.TCP_NODELAY, &result, sizeof( result ) ) );
			}
		}

		// http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html
		public bool KeepAliveEnabled {
			get {
				Boolean32 result = false;
				LibcApi.Assert( LibcApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_KEEPALIVE, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Boolean32 result = value;
				LibcApi.Assert( LibcApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_KEEPALIVE, &result, sizeof( result ) ) );
			}
		}

		// public int KeepAliveProbesMax {
		// 	get {
		// 		int result;
		// 		LibcApi.Assert( LibcApi.getsockopt( this, ( SocketPropertyGroup ) IPProtocol.IPPROTO_TCP, SocketPropertyTcp.TCP_KEEPCNT, &result, sizeof( result ) ) );
		// 		return result;
		// 	}
		// 	set {
		// 		LibcApi.Assert( LibcApi.setsockopt( this, ( SocketPropertyGroup ) IPProtocol.IPPROTO_TCP, SocketPropertyTcp.TCP_KEEPCNT, &value, sizeof( value ) ) );
		// 	}
		// }

		// public int KeepAliveIdleSeconds {
		// 	get {
		// 		int result;
		// 		LibcApi.Assert( LibcApi.getsockopt( this, ( SocketPropertyGroup ) IPProtocol.IPPROTO_TCP, SocketPropertyTcp.TCP_KEEPIDLE, &result, sizeof( result ) ) );
		// 		return result;
		// 	}
		// 	set {
		// 		LibcApi.Assert( LibcApi.setsockopt( this, ( SocketPropertyGroup ) IPProtocol.IPPROTO_TCP, SocketPropertyTcp.TCP_KEEPIDLE, &value, sizeof( value ) ) );
		// 	}
		// }

		// public int KeepAliveProbingIntervalSeconds {
		// 	get {
		// 		int result;
		// 		LibcApi.Assert( LibcApi.getsockopt( this, ( SocketPropertyGroup ) IPProtocol.IPPROTO_TCP, SocketPropertyTcp.TCP_KEEPINTVL, &result, sizeof( result ) ) );
		// 		return result;
		// 	}
		// 	set {
		// 		LibcApi.Assert( LibcApi.setsockopt( this, ( SocketPropertyGroup ) IPProtocol.IPPROTO_TCP, SocketPropertyTcp.TCP_KEEPINTVL, &value, sizeof( value ) ) );
		// 	}
		// }

		// http://en.wikipedia.org/wiki/Maximum_segment_size
		public int MaximumSegmentSize {
			get {
				int result = 0;
				LibcApi.AssertErrno( LibcApi.getsockopt( this, ( SocketPropertyGroup ) IPProtocol.IPPROTO_TCP, SocketPropertyTcp.TCP_MAXSEG, &result, sizeof( result ) ) );
				return result;
			}
			set {
				LibcApi.AssertErrno( LibcApi.setsockopt( this, ( SocketPropertyGroup ) IPProtocol.IPPROTO_TCP, SocketPropertyTcp.TCP_MAXSEG, &value, sizeof( value ) ) );
			}
		}

		protected new void DumpRelevantData( StringBuilder builder ) {
			var keepAlive = KeepAliveEnabled;

			base.DumpRelevantData( builder );

			builder.AppendFormat( " NoDelay={0} MSS={1} KeepAlive={2}", ImmediateDelivery, MaximumSegmentSize, keepAlive );
			// if( keepAlive )
			//	builder.AppendFormat( " KeepAliveProbesMax={0} KeepAliveProbingIntervalSeconds={1} KeepAliveIdleSeconds={2}", KeepAliveProbesMax, KeepAliveProbingIntervalSeconds, KeepAliveIdleSeconds );
		}

		public new void ToString( StringBuilder builder, string format ) {
			builder.Append( "{" );
			DumpRelevantData( builder );
			builder.Append( " }" );
		}
	}
}