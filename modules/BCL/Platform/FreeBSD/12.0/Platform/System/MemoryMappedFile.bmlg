//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;

namespace Platform.Libc {
	public struct MemoryMappedFile {
		public void* Start;
		public uintptr FileLength;
		public uint MappingLength;
		public IOHandle FileHandle;

		public bool CloseFile { get; set; }

		public MemoryMappedFile() {
		}

		public SystemError Map( FileHandle handle, bool ownHandle, MemoryMapProtection pageProtection = MemoryMapProtection.PROT_READ ) {
			Dispose();
			if( !handle.IsValid ) return SystemError.EINVAL;

			FileHandle = handle;
			CloseFile = ownHandle;

			stat fileStat;
			if( LibcApi.fstat( FileHandle, &fileStat ) < 0 )
				return LibcApi.LastError;

			var pagesize = System.Runtime.Memory.DefaultPageSize;

			FileLength = ( uintptr ) fileStat.st_size;
			MappingLength = ( uint ) fileStat.st_size;
			MappingLength += pagesize - 1; MappingLength &= ~( pagesize - 1 );

			var mmapResult = LibcApi.mmap( null, MappingLength, pageProtection, MemoryMapFlags.MAP_PRIVATE, FileHandle, 0 ); // | MemoryMapFlags.MAP_NONBLOCK | MemoryMapFlags.MAP_POPULATE,
			if( ( intptr ) mmapResult < 0 )
				return LibcApi.LastError;

			Start = ( void* ) mmapResult;

			// result.Start = ( void* ) LibcApi.mmap( null, result.MappingLength, MemoryMapProtection.PROT_READ, MemoryMapFlags.MAP_PRIVATE | MemoryMapFlags.MAP_POPULATE | MemoryMapFlags.MAP_NONBLOCK, result.FileHandle, 0 ); // | MemoryMapFlags.MAP_NONBLOCK | MemoryMapFlags.MAP_POPULATE,
			// LibcApi.madvise( result.Start, result.MappingLength, MemoryAdvise.MADV_SEQUENTIAL | MemoryAdvise.MADV_DONTNEED | MemoryAdvise.MADV_HUGEPAGE );

			return SystemError.None;
		}

		public SystemError Map( CUtf8String path, FctlValue fctlValue = FctlValue.O_RDONLY, MemoryMapProtection pageProtection = MemoryMapProtection.PROT_READ ) {
			return Map( new FileHandle( path, fctlValue ), true, pageProtection );
		}

		public SystemError Map( IOHandle parent, CUtf8String path, FctlValue fctlValue = FctlValue.O_RDONLY, MemoryMapProtection pageProtection = MemoryMapProtection.PROT_READ ) {
			return Map( new FileHandle( parent, path, fctlValue ), true, pageProtection );
		}

		public void Dispose() {
			if( !FileHandle.IsValid ) return;

			LibcApi.AssertErrno( LibcApi.munmap( Start, MappingLength ) );
			Start = null;
			FileLength = 0;
			MappingLength = 0;

			FileHandle.Close();
		}
	}
}