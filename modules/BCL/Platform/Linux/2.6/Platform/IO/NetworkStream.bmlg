//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.IO;

using Platform.Kernel;
using Platform.Libc;

namespace Platform.IO {
	// Must be used with non-blocking sockets inside Fibers or with blocking sockets(in ST/MT environment)
	public class NetworkStream : IStream {
		public static IPlatformErrorHandler DefaultErrorHandler = PlatformErrorHandlerNull.Instance;
		public IPlatformErrorHandler ErrorHandler = DefaultErrorHandler;

		public StreamCapabilities Capabilities { get { return StreamCapabilities.Read | StreamCapabilities.Write | StreamCapabilities.VectoredIO | StreamCapabilities.Timeout; } }
		public StreamingBufferInfo* BufferInfo { get { return null; } }

		private IOHandleNonBlocking _handle = IOHandleNonBlocking.Invalid;
		public IOHandleNonBlocking Handle {
			get { return _handle; }
			set {
				if( _handle == value ) return;

				Close();
				_handle = value;

				Boolean32 cork = true;
				if( LibcApi.setsockopt( _handle, SocketPropertyGroup.SOL_TCP, SocketPropertyTcp.TCP_CORK, &cork, sizeof( cork ) ) >= 0 )
					KernelBufferingTCP = _cork = true;
			}
		}

		public bool CloseHandle { get; set; } = true;

		public bool KernelBufferingTCP { get; set; }
		private bool _cork { get; set; }

		public string Context;

		public NetworkStream() {
		}

		public NetworkStream( IOHandleNonBlocking handle )
			: this() {
			Handle = handle;
		}

		~NetworkStream() { Close(); }
		public override void Dispose() { Close(); base.Dispose(); }

		private void Close() {
			if( CloseHandle ) _handle.Close();
			else _handle = IOHandleNonBlocking.Invalid;
		}

		private PlatformErrorAction OnLastError( SystemError errorCode ) { return ErrorHandler.OnError( Context, errorCode ); }

		public int Read( void* buffer, int count ) {
			if( !_handle.IsValid || count == 0 || buffer == null ) return 0;

			var data = ( byte* ) buffer;

			var transmitted = 0;
		restart_Receive:
			var error = _handle.Read( _timeout, data, count, transmitted );
			if( error != SystemError.None ) {
				if( OnLastError( error ) == PlatformErrorAction.Restart ) goto restart_Receive;
				return transmitted;
			}

			return transmitted;
		}

		public void Write( void* buffer, int count ) {
			if( !_handle.IsValid || count == 0 || buffer == null ) return;

			if( KernelBufferingTCP & !_cork ) {
				bitcast<SocketHandleTCP>( _handle ).Cork = _cork = true;
			}

		restart_Send:
			var error = _handle.Write( _timeout, buffer, count );
			if( error != SystemError.None ) {
				if( OnLastError( error ) == PlatformErrorAction.Restart ) goto restart_Send;
				return;
			}
		}

		public int Read( vararg MemorySegment segments ) {
			Assert.IsTrue( AdaptationLayer.IsMemorySegmentLayoutEqualsToIovec );
			int totalReaden;

		restart_Receive:
			var error = _handle.Read( _timeout, totalReaden, vararg( ( iovec* ) segments, segments.Length ) );
			if( error != SystemError.None ) {
				if( OnLastError( error ) == PlatformErrorAction.Restart ) goto restart_Receive;
				return totalReaden;
			}

			return totalReaden;
		}

		public void Write( vararg MemorySegment segments ) {
			Assert.IsTrue( AdaptationLayer.IsMemorySegmentLayoutEqualsToIovec );

			if( KernelBufferingTCP & !_cork ) {
				bitcast<SocketHandleTCP>( _handle ).Cork = _cork = true;
			}

		restart_Send:
			var error = _handle.Write( _timeout, vararg( ( iovec* ) segments, segments.Length ) );
			if( error != SystemError.None ) {
				if( OnLastError( error ) == PlatformErrorAction.Restart ) goto restart_Send;
				return;
			}
		}

		public void Flush( FlushKind flushKind = FlushKind.SynchronizeWrite ) {
			switch( flushKind ) {
				case FlushKind.Write:
				case FlushKind.SynchronizeWrite:
					if( KernelBufferingTCP & _cork ) {
						bitcast<SocketHandleTCP>( _handle ).Cork = _cork = false;
					}

					break;
			}
		}

		private TimeSpan _timeout = TimeSpan.Zero;

		public TimeSpan Timeout {
			get { return _timeout; }
			set { _timeout = value; }
		}

		long IStream.Position { get { return 0; } }
		long IStream.Seek( long offset, SeekOrigin origin ) { return 0; }
	}
}