//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime;

using Platform.Kernel;
using Platform.Libc;

namespace Platform.IO {
	// Event loop is a heart of event-driven application
	public partial class EventLoop : System.Threading.Dispatcher {
		protected bool _quitRequest;
		protected bool _fiberDispatch;

		public EpollHandle Epoll = new EpollHandle();
		private epoll_event[128] _signalledEvents;

		private NotificationEmitter _notificationEmitter = new NotificationEmitter( this );

		internal void* EventLoopData; // Used for integration with other event loops implementations
		public int PollId;            // used for syncronization

		public EventLoop( bool enableFibers = true ) {
			_notificationEmitter.Register();

			if( enableFibers && !Fiber.Enabled ) {
				_fiberDispatch = true;
				Fiber.RuntimeInitialize();
				Fiber.FiberManager.Attach( this );
			}

			_dispatchThread = pthread_t.CurrentThread;
			InitDispatcher();
		}

		public override void Dispose() {
			CloseDispatcher();

			Epoll.Close();
			foreach( var eventSink in _eventSinks ) eventSink.Dispose();

			if( _fiberDispatch ) {
				Fiber.RuntimeShutdown();
				_fiberDispatch = false;
			}

			base.Dispose();
		}

		private HashSet<EventSink> _eventSinks = new HashSet<EventSink>();

		public int EventSinkCount { get { return _eventSinks.Count; } }

		/// @{ Dispatching
		private pthread_t _dispatchThread = pthread_t.CurrentThread;

		public void Dispatch() {
			TraceDispatchStarted();

			for( ; ; ) {
				if( _quitRequest ) {
					if( Fiber.FiberManager != null && Fiber.FiberManager.FiberCount > 0 )
						Fiber.FiberManager.CancelAllFibers();
					else
						break;
				}

				atomic( ++PollId, Relaxed );
				var polledDescriptors = LibcApi.epoll_wait( Epoll, &_signalledEvents[0], _signalledEvents.Length, -1 );

				if( polledDescriptors < 0 ) {
					switch( LibcApi.LastError ) {
						case SystemError.EINTR: continue;
						default: LibcApi.AssertErrno( polledDescriptors ); continue;
					}
				}

				NotifyEventSinks( polledDescriptors );
			}

			TraceDispatchFinished();
			Dispose();
		}

		public void OnEvent() {
			while( true ) {
				atomic( ++PollId, Relaxed );
				var polledDescriptors = LibcApi.epoll_wait( Epoll, &_signalledEvents[0], _signalledEvents.Length, 0 );

				if( polledDescriptors == 0 ) break;

				if( polledDescriptors < 0 ) {
					switch( LibcApi.LastError ) {
						case SystemError.EINTR: continue;
						default: LibcApi.AssertErrno( polledDescriptors ); continue;
					}
				}

				NotifyEventSinks( polledDescriptors );
			}
		}

		private void NotifyEventSinks( int polledDescriptors ) {
			NotificationStartTime = DateTime.UnbiasedNow;
			NotificationStartTimeUtc = DateTime.UtcNow;

			TraceEventsArrived( polledDescriptors );

			for( var i = 0; i < polledDescriptors; ++i ) {
				var& @event = _signalledEvents[i];
				var& eventSink = *bitcast<EventSink*>( &@event.data ); // dont touch refcount

				eventSink.EnsureEventSinkRegistered();
				TraceEventSink( @event, eventSink );

				eventSink.OnEvent( @event );
			}
		}

		/// @}

		// One 'EventSink' for one 'IOHandle'. Can be attached to one 'EventLoop'.
		// Ensure '_listenedEvents' and 'EventHandle' are valid before call 'Register()'
		public abstract class EventSink {
			public EPOLL_EVENTS _listenedEvents;

			public EventLoop Parent;
			public abstract IOHandle EventHandle { get; }

			/// @{
			public void Register( bool subscribe = true ) { Register( EventHandle, subscribe ); }
			public void NotifyEventModification() { NotifyEventModification( EventHandle ); }
			public void Unregister() { Unregister( EventHandle ); }

			public void Subscribe() { Subscribe( EventHandle ); }
			public void Unsubscribe() { Unsubscribe( EventHandle ); }
			/// @}

			/// Calls 'NotifyEventModification' on value change
			public EPOLL_EVENTS ListenedEvents {
				get { return _listenedEvents; }
				set { if( _listenedEvents != value ) { _listenedEvents = value; NotifyEventModification(); } }
			}

			public abstract void OnEvent( epoll_event& @event );

			public EventSink( EventLoop parent ) {
				// *( void** ) &Parent = bitcast<void*>( parent );
				Parent = parent;
			}

			public override void Dispose() {
				// *( void** ) &Parent = null;
				Parent = null;

				base.Dispose();
			}

			public sealed override uint GetHashCode() { return base.GetHashCode(); }

			protected void Subscribe( IOHandle handle ) {
				Parent.Epoll.Add( handle, new epoll_event { Events = _listenedEvents, Data = bitcast<void*>( this ) } );
			}

			protected void Unsubscribe( IOHandle handle ) {
				Parent.Epoll.Remove( handle );
			}

			protected void Register( IOHandle handle, bool subscribe = true ) {
				EnsureEventSinkNotRegistered();
				if( subscribe ) Subscribe( handle );
				Parent._eventSinks.Add( this );

				TraceEventSinkRegistered( this );
			}

			protected void NotifyEventModification( IOHandle handle ) {
				EnsureEventSinkRegistered();
				Parent.Epoll.Modify( handle, new epoll_event { Events = _listenedEvents, Data = bitcast<void*>( this ) } );

				TraceEventSinkModified( this );
			}

			protected void Unregister( IOHandle handle ) {
				TraceEventSinkUnregistered( this );

				EnsureEventSinkRegistered();
				Unsubscribe( handle );
				Parent._eventSinks.Remove( this );
			}

			[Conditional( ConditionString = "DEBUG" )]
			internal void EnsureEventSinkRegistered() {
				if( !Parent._eventSinks.Contains( this ) )
					Assert.Fail( "EventSink not registered!" );
			}

			[Conditional( ConditionString = "DEBUG" )]
			private void EnsureEventSinkNotRegistered() {
				if( Parent._eventSinks.Contains( this ) )
					Assert.Fail( "EventSink already registered!" );
			}
		}

		// used for internal purposes
		private class NotificationEmitter : EventSink {
			public override IOHandle EventHandle { get { return _notificationPipe[PipeHandle.ReadEnd]; } }

			private enum NotificationCommand : byte {
				NewDispatcherTasks,
				Exit, // exit from event loop
			}

			private PipeHandle[2] _notificationPipe;

			private bool _exitRequestPending, _newDispatcherTasks;

			public NotificationEmitter( EventLoop parent )
				: base( parent ) {
				_listenedEvents = EPOLL_EVENTS.EPOLLIN;

				LibcApi.pipe( _notificationPipe );
				_notificationPipe[PipeHandle.ReadEnd].IsNonBlocking = true; _notificationPipe[PipeHandle.ReadEnd].IsClosedOnExec = true;
				_notificationPipe[PipeHandle.WriteEnd].IsNonBlocking = true; _notificationPipe[PipeHandle.WriteEnd].IsClosedOnExec = true;
			}

			// Resource freeing (raw OS handles, malloc'ed memory) must be performed strictly in destructors since 'Dispose' may not be called before object lost last reference
			~NotificationEmitter() {
				_notificationPipe[PipeHandle.ReadEnd].Close();
				_notificationPipe[PipeHandle.WriteEnd].Close();
			}

			public override void OnEvent( epoll_event& @event ) {
				using( var page = Memory.CachedPages.PopScoped() ) {
					var buffer = ( byte* ) page.Value;
					var bufferLength = ( int ) Memory.DefaultPageSize;

					while( _notificationPipe[PipeHandle.ReadEnd].AvailableBytes > 0 ) {
						int readen;
						_notificationPipe[PipeHandle.ReadEnd].Read( buffer, bufferLength, readen );

						for( var i = 0; i < readen; ++i ) {
							switch( ( NotificationCommand ) buffer[i] ) {
								case NotificationCommand.Exit: atomic( _exitRequestPending = false ); Parent._quitRequest = true; break;
								case NotificationCommand.NewDispatcherTasks: atomic( _newDispatcherTasks = false ); Parent.ExecuteTasks(); break;
							}
						}
					}
				}
			}

			private void SendCommand( NotificationCommand command ) {
				_notificationPipe[PipeHandle.WriteEnd].Write( &command, sizeof( command ) );
			}

			public void RequestExit() { if( !atomic( _exitRequestPending = true ) ) SendCommand( NotificationCommand.Exit ); } // dont overwhelm pipe
			public void NotifyNewDispatcherTasks() { if( !atomic( _newDispatcherTasks = true ) ) SendCommand( NotificationCommand.NewDispatcherTasks ); } // dont overwhelm pipe
		}

		public void RequestExit() { _notificationEmitter.RequestExit(); }
		protected override void NotifyNewDispatcherTasks() { _notificationEmitter.NotifyNewDispatcherTasks(); }

		public abstract class SignalEventSink : EventSink {
			public override IOHandle EventHandle { get { return _signal; } }

			private SignalHandle _signal;

			public sealed override void OnEvent( epoll_event& @event ) {
				var signalInfo = _signal.Read();
				OnRaised( signalInfo );
			}

			public abstract void OnRaised( signalfd_siginfo& signalInfo );

			public SignalEventSink( EventLoop parent, sigset_t& signalSet )
				: base( parent ) {
				_signal = new SignalHandle( signalSet );
				_listenedEvents = EPOLL_EVENTS.EPOLLIN;
			}

			~SignalEventSink() {
				_signal.Close();
			}
		}

		public abstract class NotificationEventSink : EventSink {
			public override IOHandle EventHandle { get { return _eventHandle; } }

			private int _notificationId = -1;
			private SemaphoreHandle _eventHandle = new SemaphoreHandle();

			public NotificationEventSink( EventLoop parent )
				: base( parent ) {
				_listenedEvents = EPOLL_EVENTS.EPOLLIN;
			}

			~NotificationEventSink() {
				_eventHandle.Close();
			}

			public void Notify() {
				var id = atomic( Parent.PollId, Unordered );

				// eliminate unnecessary syscalls
				if( atomic( _notificationId = id, Relaxed ) == id ) return;

				_eventHandle.Increment();
			}

			public override void OnEvent( epoll_event& @event ) {
				var id = atomic( Parent.PollId, Unordered ) ^ ( int ) 0x80000000;

				atomic( _notificationId = id, Relaxed );
				_eventHandle.Decrement();
				OnNotified();
			}

			public abstract void OnNotified();
		}

		public sealed class ExitSignalEventSink : SignalEventSink {
			public ExitSignalEventSink( EventLoop parent, sigset_t& signalSet )
				: base( parent, signalSet ) {
			}

			public override void OnRaised( signalfd_siginfo& signalInfo ) {
				Parent.RequestExit();
			}
		}

		private static sigset_t _exitSignalSet = new sigset_t( SignalCode.SIGINT, SignalCode.SIGQUIT, SignalCode.SIGTERM, SignalCode.SIGHUP, SignalCode.SIGABRT );

		public void CatchExitSignals() {
			BlockExitSignals();
			CatchExitSignals( _exitSignalSet );
		}

		public void BlockExitSignals() {
			LibcApi.signal( SignalCode.SIGPIPE, LibcApi.SIG_IGN );
			LibcApi.AssertErrno( LibcApi.sigprocmask( ApplySignalCommand.SIG_BLOCK, &_exitSignalSet, null ) );
		}

		public void CatchExitSignals( sigset_t& signalSet ) {
			var eventSink = new ExitSignalEventSink( this, signalSet );
			eventSink.Register();
		}

		public abstract class TimerEventSink : EventSink {
			public override IOHandle EventHandle { get { return _timer; } }

			public sealed override void OnEvent( epoll_event& @event ) { var expirations = _timer.ReadExpirations(); OnRaised( expirations ); }
			public abstract void OnRaised( long expirations );

			protected TimerHandle _timer;

			public TimerEventSink( EventLoop parent, ClockType clockType )
				: base( parent ) {
				_timer = new TimerHandle( clockType );
				_listenedEvents = EPOLL_EVENTS.EPOLLIN | EPOLL_EVENTS.EPOLLET;
			}

			~TimerEventSink() {
				_timer.Close();
			}

			public void SetInterval( TimeSpan time ) {
				_timer.SetInterval( time );
			}

			public void SetInterval( TimeSpan interval, TimeSpan initialExpiration ) {
				_timer.SetInterval( interval, initialExpiration );
			}

			public void Stop() {
				_timer.Stop();
			}
		}

		public abstract class AcceptSocketEventSink : EventSink {
			public override IOHandle EventHandle { get { return _socket; } }

			protected SocketHandle _socket;

			public AcceptSocketEventSink( EventLoop parent, SocketHandle socket )
				: base( parent ) {
				_socket = socket;
				_listenedEvents = EPOLL_EVENTS.EPOLLIN | EPOLL_EVENTS.EPOLLET;
			}

			~AcceptSocketEventSink() {
				_socket.Close();
			}
		}

		public abstract class AcceptSocketTCP4EventSink : AcceptSocketEventSink {
			public AcceptSocketTCP4EventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( epoll_event& @event ) {
				sockaddr_in clientSocketInfo;
				SocketHandleTCP clientSocketHandle;

				while( ( clientSocketHandle = bitcast<SocketHandleTCP>( LibcApi.accept4( _socket, &clientSocketInfo, sizeof( clientSocketInfo ), SocketAcceptFlag.SOCK_NONBLOCK | SocketAcceptFlag.SOCK_CLOEXEC ) ) ).IsValid )
					OnAccepted( clientSocketHandle, clientSocketInfo );
			}

			protected abstract void OnAccepted( SocketHandleTCP socket, sockaddr_in& socketInfo );
		}

		public abstract class AcceptSocketTCP6EventSink : AcceptSocketEventSink {
			public AcceptSocketTCP6EventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( epoll_event& @event ) {
				sockaddr_in6 clientSocketInfo;
				SocketHandleTCP clientSocketHandle;

				while( ( clientSocketHandle = bitcast<SocketHandleTCP>( LibcApi.accept4( _socket, &clientSocketInfo, sizeof( clientSocketInfo ), SocketAcceptFlag.SOCK_NONBLOCK | SocketAcceptFlag.SOCK_CLOEXEC ) ) ).IsValid )
					OnAccepted( clientSocketHandle, clientSocketInfo );
			}

			protected abstract void OnAccepted( SocketHandleTCP socket, sockaddr_in6& socketInfo );
		}

		public abstract class AcceptSocketUnixEventSink : AcceptSocketEventSink {
			public AcceptSocketUnixEventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( epoll_event& @event ) {
				var clientSocketInfo = default( sockaddr_un );
				SocketHandleLocal clientSocketHandle;

				while( ( clientSocketHandle = bitcast<SocketHandleLocal>( LibcApi.accept4( _socket, &clientSocketInfo, sizeof( clientSocketInfo ), SocketAcceptFlag.SOCK_NONBLOCK | SocketAcceptFlag.SOCK_CLOEXEC ) ) ).IsValid )
					OnAccepted( clientSocketHandle, clientSocketInfo );
			}

			protected abstract void OnAccepted( SocketHandleLocal socket, sockaddr_un& socketInfo );
		}

		public abstract class AcceptSocketAnyEventSink : AcceptSocketEventSink {
			public AcceptSocketAnyEventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( epoll_event& @event ) {
				SocketHandle clientSocketHandle;

				while( ( clientSocketHandle = LibcApi.accept4( _socket, null, 0, SocketAcceptFlag.SOCK_NONBLOCK | SocketAcceptFlag.SOCK_CLOEXEC ) ).IsValid )
					OnAccepted( clientSocketHandle );
			}

			protected abstract void OnAccepted( SocketHandle socket );
		}

		#region Dispatcher

		private DispatcherRealtimeEventSink _dispatcherUtcAlarmEventSink;
		private DispatcherUnbiasedAlarmEventSink _dispatcherUnbiasedAlarmEventSink;

		private sealed class DispatcherRealtimeEventSink : TimerEventSink {
			public override void OnRaised( long expirations ) { Parent.OnUtcAlarm(); }

			public DispatcherRealtimeEventSink( EventLoop parent )
				: base( parent, ClockType.CLOCK_REALTIME ) {
			}
		}

		private sealed class DispatcherUnbiasedAlarmEventSink : TimerEventSink {
			public override void OnRaised( long expirations ) { Parent.OnUnbiasedAlarm(); }

			public DispatcherUnbiasedAlarmEventSink( EventLoop parent )
				: base( parent, ClockType.CLOCK_MONOTONIC ) {
			}
		}

		private void InitDispatcher() {
			_dispatcherUtcAlarmEventSink = new DispatcherRealtimeEventSink( this );
			_dispatcherUtcAlarmEventSink.Register();

			_dispatcherUnbiasedAlarmEventSink = new DispatcherUnbiasedAlarmEventSink( this );
			_dispatcherUnbiasedAlarmEventSink.Register();
		}

		private void CloseDispatcher() {
			ExecuteTasks();

			if( _dispatcherUtcAlarmEventSink != null ) { _dispatcherUtcAlarmEventSink.Unregister(); _dispatcherUtcAlarmEventSink = null; }
			if( _dispatcherUnbiasedAlarmEventSink != null ) { _dispatcherUnbiasedAlarmEventSink.Unregister(); _dispatcherUnbiasedAlarmEventSink = null; }
		}

		protected override void StopAlarm( AlarmKind kind ) {
			switch( kind ) {
				case AlarmKind.Utc: _dispatcherUtcAlarmEventSink.Stop(); break;
				case AlarmKind.Unbiased: _dispatcherUnbiasedAlarmEventSink.Stop(); break;
			}
		}

		protected override void SetAlarm( AlarmKind kind, TimeSpan time ) {
			switch( kind ) {
				case AlarmKind.Utc: _dispatcherUtcAlarmEventSink.SetInterval( time ); break;
				case AlarmKind.Unbiased: _dispatcherUnbiasedAlarmEventSink.SetInterval( time ); break;
			}
		}

		protected override bool IsDispatchingThread { get { return _dispatchThread.IsCurrent; } }

		#endregion

		/// @{ Tracing
		private const string TraceConditionString = "TRACE_EVENT_LOOP";

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceDispatchStarted() {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue,
				Bold = true
			}, "EventLoop dispatch started: {0}", DateTime.UtcNow );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceDispatchFinished() {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue,
				Bold = true
			}, "EventLoop dispatch finished: {0}", DateTime.UtcNow );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private void TraceEventsArrived( int polledDescriptors ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue,
				Bold = true
			}, "EventLoop: epoll_wait() count={0} at {1}", polledDescriptors, NotificationStartTime );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceEventSink( epoll_event& @event, EventSink eventSink ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, " notify '{0}'({1}) with event='{2}'", eventSink != null ? eventSink.GetType() : typeof( void ), bitcast<void*>( eventSink ), @event );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceEventSinkRegistered( EventSink eventSink ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue,
				Bold = true
			}, "EventSink '{0}'({1}) registered. Handle={2}, Events={3}", eventSink.GetType(), bitcast<void*>( eventSink ), eventSink.EventHandle.ID, eventSink._listenedEvents );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceEventSinkModified( EventSink eventSink ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue,
				Bold = true
			}, "EventSink '{0}'({1}) modified. Handle={2}, Events={3}", eventSink.GetType(), bitcast<void*>( eventSink ), eventSink.EventHandle.ID, eventSink._listenedEvents );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceEventSinkUnregistered( EventSink eventSink ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue,
				Bold = true
			}, "EventSink '{0}'({1}) unregistered. Handle={2}", eventSink.GetType(), bitcast<void*>( eventSink ), eventSink.EventHandle.ID );
		}
		/// @}
	}
}