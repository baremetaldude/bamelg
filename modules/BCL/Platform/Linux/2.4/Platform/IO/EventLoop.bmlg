//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Runtime;

using Platform.Kernel;
using Platform.Libc;

namespace Platform.IO {
	// Event loop is a heart of event-driven application
	public partial class EventLoop : System.Threading.Dispatcher {
		protected bool _quitRequest = false;

		private List<pollfd> _polledDescriptors = new List<pollfd>();
		private List<EventSink> _eventSinks = new List<EventSink>();
		private PoolIndexManager _indexManager = new PoolIndexManager( 32 );
		private List<int> _readyIndices = new List<int>( 32 ); // attempt to make polling more cache-friendly

		private NotificationEmitter _notificationEmitter = new NotificationEmitter( this );

		private bool _fiberDispatch = false;

		[ThreadStatic]
		public static EventLoop Instance;

		public EventLoop( bool enableFibers = true ) {
			_notificationEmitter.Register();

			if( enableFibers && !Fiber.Enabled ) {
				_fiberDispatch = true;
				Fiber.RuntimeInitialize();
				Fiber.FiberManager.Attach( this );
			}

			Instance = this;
			_dispatchThread = Platform.Libc.pthread_t.CurrentThread;
		}

		public override void Dispose() {
			ExecuteTasks();

			if( _fiberDispatch )
				Fiber.FiberManager.Detach( this );

			foreach( var eventSink in _eventSinks )
				if( eventSink != null )
					eventSink.Dispose();

			if( _fiberDispatch ) {
				Fiber.RuntimeShutdown();
				_fiberDispatch = false;
			}

			Instance = null;
		}

		private static void QuitSignalHandler( int signal ) {
			Instance.RequestExit();
		}

		private static sigset_t _exitSignalSet = new sigset_t( SignalCode.SIGINT, SignalCode.SIGQUIT, SignalCode.SIGTERM, SignalCode.SIGHUP, SignalCode.SIGABRT );

		public void CatchExitSignals() {
			LibcApi.signal( SignalCode.SIGPIPE, LibcApi.SIG_IGN );
			CatchExitSignals( _exitSignalSet );
		}

		public void CatchExitSignals( sigset_t& signalSet ) {
			foreach( var signal in _exitSignalSet )
				LibcApi.signal( signal, QuitSignalHandler );
		}

		public void RequestExit() { _notificationEmitter.RequestExit(); }
		public void RequestUpdateEventList() { if( !_dispatchThread.IsCurrent ) _notificationEmitter.RequestUpdate(); }
		protected override void NotifyNewDispatcherTasks() { _notificationEmitter.NotifyNewDispatcherTasks(); }

		/// @{ Dispatching
		private Platform.Libc.pthread_t _dispatchThread;

		internal int _dispatchingIndex;

		public void UnregisterHandle( int poolID ) {
			_indexManager.Deallocate( poolID );
			_polledDescriptors[poolID] = new pollfd { Handle = IOHandle.Invalid, ListenedEvents = PollEvents.None, RaisedEvents = PollEvents.None };
			_eventSinks[poolID] = null; // 'this' may be destroyed after that statement
		}

		public void Dispatch() {
			TraceDispatchStarted();
			Instance = this;

			for( ; ; ) {
				if( _quitRequest ) {
					if( Fiber.FiberManager != null && Fiber.FiberManager.FiberCount > 0 )
						Fiber.FiberManager.CancelAllFibers();
					else
						break;
				}

				var pollTimeout = -1;

				var timeout = GetWaitTime();
				if( timeout != TimeSpan.MaxValue )
					pollTimeout = ( int ) timeout.TotalMilliseconds;

				TraceBeginWait( _polledDescriptors.Count, pollTimeout );

				var eventBuffer = _polledDescriptors.GetBuffer();
				var polledDescriptors = LibcApi.poll( eventBuffer, _polledDescriptors.Count.ToUnsigned(), pollTimeout );
				if( polledDescriptors < 0 ) {
					switch( LibcApi.LastError ) {
						case SystemError.EINTR: continue;
						default: LibcApi.AssertErrno( polledDescriptors ); continue;
					}
				}

				NotificationStartTime = DateTime.UnbiasedNow;
				NotificationStartTimeUtc = DateTime.UtcNow;
				TraceEventsArrived( polledDescriptors );

				OnUtcAlarm();
				OnUnbiasedAlarm();

				var sourcesBuffer = _eventSinks.GetBuffer();

				_readyIndices.Clear();
				for( var i = 0; i < _polledDescriptors.Count; ++i ) {
					var& @event = eventBuffer[i];

					if( @event.RaisedEvents != 0 ) {
						_readyIndices.Add( i );
						--polledDescriptors;
						if( polledDescriptors <= 0 ) break;
					}
				}

				for( var j = 0; j < _readyIndices.Count; ++j ) {
					_dispatchingIndex = _readyIndices[j];

					var& @event = eventBuffer[_dispatchingIndex];
					var& eventSink = *bitcast<EventSink*>( &sourcesBuffer[_dispatchingIndex] ); // dont touch refcount
					TraceEventSink( @event, eventSink );

					eventSink.OnEvent( @event );
				}
			}

			TraceDispatchFinished();
			Dispose();
		}
		/// @}

		public abstract class EventSink {
			public EventLoop Parent; ///< Event loop holding/polling this EventSink

			public abstract void OnEvent( pollfd& @event );

			public EventSink( EventLoop parent ) {
				Parent = parent;
			}

			public override void Dispose() {
				// *( void** ) &Parent = null;
				Parent = null;

				base.Dispose();
			}

			public sealed override uint GetHashCode() { return base.GetHashCode(); }

			protected int RegisterHandle( IOHandle handle, PollEvents events ) {
				var poolID = Parent._indexManager.Allocate();
				if( poolID >= Parent._eventSinks.Count ) {
					Parent._polledDescriptors.Add( new pollfd { Handle = handle, ListenedEvents = events, RaisedEvents = PollEvents.None } );
					Parent._eventSinks.Add( this );
				}
				else {
					Parent._eventSinks[poolID] = this;
					Parent._polledDescriptors[poolID] = new pollfd { Handle = handle, ListenedEvents = events, RaisedEvents = PollEvents.None };
				}

				return poolID;
			}
		}

		public abstract class EventSinkHandle : EventSink {
			public IOHandle EventHandle; ///< Handle passed to 'poll'

			/// Calls 'NotifyEventModification' on value change
			public PollEvents ListenedEvents {
				get { return _listenedEvents; }
				set { if( _listenedEvents != value ) { _listenedEvents = value; NotifyEventModification( EventHandle ); } }
			}

			public PollEvents _listenedEvents; ///< If you need to update '_listenedEvents' outside of 'OnEvent' call 'NotifyEventModification' method
			public int PoolID = -1;            ///< Index of EventSink in array of 'pollfd' passed to 'poll'

			public EventSinkHandle( EventLoop parent )
				: base( parent ) {
			}

			[Conditional( ConditionString = "DEBUG" )]
			protected void EnsureEventSinkRegistered() {
				if( PoolID == -1 )
					Assert.Fail( "EventSink not registered!" );
			}

			[Conditional( ConditionString = "DEBUG" )]
			protected void EnsureEventSinkNotRegistered() {
				if( PoolID != -1 )
					Assert.Fail( "EventSink already registered!" );
			}

			public void Register() {
				EnsureEventSinkNotRegistered();

				PoolID = RegisterHandle( EventHandle, _listenedEvents );

				TraceEventSinkRegistered( this );
			}

			public void Unregister() {
				TraceEventSinkUnregistered( this );
				EnsureEventSinkRegistered();

				var poolId = PoolID;
				PoolID = -1;
				Parent.UnregisterHandle( poolId );
			}

			protected void NotifyEventModification( IOHandle handle ) {
				EnsureEventSinkRegistered();

				var pollBuffer = Parent._polledDescriptors.GetBuffer();
				if( pollBuffer[PoolID].ListenedEvents != _listenedEvents ) {
					pollBuffer[PoolID].ListenedEvents = _listenedEvents;
					Parent.RequestUpdateEventList();
				}

				TraceEventSinkModified( this );
			}
		}

		// used for internal purposes
		private class NotificationEmitter : EventSinkHandle {
			private enum NotificationCommand {
				NewDispatcherTasks, // new tasks arrived
				Exit,               // exit from main loop
				Update,             // update list of handles/event types
			}

			private PipeHandle[2] _notificationPipe;

			private bool _exitRequestPending, _updateRequestPending;
			private bool _newDispatcherTasks = false;

			public NotificationEmitter( EventLoop parent )
				: base( parent ) {
				_listenedEvents = PollEvents.POLLIN;

				LibcApi.pipe( _notificationPipe );

				_notificationPipe[PipeHandle.ReadEnd].IsNonBlocking = true; _notificationPipe[PipeHandle.ReadEnd].IsClosedOnExec = true;
				_notificationPipe[PipeHandle.WriteEnd].IsNonBlocking = true; _notificationPipe[PipeHandle.WriteEnd].IsClosedOnExec = true;

				EventHandle = _notificationPipe[PipeHandle.ReadEnd];
			}

			// Resource freeing (raw OS handles, malloc'ed memory) must be performed strictly in destructors since 'Dispose' may not be called before object lost last reference
			~NotificationEmitter() {
				_notificationPipe[PipeHandle.ReadEnd].Close();
				_notificationPipe[PipeHandle.WriteEnd].Close();
			}

			public override void OnEvent( pollfd& @event ) {
				using( var page = Memory.CachedPages.PopScoped() ) {
					var buffer = ( byte* ) page.Value;
					var bufferLength = ( int ) Memory.DefaultPageSize;

					while( _notificationPipe[PipeHandle.ReadEnd].AvailableBytes > 0 ) {
						int readen;
						_notificationPipe[PipeHandle.ReadEnd].Read( buffer, bufferLength, readen );

						for( var i = 0; i < readen; ++i ) {
							switch( ( NotificationCommand ) buffer[i] ) {
								case NotificationCommand.Exit: atomic( _exitRequestPending = false ); Parent._quitRequest = true; break;
								case NotificationCommand.Update: atomic( _updateRequestPending = false ); break;
								case NotificationCommand.NewDispatcherTasks: atomic( _newDispatcherTasks = false ); Parent.ExecuteTasks(); break;
							}
						}
					}
				}
			}

			private void SendCommand( NotificationCommand command ) {
				_notificationPipe[PipeHandle.WriteEnd].Write( &command, sizeof( command ) );
			}

			public void RequestExit() { if( !atomic( _exitRequestPending = true ) ) { SendCommand( NotificationCommand.Exit ); } } // dont overwhelm pipe
			public void RequestUpdate() { if( !atomic( _updateRequestPending = true ) ) { SendCommand( NotificationCommand.Update ); } } // dont overwhelm pipe
			public void NotifyNewDispatcherTasks() { if( !atomic( _newDispatcherTasks = true ) ) SendCommand( NotificationCommand.NewDispatcherTasks ); } // dont overwhelm pipe
		}

		public abstract class NotificationEventSink : EventSinkHandle {
			private enum NotificationCommand {
				Update,
			}

			private PipeHandle[2] _notificationPipe;

			private bool _notificationPending;

			public NotificationEventSink( EventLoop parent )
				: base( parent ) {
				_listenedEvents = PollEvents.POLLIN;

				LibcApi.pipe( _notificationPipe );

				_notificationPipe[PipeHandle.ReadEnd].IsNonBlocking = true; _notificationPipe[PipeHandle.ReadEnd].IsClosedOnExec = true;
				_notificationPipe[PipeHandle.WriteEnd].IsNonBlocking = true; _notificationPipe[PipeHandle.WriteEnd].IsClosedOnExec = true;

				EventHandle = _notificationPipe[PipeHandle.ReadEnd];
			}

			// Resource freeing (raw OS handles, malloc'ed memory) must be performed strictly in destructors since 'Dispose' may not be called before object lost last reference
			~NotificationEventSink() {
				_notificationPipe[PipeHandle.ReadEnd].Close();
				_notificationPipe[PipeHandle.WriteEnd].Close();
			}

			public override void OnEvent( pollfd& @event ) {
				_notificationPending = false;

				for( var available = _notificationPipe[PipeHandle.ReadEnd].AvailableBytes; available > 0; available = _notificationPipe[PipeHandle.ReadEnd].AvailableBytes ) {
					for( var bytes = 0; bytes < available; ) {
						int readen;

						NotificationCommand command;
						_notificationPipe[PipeHandle.ReadEnd].Read( &command, sizeof( command ), readen );
						bytes += sizeof( command );

						switch( command ) {
							case NotificationCommand.Update: break;
						}
					}
				}

				OnNotified();
			}

			private void SendCommand( NotificationCommand command ) {
				_notificationPipe[PipeHandle.WriteEnd].Write( &command, sizeof( command ) );
			}

			public void Notify() { if( !atomic( _notificationPending = true ) ) SendCommand( NotificationCommand.Update ); }

			public abstract void OnNotified();
		}

		public abstract class AcceptSocketEventSink : EventSinkHandle {
			[Overlapped( Offset = memberinfo( EventSinkHandle.EventHandle ).ByteOffset )]
			public new SocketHandle EventHandle;

			public AcceptSocketEventSink( EventLoop parent, SocketHandle socket )
				: base( parent ) {
				EventHandle = socket;
				_listenedEvents = PollEvents.POLLIN;
			}

			~AcceptSocketEventSink() {
				EventHandle.Close();
			}
		}

		public abstract class AcceptSocketTCP4EventSink : AcceptSocketEventSink {
			public AcceptSocketTCP4EventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( pollfd& @event ) {
				sockaddr_in clientSocketInfo;
				SocketHandleTCP clientSocketHandle;

				while( ( clientSocketHandle = bitcast<SocketHandleTCP>( LibcApi.accept( EventHandle, ( sockaddr* ) &clientSocketInfo, sizeof( clientSocketInfo ) ) ) ).IsValid ) {
					clientSocketHandle.IsNonBlocking = true;
					OnAccepted( clientSocketHandle, clientSocketInfo );
				}
			}

			protected abstract void OnAccepted( SocketHandleTCP socket, sockaddr_in& socketInfo );
		}

		public abstract class AcceptSocketTCP6EventSink : AcceptSocketEventSink {
			public AcceptSocketTCP6EventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( pollfd& @event ) {
				sockaddr_in6 clientSocketInfo;
				SocketHandleTCP clientSocketHandle;

				while( ( clientSocketHandle = bitcast<SocketHandleTCP>( LibcApi.accept( EventHandle, ( sockaddr* ) &clientSocketInfo, sizeof( clientSocketInfo ) ) ) ).IsValid ) {
					clientSocketHandle.IsNonBlocking = true;
					OnAccepted( clientSocketHandle, clientSocketInfo );
				}
			}

			protected abstract void OnAccepted( SocketHandleTCP socket, sockaddr_in6& socketInfo );
		}

		public abstract class AcceptSocketUnixEventSink : AcceptSocketEventSink {
			public AcceptSocketUnixEventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( pollfd& @event ) {
				var clientSocketInfo = default( sockaddr_un );
				SocketHandleLocal clientSocketHandle;

				while( ( clientSocketHandle = bitcast<SocketHandleLocal>( LibcApi.accept( EventHandle, ( sockaddr* ) &clientSocketInfo, sizeof( clientSocketInfo ) ) ) ).IsValid ) {
					clientSocketHandle.IsNonBlocking = true;
					OnAccepted( clientSocketHandle, clientSocketInfo );
				}
			}

			protected abstract void OnAccepted( SocketHandleLocal socket, sockaddr_un& socketInfo );
		}

		public abstract class AcceptSocketAnyEventSink : AcceptSocketEventSink {
			public AcceptSocketAnyEventSink( EventLoop parent, SocketHandle socket )
				: base( parent, socket ) {
			}

			public override void OnEvent( pollfd& @event ) {
				SocketHandle clientSocketHandle;

				while( ( clientSocketHandle = LibcApi.accept( EventHandle, null, 0 ) ).IsValid ) {
					clientSocketHandle.IsNonBlocking = true;
					OnAccepted( clientSocketHandle );
				}
			}

			protected abstract void OnAccepted( SocketHandle socket );
		}

		#region Dispatcher

		protected override void SetAlarm( AlarmKind kind, TimeSpan time ) { }
		protected override void StopAlarm( AlarmKind kind ) { }
		protected override bool IsDispatchingThread { get { return _dispatchThread.IsCurrent; } }

		#endregion

		/// @{ Tracing
		private const string TraceConditionString = "TRACE_EVENT_LOOP";

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceDispatchStarted() {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, "EventLoop dispatch started: {0}", DateTime.UtcNow );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceDispatchFinished() {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, "EventLoop dispatch finished: {0}", DateTime.UtcNow );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private void TraceEventsArrived( int polledDescriptors ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue,
				Bold = true
			}, "EventLoop: poll() count={0} at {1}", polledDescriptors, NotificationStartTimeUtc );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceBeginWait( int eventCount, int milliseconds ) {
			TypedReference timeout = milliseconds;
			if( milliseconds == -1 ) timeout = "INFINITE";

			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue,
				Bold = true
			}, "EventLoop: Begin wait {0} events for {1}{2}", eventCount, timeout, milliseconds != -1 ? "ms" : "" );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceEventSink( pollfd& @event, EventSink eventSink ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, " notify '{0}'({1}) with event='{2}'", eventSink != null ? eventSink.GetType() : typeof( void ), bitcast<void*>( eventSink ), @event );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceEventSinkRegistered( EventSinkHandle eventSink ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, "EventSink '{0}'({1}) registered. Handle={2}, Events={3}", eventSink.GetType(), bitcast<void*>( eventSink ), eventSink.EventHandle.ID, eventSink._listenedEvents );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceEventSinkModified( EventSinkHandle eventSink ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, "EventSink '{0}'({1}) modified. Handle={2}, Events={3}", eventSink.GetType(), bitcast<void*>( eventSink ), eventSink.EventHandle.ID, eventSink._listenedEvents );
		}

		[Conditional( ConditionString = TraceConditionString )]
		private static void TraceEventSinkUnregistered( EventSinkHandle eventSink ) {
			Trace.Write( new Console.OutputAttributes() {
				BackgroundColor = RgbColor.Blue
			}, "EventSink '{0}'({1}) unregistered. Handle={2}", eventSink.GetType(), bitcast<void*>( eventSink ), eventSink.EventHandle.ID );
		}
		/// @}
	}
}