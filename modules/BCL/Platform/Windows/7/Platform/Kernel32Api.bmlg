//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.Diagnostics;
using System.Net;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Platform {
	[DllImport( Image = "KERNEL32.dll" )]
	[CallingConvention( Value = NtApi.DefaultCallingConvention )]
	public static partial struct Kernel32Api {
		public extern static int WideCharToMultiByte( uint CodePage, uint dwFlags, char* lpWideCharStr, int cchWideChar, byte* buffer, int cbMultiByte, byte* lpDefaultChar, Boolean32& lpUsedDefaultChar );

		public extern static ushort RtlCaptureStackBackTrace( uintptr framesToSkip, uintptr framesToCapture, void** backTrace, uintptr* backTraceHash );

		[BackendSymbol( Name = "ExpandEnvironmentStringsA" )]
		public extern static uint ExpandEnvironmentStrings( CString source, byte* destination, uint destinationLength );
		[BackendSymbol( Name = "ExpandEnvironmentStringsW" )]
		public extern static uint ExpandEnvironmentStrings( CUtf16String source, char* destination, uint destinationLength );

		/// @{ Pipe
		public extern static Boolean32 CreatePipe( HANDLE& readPipe, HANDLE& writePipe, SECURITY_ATTRIBUTES& pipeAttributes, uint size = 0 );
		[BackendSymbol( Name = "CreateNamedPipeA" )]
		public extern static NamedPipeHandle CreateNamedPipe( CString name, NamedPipeAccessMode openMode, NamedPipeCreateMode pipeMode, uint maxInstances, uint outBufferSize, uint inBufferSize, uint defaultTimeOut, SECURITY_ATTRIBUTES& attributes );
		[BackendSymbol( Name = "CreateNamedPipeW" )]
		public extern static NamedPipeHandle CreateNamedPipe( CUtf16String name, NamedPipeAccessMode openMode, NamedPipeCreateMode pipeMode, uint maxInstances, uint outBufferSize, uint inBufferSize, uint defaultTimeOut, SECURITY_ATTRIBUTES& attributes );

		public extern static Boolean32 ConnectNamedPipe( HANDLE pipe, OVERLAPPED& overlapped );
		public extern static Boolean32 DisconnectNamedPipe( HANDLE pipe );

		public extern static Boolean32 SetNamedPipeHandleState( HANDLE pipe, NamedPipeState& mode, uint& maxCollectionCount, uint& collectDataTimeout );
		[BackendSymbol( Name = "GetNamedPipeHandleStateA" )]
		public extern static Boolean32 GetNamedPipeHandleState( HANDLE pipe, NamedPipeState& state, uint& curInstances, uint& maxCollectionCount, uint& collectDataTimeout, byte* userName, uint maxUserNameSize );
		[BackendSymbol( Name = "GetNamedPipeHandleStateW" )]
		public extern static Boolean32 GetNamedPipeHandleState( HANDLE pipe, NamedPipeState& state, uint& curInstances, uint& maxCollectionCount, uint& collectDataTimeout, char* userName, uint maxUserNameSize );

		public extern static Boolean32 GetNamedPipeInfo( HANDLE pipe, NamedPipeInfo& flags, uint& outBufferSize, uint& inBufferSize, uint& maxInstances );

		public extern static Boolean32 PeekNamedPipe( HANDLE pipe, void* buffer, uint bufferSize, uint& bytesRead, uint& totalBytesAvail, uint& bytesLeftThisMessage );
		public extern static Boolean32 TransactNamedPipe( HANDLE namedPipe, void* inBuffer, uint inBufferSize, void* outBuffer, uint outBufferSize, uint& bytesRead, OVERLAPPED& overlapped );

		public extern static Boolean32 GetNamedPipeClientProcessId( HANDLE pipe, uint& clientProcessId );
		public extern static Boolean32 GetNamedPipeClientSessionId( HANDLE pipe, uint& clientSessionId );
		public extern static Boolean32 GetNamedPipeServerProcessId( HANDLE pipe, uint& serverProcessId );
		public extern static Boolean32 GetNamedPipeServerSessionId( HANDLE pipe, uint& serverSessionId );

		[BackendSymbol( Name = "GetNamedPipeClientComputerNameA" )]
		public extern static Boolean32 GetNamedPipeClientComputerName( HANDLE pipe, byte* clientComputerName, uint clientComputerNameLength );
		[BackendSymbol( Name = "GetNamedPipeClientComputerNameW" )]
		public extern static Boolean32 GetNamedPipeClientComputerName( HANDLE pipe, char* clientComputerName, uint clientComputerNameLength );

		public extern static Boolean32 GetNamedPipeAttribute( HANDLE pipe, PIPE_ATTRIBUTE_TYPE attributeType, CString AttributeName, void* AttributeValue, uintptr AttributeValueLength );
		public extern static Boolean32 SetNamedPipeAttribute( HANDLE pipe, PIPE_ATTRIBUTE_TYPE attributeType, CString attributeName, void* attributeValue, uintptr attributeValueLength );

		[BackendSymbol( Name = "CallNamedPipeA" )]
		public extern static Boolean32 CallNamedPipe( CString name, void* buffer, uint bufferSize, void* outBuffer, uint outBufferSize, uint& bytesRead, uint timeOut );
		[BackendSymbol( Name = "CallNamedPipeW" )]
		public extern static Boolean32 CallNamedPipe( CUtf16String name, void* buffer, uint bufferSize, void* outBuffer, uint outBufferSize, uint& bytesRead, uint timeOut );

		[BackendSymbol( Name = "WaitNamedPipeA" )]
		public extern static Boolean32 WaitNamedPipe( CString name, uint timeOut );
		[BackendSymbol( Name = "WaitNamedPipeW" )]
		public extern static Boolean32 WaitNamedPipe( CUtf16String name, uint timeOut );
		/// @}

		/// @{ Heap
		public extern static HeapHandle GetProcessHeap();
		public extern static HeapHandle HeapCreate( HeapCreateFlags flags, uint initialSize, uint maxSize );
		public extern static Boolean32 HeapDestroy( HeapHandle value );
		public extern static void* HeapAlloc( HeapHandle heap, HeapAllocFlags flags, uint bytes );
		public extern static void* HeapReAlloc( HeapHandle heap, HeapReAllocFlags flags, void* memory, uint bytes );
		public extern static Boolean32 HeapFree( HeapHandle heap, HeapSerializationFlags flags, void* memory );
		public extern static uint HeapSize( HeapHandle heap, HeapSerializationFlags flags, void* memory );
		public extern static Boolean32 HeapValidate( HeapHandle hHeap, HeapSerializationFlags flags, void* memory );
		public extern static uint HeapCompact( HeapHandle heap, HeapSerializationFlags flags );
		/// @}

		/// @{ Error handling
		public extern static Boolean32 Beep( uint freq, uint durationMilliseconds );

		/// http://msdn.microsoft.com/en-us/library/ms679360(v=vs.85).aspx
		public extern static SystemErrorCode GetLastError();
		public static SystemErrorCode LastError {
			get {
				return _TEB.LastError;
				// return GetLastError();
			}
			set {
				_TEB.LastError = value;
				// SetLastError( value );
			}
		}

		public static void Assert( bool condition, [In] CallerContext& callercontext = nullref ) {
			if( condition ) return;
			var lastError = LastError;

			Console.Write( "Assertion failed: " );
			Console.Write( callercontext.Expression );
			Console.Write( " LastError: " );
			Console.Write( lastError );
			Console.Write( " at line " );
			Console.Write( callercontext.Row );

			Assert.PrintContextInfo( callercontext );
			Console.WriteLine();
		}

		/// http://msdn.microsoft.com/en-us/library/ms680627(VS.85).aspx
		public extern static void SetLastError( SystemErrorCode code );

		public extern static ProcessErrorMode SetErrorMode( ProcessErrorMode mode );
		public extern static ProcessErrorMode GetErrorMode();

		[BackendSymbol( Name = "FatalAppExitA" )]
		public extern static void FatalAppExit( [Unused] uint reserved, CString messageText );
		[BackendSymbol( Name = "FatalAppExitW" )]
		public extern static void FatalAppExit( [Unused] uint reserved, CUtf16String messageText );
		/// @}

		/// @{ Error recovery
		public functor uint ApplicationRecoveryCallback( void* parameter );
		public extern static SystemErrorCode ApplicationRecoveryInProgress( int& canceled );
		public extern static SystemErrorCode UnregisterApplicationRecoveryCallback();
		public extern static SystemErrorCode UnregisterApplicationRestart();
		public extern static SystemErrorCode RegisterApplicationRestart( CUtf16String commandline, RegisterApplicationRestartFlags flags );
		public extern static SystemErrorCode RegisterApplicationRecoveryCallback( ApplicationRecoveryCallback recoveryCallback, void* parameter, uint pingInterval, [Unused] uint reserved );
		public extern static SystemErrorCode GetApplicationRecoveryCallback( ProcessHandle process, ApplicationRecoveryCallback& recoveryCallback, void*& parameter, uint pingInterval, [Unused] uint reserved );
		public extern static SystemErrorCode GetApplicationRestartSettings( ProcessHandle process, char* commandline, uint& commandLineLength, RegisterApplicationRestartFlags& flags );
		/// @}

		/// @{ Debugging
		public extern static Boolean32 IsDebuggerPresent();

		public extern static void DebugBreak();
		public extern static Boolean32 DebugBreakProcess( ProcessHandle process );
		public extern static Boolean32 CheckRemoteDebuggerPresent( ProcessHandle process, int& isDebuggerPresent );
		public extern static Boolean32 DebugActiveProcess( uint processId );
		public extern static Boolean32 DebugActiveProcessStop( uint processId );
		public extern static Boolean32 DebugSetProcessKillOnExit( bool killOnExit );
		public extern static Boolean32 FlushInstructionCache( ProcessHandle process, void* baseAddress, uintptr size );

		public extern static Boolean32 WriteProcessMemory( ProcessHandle process, void* destinationAddress, void* buffer, uintptr size, uintptr& numberOfBytesWritten );

		[BackendSymbol( Name = "OutputDebugStringA" )]
		public extern static void OutputDebugString( CString value );
		[BackendSymbol( Name = "OutputDebugStringW" )]
		public extern static void OutputDebugString( CUtf16String value );

		/// @}

		/// @{ Handle
		public extern static Boolean32 CloseHandle( HANDLE handle );
		public extern static Boolean32 GetHandleInformation( HANDLE handle, uint& flags );
		public extern static Boolean32 SetHandleInformation( HANDLE handle, uint mask, uint flags );
		public extern static Boolean32 DuplicateHandle( HANDLE sourceProcessHandle, HANDLE sourceHandle, HANDLE targetProcessHandle, HANDLE& targetHandle, uint dwDesiredAccess, bool bInheritHandle, uint options );
		/// @}

		/// @{ Console http://msdn.microsoft.com/en-us/library/ms682073(v=vs.85).aspx
		public functor Boolean32 HandlerRoutine( ConsoleTerminationEvent @event );
		public extern static Boolean32 SetConsoleCtrlHandler( HandlerRoutine handlerRoutine, bool add );

		/// http://msdn.microsoft.com/en-us/library/ms681944(v=vs.85).aspx
		public extern static Boolean32 AllocConsole();

		/// http://msdn.microsoft.com/en-us/library/ms681952(v=vs.85).aspx
		public extern static Boolean32 FreeConsole();

		/// http://msdn.microsoft.com/en-us/library/ms681952(v=vs.85).aspx
		public extern static Boolean32 AttachConsole( uint code );

		/// http://msdn.microsoft.com/en-us/library/ms686050(v=vs.85).aspx
		[BackendSymbol( Name = "SetConsoleTitleA" )]
		public extern static Boolean32 SetConsoleTitle( CString title );
		[BackendSymbol( Name = "SetConsoleTitleW" )]
		public extern static Boolean32 SetConsoleTitle( CUtf16String title );

		/// http://msdn.microsoft.com/en-us/library/ms683174(v=vs.85).aspx
		[BackendSymbol( Name = "GetConsoleTitleA" )]
		public extern static uint GetConsoleTitle( byte* buffer, int length );
		[BackendSymbol( Name = "GetConsoleTitleW" )]
		public extern static uint GetConsoleTitle( char* buffer, int length );

		// public extern static Boolean32 SetConsoleIcon( HICON icon );

		/// http://msdn.microsoft.com/en-us/library/ms683162(VS.85).aspx
		public extern static CodePageID GetConsoleCP();
		/// http://msdn.microsoft.com/en-us/library/ms686013(VS.85).aspx
		public extern static Boolean32 SetConsoleCP( CodePageID codePageID );

		/// http://msdn.microsoft.com/en-us/library/ms683169(VS.85).aspx
		public extern static CodePageID GetConsoleOutputCP();
		/// http://msdn.microsoft.com/en-us/library/ms686036(VS.85).aspx
		public extern static Boolean32 SetConsoleOutputCP( CodePageID codePageID );

		/// http://msdn.microsoft.com/en-us/library/ms683231(v=vs.85).aspx
		public extern static HANDLE GetStdHandle( StandartIOHandle handle );

		/// http://msdn.microsoft.com/en-us/library/windows/desktop/ms686047(v=vs.85).aspx
		public extern static Boolean32 SetConsoleTextAttribute( HANDLE console, ushort attributes );

		[BackendSymbol( Name = "WriteConsoleA" )]
		public extern static Boolean32 WriteConsole( HANDLE consoleOutput, byte* buffer, uint numberOfCharsToWrite, uint& numberOfCharsWritten, [Unused] void* reserved );
		[BackendSymbol( Name = "WriteConsoleW" )]
		public extern static Boolean32 WriteConsole( HANDLE consoleOutput, char* buffer, uint numberOfCharsToWrite, uint& numberOfCharsWritten, [Unused] void* reserved );

		public extern static Boolean32 GetConsoleMode( HANDLE console, uint& mode );
		/// @}

		/// @{ File management
		public functor void FileIOCompletionRoutine( SystemErrorCode errorCode, uint numberOfBytesTransfered, OVERLAPPED& overlapped );

		[BackendSymbol( Name = "CreateFileA" )]
		public extern static HANDLE CreateFile( CString fileName, FileAccessRights desiredAccess, FileShareMode shareMode, SECURITY_ATTRIBUTES& securityAttributes, FileCreationDisposition creationDisposition, FileCreationFlags flags, HANDLE templateFile );
		[BackendSymbol( Name = "CreateFileW" )]
		public extern static HANDLE CreateFile( CUtf16String fileName, FileAccessRights desiredAccess, FileShareMode shareMode, SECURITY_ATTRIBUTES& securityAttributes, FileCreationDisposition creationDisposition, FileCreationFlags flags, HANDLE templateFile );

		[BackendSymbol( Name = "SetFileAttributesA" )]
		public extern static Boolean32 SetFileAttributes( CString fileName, FileAttribute attributes );
		[BackendSymbol( Name = "SetFileAttributesW" )]
		public extern static Boolean32 SetFileAttributes( CUtf16String fileName, FileAttribute attributes );

		[BackendSymbol( Name = "SetFileAttributesTransactedA" )]
		public extern static Boolean32 SetFileAttributesTransacted( CString fileName, FileAttribute attributes, TransactionHandle transaction );
		[BackendSymbol( Name = "SetFileAttributesTransactedW" )]
		public extern static Boolean32 SetFileAttributesTransacted( CUtf16String fileName, FileAttribute attributes, TransactionHandle transaction );

		[BackendSymbol( Name = "GetFileAttributesA" )]
		public extern static FileAttribute GetFileAttributes( CString fileName );
		[BackendSymbol( Name = "GetFileAttributesW" )]
		public extern static FileAttribute GetFileAttributes( CUtf16String fileName );

		[BackendSymbol( Name = "GetFileAttributesExA" )]
		public extern static Boolean32 GetFileAttributesEx( CString fileName, GET_FILEEX_INFO_LEVELS infoLevelId, void* fileInformation );
		[BackendSymbol( Name = "GetFileAttributesExW" )]
		public extern static Boolean32 GetFileAttributesEx( CUtf16String fileName, GET_FILEEX_INFO_LEVELS infoLevelId, void* fileInformation );

		[BackendSymbol( Name = "GetFileAttributesTransactedA" )]
		public extern static Boolean32 GetFileAttributesTransacted( CString fileName, GET_FILEEX_INFO_LEVELS infoLevelId, void* fileInformation, TransactionHandle transaction );
		[BackendSymbol( Name = "GetFileAttributesTransactedW" )]
		public extern static Boolean32 GetFileAttributesTransacted( CUtf16String fileName, GET_FILEEX_INFO_LEVELS infoLevelId, void* fileInformation, TransactionHandle transaction );

		/// http://msdn.microsoft.com/en-us/library/aa365467(VS.85).aspx
		public extern static Boolean32 ReadFile( HANDLE file, [Out] void* buffer, uint length, [Out] [System.Diagnostics.Optional] uint& readen, [InOut] [System.Diagnostics.Optional] OVERLAPPED& overlapped );
		public extern static Boolean32 ReadFileEx( HANDLE file, [Out] void* buffer, uint length, OVERLAPPED& lpOverlapped, FileIOCompletionRoutine completionRoutine );
		public extern static Boolean32 ReadFileScatter( HANDLE file, FILE_SEGMENT_ELEMENT* segmentArray, uint numberOfBytesToRead, uint& reserved, OVERLAPPED& overlapped );

		/// http://msdn.microsoft.com/en-us/library/aa365747(VS.85).aspx
		public extern static Boolean32 WriteFile( HANDLE file, [In] void* buffer, uint length, [Out] [System.Diagnostics.Optional] uint& written, [InOut] [System.Diagnostics.Optional] OVERLAPPED& overlapped );
		public extern static Boolean32 WriteFileEx( HANDLE file, [In] void* buffer, uint numberOfBytesToWrite, OVERLAPPED& overlapped, FileIOCompletionRoutine completionRoutine );
		public extern static Boolean32 WriteFileGather( HANDLE file, FILE_SEGMENT_ELEMENT* segmentArray, uint numberOfBytesToWrite, uint& reserved, OVERLAPPED& overlapped );

		public extern static Boolean32 FlushFileBuffers( HANDLE file );

		public extern static uint SetFilePointer( HANDLE file, int distanceToMove, int& distanceToMoveHigh, FileSeekOrigin moveMethod );
		public extern static Boolean32 SetFilePointerEx( HANDLE file, long distanceToMove, long& newFilePointer, FileSeekOrigin moveMethod );

		public extern static Boolean32 SetEndOfFile( HANDLE file );

		// [Obsolete]
		// public extern static uint GetFileSize( HANDLE file, int& fileSizeHigh );
		public extern static Boolean32 GetFileSizeEx( HANDLE file, long& fileSize );

		public extern static FileHandleType GetFileType( HANDLE file );

		public functor uint CopyProgressRoutine( long totalFileSize, long totalBytesTransferred, long streamSize, long streamBytesTransferred, uint streamNumber, uint callbackReason, HANDLE sourceFile, HANDLE destinationFile, void* data );

		[BackendSymbol( Name = "CopyFileA" )]
		public extern static Boolean32 CopyFile( CString existingFileName, CString newFileName, Boolean32 failIfExists );
		[BackendSymbol( Name = "CopyFileW" )]
		public extern static Boolean32 CopyFile( CUtf16String existingFileName, CUtf16String newFileName, Boolean32 failIfExists );

		[BackendSymbol( Name = "CopyFileExA" )]
		public extern static Boolean32 CopyFileEx( CString existingFileName, CString newFileName, CopyProgressRoutine progressRoutine, void* data, int& cancel, uint copyFlags );
		[BackendSymbol( Name = "CopyFileExW" )]
		public extern static Boolean32 CopyFileEx( CUtf16String existingFileName, CUtf16String newFileName, CopyProgressRoutine progressRoutine, void* data, int& cancel, uint copyFlags );

		[BackendSymbol( Name = "CopyFileTransactedA" )]
		public extern static Boolean32 CopyFileTransacted( CString existingFileName, CString newFileName, CopyProgressRoutine progressRoutine, void* data, int& cancel, uint copyFlags, TransactionHandle transaction );
		[BackendSymbol( Name = "CopyFileTransactedW" )]
		public extern static Boolean32 CopyFileTransacted( CUtf16String existingFileName, CUtf16String newFileName, CopyProgressRoutine progressRoutine, void* data, int& cancel, uint copyFlags, TransactionHandle transaction );

		[BackendSymbol( Name = "MoveFileA" )]
		public extern static Boolean32 MoveFile( CString existingFileName, CString newFileName );
		[BackendSymbol( Name = "MoveFileW" )]
		public extern static Boolean32 MoveFile( CUtf16String existingFileName, CUtf16String newFileName );

		[BackendSymbol( Name = "MoveFileExA" )]
		public extern static Boolean32 MoveFileEx( CString existingFileName, CString newFileName, uint flags );
		[BackendSymbol( Name = "MoveFileExW" )]
		public extern static Boolean32 MoveFileEx( CUtf16String existingFileName, CUtf16String newFileName, uint flags );

		[BackendSymbol( Name = "MoveFileTransactedA" )]
		public extern static Boolean32 MoveFileTransacted( CString existingFileName, CString newFileName, CopyProgressRoutine progressRoutine, void* data, uint flags, TransactionHandle transaction );
		[BackendSymbol( Name = "MoveFileTransactedW" )]
		public extern static Boolean32 MoveFileTransacted( CUtf16String existingFileName, CUtf16String newFileName, CopyProgressRoutine progressRoutine, void* data, uint flags, TransactionHandle transaction );

		[BackendSymbol( Name = "MoveFileWithProgressA" )]
		public extern static Boolean32 MoveFileWithProgress( CString existingFileName, CString newFileName, CopyProgressRoutine progressRoutine, void* data, uint flags );
		[BackendSymbol( Name = "MoveFileWithProgressW" )]
		public extern static Boolean32 MoveFileWithProgress( CUtf16String existingFileName, CUtf16String newFileName, CopyProgressRoutine progressRoutine, void* data, uint flags );

		[BackendSymbol( Name = "ReplaceFileA" )]
		public extern static Boolean32 ReplaceFile( CString replacedFileName, CString replacementFileName, CString backupFileName, uint replaceFlags, void* exclude, void* reserved );
		[BackendSymbol( Name = "ReplaceFileW" )]
		public extern static Boolean32 ReplaceFile( CUtf16String replacedFileName, CUtf16String replacementFileName, CUtf16String backupFileName, uint replaceFlags, void* exclude, void* reserved );

		public extern static HANDLE ReOpenFile( HANDLE originalFile, uint desiredAccess, uint shareMode, uint flags );

		[BackendSymbol( Name = "DeleteFileA" )]
		public extern static Boolean32 DeleteFile( CString fileName );
		[BackendSymbol( Name = "DeleteFileW" )]
		public extern static Boolean32 DeleteFile( CUtf16String fileName );

		[BackendSymbol( Name = "DeleteFileTransactedA" )]
		public extern static Boolean32 DeleteFileTransacted( CString fileName, TransactionHandle transaction );
		[BackendSymbol( Name = "DeleteFileTransactedW" )]
		public extern static Boolean32 DeleteFileTransacted( CUtf16String fileName, TransactionHandle transaction );

		public extern static Boolean32 LockFile( HANDLE file, uint fileOffsetLow, uint fileOffsetHigh, uint numberOfBytesToLockLow, uint numberOfBytesToLockHigh );
		public extern static Boolean32 LockFileEx( HANDLE file, uint flags, [Unused] uint reserved, uint numberOfBytesToLockLow, uint numberOfBytesToLockHigh, OVERLAPPED& overlapped );

		[BackendSymbol( Name = "FindFirstFileA" )]
		public extern static FindFileHandle FindFirstFile( CString fileName, [Out] WIN32_FIND_DATAA& findFileData );
		[BackendSymbol( Name = "FindFirstFileW" )]
		public extern static FindFileHandle FindFirstFile( CUtf16String fileName, [Out] WIN32_FIND_DATAW& findFileData );

		[BackendSymbol( Name = "FindFirstFileExA" )]
		public extern static FindFileHandle FindFirstFileEx( CString fileName, FINDEX_INFO_LEVELS infoLevelId, [Out] WIN32_FIND_DATAA& findFileData, FINDEX_SEARCH_OPS searchOp, [Unused] void* searchFilter, FindFileFlags additionalFlags );
		[BackendSymbol( Name = "FindFirstFileExW" )]
		public extern static FindFileHandle FindFirstFileEx( CUtf16String fileName, FINDEX_INFO_LEVELS infoLevelId, [Out] WIN32_FIND_DATAW& findFileData, FINDEX_SEARCH_OPS searchOp, [Unused] void* searchFilter, FindFileFlags additionalFlags );

		[BackendSymbol( Name = "FindFirstFileTransactedA" )]
		public extern static FindFileHandle FindFirstFileTransacted( CString fileName, FINDEX_INFO_LEVELS infoLevelId, [Out] WIN32_FIND_DATAA& findFileData, FINDEX_SEARCH_OPS searchOp, [Unused] void* searchFilter, FindFileFlags additionalFlags, TransactionHandle transaction );
		[BackendSymbol( Name = "FindFirstFileTransactedW" )]
		public extern static FindFileHandle FindFirstFileTransacted( CUtf16String fileName, FINDEX_INFO_LEVELS infoLevelId, [Out] WIN32_FIND_DATAW& findFileData, FINDEX_SEARCH_OPS searchOp, [Unused] void* searchFilter, FindFileFlags additionalFlags, TransactionHandle transaction );

		public extern static HANDLE FindFirstStreamW( CUtf16String fileName, STREAM_INFO_LEVELS infoLevel, WIN32_FIND_STREAM_DATA& findStreamData, [Unused] uint flags );
		public extern static HANDLE FindFirstStreamTransactedW( CUtf16String fileName, STREAM_INFO_LEVELS infoLevel, WIN32_FIND_STREAM_DATA& findStreamData, [Unused] uint flags, TransactionHandle transaction );

		[BackendSymbol( Name = "FindNextFileA" )]
		public extern static Boolean32 FindNextFile( FindFileHandle findHandle, WIN32_FIND_DATAA& findFileData );
		[BackendSymbol( Name = "FindNextFileW" )]
		public extern static Boolean32 FindNextFile( FindFileHandle findHandle, WIN32_FIND_DATAW& findFileData );

		// Enumerate hardlinks
		public extern static FindFileNameHandle FindFirstFileNameW( CUtf16String fileName, [Unused] uint flags, uint& stringLength, char* linkName );
		public extern static FindFileNameHandle FindFirstFileNameTransactedW( CUtf16String fileName, [Unused] uint flags, uint& stringLength, char* linkName, TransactionHandle transaction );

		public extern static Boolean32 FindNextFileNameW( FindFileNameHandle findHandle, uint& stringLength, char* linkName );

		public extern static Boolean32 FindNextStreamW( FindFileStreamHandle findHandle, WIN32_FIND_STREAM_DATA& findStreamData );

		public extern static Boolean32 FindClose( FindHandle findHandle );

		public extern static Boolean32 GetOverlappedResult( HANDLE file, OVERLAPPED& overlapped, uint& numberOfBytesTransferred, Boolean32 wait );
		public extern static Boolean32 CancelIo( HANDLE file );
		public extern static Boolean32 CancelIoEx( HANDLE file, OVERLAPPED& overlapped );
		public extern static Boolean32 CancelSynchronousIo( ThreadHandle thread );
		public extern static Boolean32 DeviceIoControl( HANDLE device, uint ioControlCode, void* inBuffer, uint inBufferSize, void* outBuffer, uint outBufferSize, uint& bytesReturned, OVERLAPPED& overlapped );

		[BackendSymbol( Name = "CreateSymbolicLinkA" )]
		public extern static Boolean32 CreateSymbolicLink( CString symlinkFileName, CString targetFileName, uint flags );
		[BackendSymbol( Name = "CreateSymbolicLinkW" )]
		public extern static Boolean32 CreateSymbolicLink( CUtf16String symlinkFileName, CUtf16String targetFileName, uint flags );

		[BackendSymbol( Name = "CreateSymbolicLinkTransactedA" )]
		public extern static Boolean32 CreateSymbolicLinkTransacted( CString symlinkFileName, CString targetFileName, uint flags, TransactionHandle transaction );
		[BackendSymbol( Name = "CreateSymbolicLinkTransactedW" )]
		public extern static Boolean32 CreateSymbolicLinkTransacted( CUtf16String symlinkFileName, CUtf16String targetFileName, uint flags, TransactionHandle transaction );

		[BackendSymbol( Name = "CreateHardLinkA" )]
		public extern static Boolean32 CreateHardLink( CString fileName, CString existingFileName, SECURITY_ATTRIBUTES& securityAttributes );
		[BackendSymbol( Name = "CreateHardLinkW" )]
		public extern static Boolean32 CreateHardLink( CUtf16String fileName, CUtf16String existingFileName, SECURITY_ATTRIBUTES& securityAttributes );

		[BackendSymbol( Name = "CreateHardLinkTransactedA" )]
		public extern static Boolean32 CreateHardLinkTransacted( CString lpFileName, CString lpExistingFileName, SECURITY_ATTRIBUTES& securityAttributes, TransactionHandle transaction );
		[BackendSymbol( Name = "CreateHardLinkTransactedW" )]
		public extern static Boolean32 CreateHardLinkTransacted( CUtf16String lpFileName, CUtf16String lpExistingFileName, SECURITY_ATTRIBUTES& securityAttributes, TransactionHandle transaction );

		/// @}

		/// @{ Ptr check
		public extern static Boolean32 IsBadCodePtr( void* function );
		public extern static Boolean32 IsBadReadPtr( void* ptr, uintptr length );
		[BackendSymbol( Name = "IsBadStringPtrA" )]
		public extern static Boolean32 IsBadStringPtr( CString ptr, uintptr length );
		[BackendSymbol( Name = "IsBadStringPtrW" )]
		public extern static Boolean32 IsBadStringPtr( CUtf16String ptr, uintptr length );
		public extern static Boolean32 IsBadWritePtr( void* ptr, uintptr length );

		/// @}

		/// @{ Memory-mapped files
		[BackendSymbol( Name = "CreateFileMappingA" )]
		public extern static FileMappingHandle CreateFileMapping( HANDLE file, SECURITY_ATTRIBUTES& attributes, FileMappingCreateFlags flags, uint maximumSizeHigh, uint maximumSizeLow, CString name );
		[BackendSymbol( Name = "CreateFileMappingW" )]
		public extern static FileMappingHandle CreateFileMapping( HANDLE file, SECURITY_ATTRIBUTES& attributes, FileMappingCreateFlags flags, uint maximumSizeHigh, uint maximumSizeLow, CUtf16String name );

		[BackendSymbol( Name = "CreateFileMappingNumaA" )]
		public extern static FileMappingHandle CreateFileMappingNuma( HANDLE file, SECURITY_ATTRIBUTES& attributes, FileMappingCreateFlags flags, uint maximumSizeHigh, uint maximumSizeLow, CString name, uint preferredNode );
		[BackendSymbol( Name = "CreateFileMappingNumaW" )]
		public extern static FileMappingHandle CreateFileMappingNuma( HANDLE file, SECURITY_ATTRIBUTES& attributes, FileMappingCreateFlags flags, uint maximumSizeHigh, uint maximumSizeLow, CUtf16String name, uint preferredNode );

		public extern static void* MapViewOfFile( FileMappingHandle mapping, FileMappingAccessRights desiredAccess, uint fileOffsetHigh, uint fileOffsetLow, uintptr numberOfBytesToMap );
		public extern static void* MapViewOfFileEx( FileMappingHandle mapping, FileMappingAccessRights desiredAccess, uint fileOffsetHigh, uint fileOffsetLow, uintptr numberOfBytesToMap, void* baseAddress );
		public extern static void* MapViewOfFileExNuma( FileMappingHandle mapping, FileMappingAccessRights desiredAccess, uint fileOffsetHigh, uint fileOffsetLow, uintptr numberOfBytesToMap, void* baseAddress, uint preferredNode );

		[BackendSymbol( Name = "OpenFileMappingA" )]
		public extern static FileMappingHandle OpenFileMapping( FileMappingAccessRights desiredAccess, Boolean32 inheritHandle, CString name );
		[BackendSymbol( Name = "OpenFileMappingW" )]
		public extern static FileMappingHandle OpenFileMapping( FileMappingAccessRights desiredAccess, Boolean32 inheritHandle, CUtf16String name );

		[BackendSymbol( Name = "K32GetMappedFileNameA" )]
		public extern static uint GetMappedFileName( ProcessHandle process, void* address, byte* filename, uint size );
		[BackendSymbol( Name = "K32GetMappedFileNameW" )]
		public extern static uint GetMappedFileName( ProcessHandle process, void* address, char* filename, uint size );

		public extern static Boolean32 FlushViewOfFile( void* baseAddress, uintptr numberOfBytesToFlush );
		public extern static Boolean32 UnmapViewOfFile( void* baseAddress );
		/// @}

		/// @{ Virtual Memory
		public extern static void* VirtualAlloc( void* address, uintptr size, VirtualAllocFlags allocationType, PageProtectionFlags protect );
		public extern static void* VirtualAllocEx( ProcessHandle process, void* address, uintptr size, VirtualAllocFlags allocationType, PageProtectionFlags protect );
		public extern static void* VirtualAllocExNuma( ProcessHandle process, void* address, uintptr size, VirtualAllocFlags allocationType, PageProtectionFlags protect, uint preferredNode );
		public extern static Boolean32 VirtualFree( void* address, uintptr size, VirtualFreeType freeType );
		public extern static Boolean32 VirtualFreeEx( ProcessHandle process, void* address, uintptr size, VirtualFreeType freeType );
		public extern static Boolean32 VirtualLock( void* address, uintptr size );
		public extern static Boolean32 VirtualProtect( void* address, uintptr size, PageProtectionFlags newProtect, PageProtectionFlags& oldProtect );
		public extern static Boolean32 VirtualProtectEx( ProcessHandle process, void* address, uintptr size, PageProtectionFlags newProtect, PageProtectionFlags& oldProtect );
		public extern static uintptr VirtualQuery( void* address, MEMORY_BASIC_INFORMATION& buffer, uintptr length );
		public extern static uintptr VirtualQueryEx( ProcessHandle process, void* address, MEMORY_BASIC_INFORMATION& buffer, uintptr length );
		public extern static Boolean32 VirtualUnlock( void* address, uintptr size );
		/// @}

		/// @{ Synchronization
		public functor void APCProc( uintptr parameter );
		public extern static uint QueueUserAPC( APCProc callback, HANDLE thread, uintptr data );

		public extern static void InitializeCriticalSection( [Out] CRITICAL_SECTION& value );
		public extern static void EnterCriticalSection( CRITICAL_SECTION& value );
		public extern static void LeaveCriticalSection( CRITICAL_SECTION& value );
		public extern static void DeleteCriticalSection( CRITICAL_SECTION& value );
		public extern static Boolean32 InitializeCriticalSectionAndSpinCount( [Out] CRITICAL_SECTION& value, uint spinCount );
		public extern static Boolean32 InitializeCriticalSectionEx( [Out] CRITICAL_SECTION& value, uint spinCount, CriticalSectionInitializeFlags flags );
		public extern static uint SetCriticalSectionSpinCount( CRITICAL_SECTION& value, uint spinCount );
		public extern static Boolean32 TryEnterCriticalSection( CRITICAL_SECTION& value );

		[BackendSymbol( Name = "CreateEventA" )]
		public extern static EventHandle CreateEvent( SECURITY_ATTRIBUTES& attributes, Boolean32 manualReset, Boolean32 initialState, CString name );
		[BackendSymbol( Name = "CreateEventW" )]
		public extern static EventHandle CreateEvent( SECURITY_ATTRIBUTES& attributes, Boolean32 manualReset, Boolean32 initialState, CUtf16String name );
		[BackendSymbol( Name = "CreateEventExA" )]
		public extern static EventHandle CreateEventEx( SECURITY_ATTRIBUTES& attributes, CString name, uint flags, EventAccessRights desiredAccess );
		[BackendSymbol( Name = "CreateEventExW" )]
		public extern static EventHandle CreateEventEx( SECURITY_ATTRIBUTES& attributes, CUtf16String name, uint flags, EventAccessRights desiredAccess );
		[BackendSymbol( Name = "OpenEventA" )]
		public extern static EventHandle OpenEvent( EventAccessRights desiredAccess, Boolean32 inheritHandle, CString name );
		[BackendSymbol( Name = "OpenEventW" )]
		public extern static EventHandle OpenEvent( EventAccessRights desiredAccess, Boolean32 inheritHandle, CUtf16String name );
		public extern static Boolean32 ResetEvent( EventHandle value );
		public extern static Boolean32 SetEvent( EventHandle value );

		// [Obsolete( Message = "unreliable, retained for compatibility" )]
		// public extern static Boolean32 PulseEvent( EventHandle value );

		[BackendSymbol( Name = "CreateMutexA" )]
		public extern static MutexHandle CreateMutex( SECURITY_ATTRIBUTES& attributes, Boolean32 initialOwner, CString name );
		[BackendSymbol( Name = "CreateMutexW" )]
		public extern static MutexHandle CreateMutex( SECURITY_ATTRIBUTES& attributes, Boolean32 initialOwner, CUtf16String name );
		[BackendSymbol( Name = "CreateMutexExA" )]
		public extern static MutexHandle CreateMutexEx( SECURITY_ATTRIBUTES& attributes, CString name, MutexCreateFlags flags, MutexAccessRights desiredAccess );
		[BackendSymbol( Name = "CreateMutexExW" )]
		public extern static MutexHandle CreateMutexEx( SECURITY_ATTRIBUTES& attributes, CUtf16String name, MutexCreateFlags flags, MutexAccessRights desiredAccess );
		[BackendSymbol( Name = "OpenMutexA" )]
		public extern static MutexHandle OpenMutex( MutexAccessRights desiredAccess, Boolean32 inheritHandle, CString name );
		[BackendSymbol( Name = "OpenMutexW" )]
		public extern static MutexHandle OpenMutex( MutexAccessRights desiredAccess, Boolean32 inheritHandle, CUtf16String name );
		public extern static Boolean32 ReleaseMutex( MutexHandle value );

		[BackendSymbol( Name = "CreateSemaphoreA" )]
		public extern static SemaphoreHandle CreateSemaphore( SECURITY_ATTRIBUTES& attributes, int initialCount, int maximumCount, CString name );
		[BackendSymbol( Name = "CreateSemaphoreW" )]
		public extern static SemaphoreHandle CreateSemaphore( SECURITY_ATTRIBUTES& attributes, int initialCount, int maximumCount, CUtf16String name );
		[BackendSymbol( Name = "CreateSemaphoreExA" )]
		public extern static SemaphoreHandle CreateSemaphoreEx( SECURITY_ATTRIBUTES& attributes, int initialCount, int maximumCount, CString name, [Unused] uint flags, SemaphoreAccessRights desiredAccess );
		[BackendSymbol( Name = "CreateSemaphoreExW" )]
		public extern static SemaphoreHandle CreateSemaphoreEx( SECURITY_ATTRIBUTES& attributes, int initialCount, int maximumCount, CUtf16String name, [Unused] uint flags, SemaphoreAccessRights desiredAccess );
		[BackendSymbol( Name = "OpenSemaphoreA" )]
		public extern static SemaphoreHandle OpenSemaphore( SemaphoreAccessRights dwDesiredAccess, Boolean32 inheritHandle, CString name );
		[BackendSymbol( Name = "OpenSemaphoreW" )]
		public extern static SemaphoreHandle OpenSemaphore( SemaphoreAccessRights dwDesiredAccess, Boolean32 inheritHandle, CUtf16String name );
		[BackendSymbol( Name = "ReleaseSemaphore" )]
		public extern static Boolean32 ReleaseSemaphore( SemaphoreHandle value, int releaseCount, int& previousCount );

		public extern static void InitializeSRWLock( [Out] SRWLOCK& lock );
		public extern static void AcquireSRWLockExclusive( SRWLOCK& lock );
		public extern static void AcquireSRWLockShared( SRWLOCK& lock );
		public extern static void ReleaseSRWLockExclusive( SRWLOCK& lock );
		public extern static void ReleaseSRWLockShared( SRWLOCK& lock );
		public extern static Boolean32 TryAcquireSRWLockShared( SRWLOCK& lock );
		public extern static Boolean32 TryAcquireSRWLockExclusive( SRWLOCK& lock );

		public extern static void InitializeConditionVariable( [Out] CONDITION_VARIABLE& @this );
		public extern static Boolean32 SleepConditionVariableCS( CONDITION_VARIABLE& @this, CRITICAL_SECTION& criticalSection, uint milliseconds );
		public extern static Boolean32 SleepConditionVariableSRW( CONDITION_VARIABLE& @this, SRWLOCK& lock, uint milliseconds, ConditionVariablesSleepSRWFlags flags );
		public extern static void WakeAllConditionVariable( CONDITION_VARIABLE& @this );
		public extern static void WakeConditionVariable( CONDITION_VARIABLE& @this );

		public functor void TimerAPCProc( void* argToCompletionRoutine, uint timerLowValue, uint timerHighValue );
		[BackendSymbol( Name = "CreateWaitableTimerExA" )]
		public extern static WaitableTimerHandle CreateWaitableTimerEx( SECURITY_ATTRIBUTES& timerAttributes, CString timerName, WaitableTimerCreateFlags flags, TimerAccessRights desiredAccess );
		[BackendSymbol( Name = "CreateWaitableTimerExW" )]
		public extern static WaitableTimerHandle CreateWaitableTimerEx( SECURITY_ATTRIBUTES& timerAttributes, CUtf16String timerName, WaitableTimerCreateFlags flags, TimerAccessRights desiredAccess );
		[BackendSymbol( Name = "OpenWaitableTimerA" )]
		public extern static WaitableTimerHandle OpenWaitableTimer( TimerAccessRights desiredAccess, Boolean32 inheritHandle, CString timerName );
		[BackendSymbol( Name = "OpenWaitableTimerW" )]
		public extern static WaitableTimerHandle OpenWaitableTimer( TimerAccessRights desiredAccess, Boolean32 inheritHandle, CUtf16String timerName );
		public extern static Boolean32 SetWaitableTimer( WaitableTimerHandle timer, long& dueTime, int period, TimerAPCProc completionRoutine, void* argToCompletionRoutine, Boolean32 resume );
		public extern static Boolean32 SetWaitableTimerEx( WaitableTimerHandle timer, long& dueTime, int period, TimerAPCProc completionRoutine, void* argToCompletionRoutine, REASON_CONTEXT& wakeContext, uint tolerableDelay );

		public functor void WaitOrTimerCallback( void* parameter, Boolean32 timerOrWaitFired );
		public extern static TimerQueueHandle CreateTimerQueue();
		public extern static Boolean32 ChangeTimerQueueTimer( TimerQueueHandle timerQueue, TimerQueueTimerHandle timer, uint dueTime, uint period );
		public extern static Boolean32 CreateTimerQueueTimer( TimerQueueTimerHandle& newTimer, TimerQueueHandle timerQueue, WaitOrTimerCallback callback, void* parameter, uint DueTime, uint Period, uint Flags );
		public extern static Boolean32 DeleteTimerQueue( TimerQueueHandle timerQueue );
		public extern static Boolean32 DeleteTimerQueueEx( TimerQueueHandle timerQueue, HANDLE completionEvent );
		public extern static Boolean32 DeleteTimerQueueTimer( TimerQueueHandle timerQueue, TimerQueueTimerHandle timer, HANDLE completionEvent );

		public extern static uint WaitForSingleObject( HANDLE handle, uint milliseconds );
		public extern static uint WaitForSingleObjectEx( HANDLE handle, uint milliseconds, Boolean32 alertable );
		public extern static uint WaitForMultipleObjectsEx( uint count, HANDLE* handles, Boolean32 waitAll, uint milliseconds, Boolean32 alertable );
		public extern static uint WaitForMultipleObjects( uint count, HANDLE* handles, Boolean32 waitAll, uint milliseconds );
		public extern static uint SignalObjectAndWait( HANDLE objectToSignal, HANDLE objectToWaitOn, uint milliseconds, Boolean32 alertable );

		public static uint WaitForMultipleObjects( Boolean32 waitAll, uint milliseconds, vararg HANDLE handles ) { return WaitForMultipleObjects( handles.Length, handles, waitAll, milliseconds ); }
		public static uint WaitForMultipleObjectsEx( Boolean32 waitAll, uint milliseconds, Boolean32 alertable, vararg HANDLE handles ) { return WaitForMultipleObjectsEx( handles.Length, handles, waitAll, milliseconds, alertable ); }

		/// http://msdn.microsoft.com/en-us/library/ms685061(VS.85).aspx
		public extern static Boolean32 RegisterWaitForSingleObject( RegisteredWaitHandle& waitHandle, HANDLE object, WaitOrTimerCallback callback, void* context, uint milliseconds, RegisterWaitFlags flags );
		public extern static RegisteredWaitHandle RegisterWaitForSingleObjectEx( HANDLE object, WaitOrTimerCallback callback, void* context, uint milliseconds, RegisterWaitFlags flags );

		public extern static Boolean32 UnregisterWait( RegisteredWaitHandle waitHandle );
		public extern static Boolean32 UnregisterWaitEx( RegisteredWaitHandle waitHandle, HANDLE completionEvent );

		public functor Boolean32 InitOnceCallback( INIT_ONCE& initOnce, void* parameter, void*& context );
		public extern static Boolean32 InitOnceBeginInitialize( INIT_ONCE& initOnce, InitOnceBeginFlags flags, int& isPending, void*& context );
		public extern static Boolean32 InitOnceExecuteOnce( INIT_ONCE& initOnce, InitOnceCallback initFn, void* Parameter, void*& context );
		public extern static Boolean32 InitOnceComplete( INIT_ONCE& initOnce, InitOnceCompleteFlags dwFlags, void* context );

		/// @}

		/// @{ Time
		public extern static uint GetTickCount();
		public extern static ulong GetTickCount64();
		public extern static Boolean32 QueryUnbiasedInterruptTime( ulong& unbiasedTime );

		public extern static void GetSystemTime( [Out] SYSTEMTIME& systemTime );
		public extern static Boolean32 SetSystemTime( [In] SYSTEMTIME& systemTime );

		public extern static void GetLocalTime( [Out] SYSTEMTIME& systemTime );
		public extern static Boolean32 SetLocalTime( [In] SYSTEMTIME& systemTime );

		public extern static Boolean32 GetFileTime( HANDLE file, [Out] FILETIME& creationTime, [Out] FILETIME& lastAccessTime, [Out] FILETIME& lastWriteTime );
		public extern static Boolean32 SetFileTime( HANDLE file, [In] FILETIME& creationTime, [In] FILETIME& lastAccessTime, [In] FILETIME& lastWriteTime );

		public extern static Boolean32 FileTimeToSystemTime( [In] FILETIME& fileTime, [Out] SYSTEMTIME& systemTime );
		public extern static Boolean32 FileTimeToLocalFileTime( [In] FILETIME& fileTime, [Out] SYSTEMTIME& systemTime );

		public extern static void GetSystemTimeAsFileTime( [Out] FILETIME& systemTimeAsFileTime );

		public extern static Boolean32 LocalFileTimeToFileTime( [In] FILETIME& localFileTime, [Out] FILETIME& fileTime );
		public extern static Boolean32 SystemTimeToFileTime( [In] SYSTEMTIME& systemTime, [Out] FILETIME& fileTime );

		public extern static int CompareFileTime( [In] FILETIME& fileTime1, [In] FILETIME& fileTime2 );

		public extern static Boolean32 QueryPerformanceCounter( ulong& value );
		public extern static Boolean32 QueryPerformanceFrequency( ulong& value );

		/// @}

		/// @{ DLLs
		[BackendSymbol( Name = "SetDllDirectoryA" )]
		public extern static Boolean32 SetDllDirectory( CString path );
		[BackendSymbol( Name = "SetDllDirectoryW" )]
		public extern static Boolean32 SetDllDirectory( CUtf16String path );

		public extern static void* GetProcAddress( HMODULE module, CString name );
		public extern static uint LoadModule( CString moduleName, void* parameterBlock );

		[BackendSymbol( Name = "LoadLibraryA" )]
		public extern static HMODULE LoadLibrary( CString fileName );
		[BackendSymbol( Name = "LoadLibraryW" )]
		public extern static HMODULE LoadLibrary( CUtf16String fileName );

		[BackendSymbol( Name = "GetDllDirectoryA" )]
		public extern static uint GetDllDirectory( uint bufferLength, byte* buffer );
		[BackendSymbol( Name = "GetDllDirectoryW" )]
		public extern static uint GetDllDirectory( uint bufferLength, char* buffer );

		public extern static Boolean32 FreeLibrary( HMODULE module );

		public extern static void FreeLibraryAndExitThread( HMODULE module, uint exitCode );
		public extern static Boolean32 DisableThreadLibraryCalls( HMODULE module );

		[BackendSymbol( Name = "GetModuleFileNameA" )]
		public extern static uint GetModuleFileName( HMODULE module, byte* filename, uint size );
		[BackendSymbol( Name = "GetModuleFileNameW" )]
		public extern static uint GetModuleFileName( HMODULE module, char* filename, uint size );

		[BackendSymbol( Name = "GetModuleHandleA" )]
		public extern static HMODULE GetModuleHandle( CString moduleName );
		[BackendSymbol( Name = "GetModuleHandleW" )]
		public extern static HMODULE GetModuleHandle( CUtf16String moduleName );
		/// @}

		/// @{ Stats
		public extern static Boolean32 GetProcessWorkingSetSize( ProcessHandle process, uintptr& minimumWorkingSetSize, uintptr& maximumWorkingSetSize );
		public extern static uint GetMaximumProcessorCount( ushort GroupNumber );
		public extern static ushort GetMaximumProcessorGroupCount();
		public extern static uint GetCurrentProcessorNumber();
		public extern static void GetCurrentProcessorNumberEx( PROCESSOR_NUMBER& processorNumber );

		public extern static CString GetEnvironmentStringsA();
		public extern static CUtf16String GetEnvironmentStringsW();

		[BackendSymbol( Name = "GetEnvironmentVariableA" )]
		public extern static uint GetEnvironmentVariable( CString name, byte* buffer, uint size );
		[BackendSymbol( Name = "GetEnvironmentVariableW" )]
		public extern static uint GetEnvironmentVariable( CUtf16String name, char* buffer, uint size );

		public extern static Boolean32 GetProcessHandleCount( ProcessHandle process, uint& handleCount );
		public extern static Boolean32 GetProcessIoCounters( ProcessHandle process, [Out] IO_COUNTERS& ioCounters );
		[BackendSymbol( Name = "GetStartupInfoA" )]
		public extern static void GetStartupInfo( STARTUPINFOA startupInfo );
		[BackendSymbol( Name = "GetStartupInfoW" )]
		public extern static void GetStartupInfo( STARTUPINFOW startupInfo );

		public extern static Boolean32 GetThreadTimes( ThreadHandle thread, FILETIME& creationTime, FILETIME& exitTime, FILETIME& kernelTime, FILETIME& userTime );
		public extern static Boolean32 QueryThreadCycleTime( ThreadHandle thread, ulong& result );
		/// @}

		/// @{ Processes
		[BackendSymbol( Name = "CreateProcessA" )]
		public extern static Boolean32 CreateProcess( CString path, CString commandLine, SECURITY_ATTRIBUTES& processAttributes, SECURITY_ATTRIBUTES& threadAttributes, Boolean32 inheritHandles, uint dwCreationFlags, void* environment, CString currentDirectory, STARTUPINFOA& startupInfo, PROCESS_INFORMATION& processInformation );
		[BackendSymbol( Name = "CreateProcessW" )]
		public extern static Boolean32 CreateProcess( CUtf16String path, CUtf16String commandLine, SECURITY_ATTRIBUTES& processAttributes, SECURITY_ATTRIBUTES& threadAttributes, Boolean32 inheritHandles, uint dwCreationFlags, void* environment, CUtf16String currentDirectory, STARTUPINFOW& startupInfo, PROCESS_INFORMATION& processInformation );

		public extern static ProcessHandle OpenProcess( ProcessAccessRights desiredAccess, Boolean32 inheritHandle, uint processId );

		public extern static ProcessHandle GetCurrentProcess();
		public extern static uint GetCurrentProcessId();
		public extern static uint GetProcessId( ProcessHandle process );
		public extern static uint GetProcessIdOfThread( ThreadHandle thread );

		public extern static void ExitProcess( uint exitCode );
		public extern static Boolean32 TerminateProcess( ProcessHandle process, uint exitCode );
		public extern static Boolean32 GetExitCodeProcess( ProcessHandle process, uint& exitCode );

		public extern static ProcessPriorityClass GetPriorityClass( ProcessHandle process );
		public extern static Boolean32 SetPriorityClass( ProcessHandle process, ProcessPriorityClass value );

		public extern static Boolean32 GetProcessAffinityMask( ProcessHandle process, uintptr& processAffinityMask, uintptr& systemAffinityMask );
		public extern static Boolean32 GetProcessGroupAffinity( ProcessHandle process, ushort& groupCount, ushort* groupArray );

		public extern static Boolean32 QueryProcessCycleTime( ProcessHandle process, ulong& result );
		public extern static Boolean32 QueryIdleProcessorCycleTime( uint& bufferLength, ulong* processorIdleCycleTime );
		public extern static Boolean32 GetProcessTimes( ProcessHandle process, FILETIME& creationTime, FILETIME& exitTime, TimeSpan& kernelTime, TimeSpan& userTime );

		public extern static uint GetProcessVersion( uint processId );

		public extern static void FlushProcessWriteBuffers();


		/// @{ From PSAPI
		public extern static Boolean32 K32EmptyWorkingSet( ProcessHandle process );
		public extern static Boolean32 K32EnumProcesses( uint* processIds, uint byteCount, uint* bytesReturned );
		public extern static Boolean32 K32GetProcessMemoryInfo( ProcessHandle process, PROCESS_MEMORY_COUNTERS_EX& counters, uint countersSize );

		/// @}

		/// @}

		/// @{ Threads
		public extern static ThreadHandle GetCurrentThread();
		public extern static uint GetCurrentThreadId();
		public extern static uint GetThreadId( ThreadHandle thread );
		public extern static ThreadHandle OpenThread( ThreadAccessRights desiredAccess, Boolean32 inheritHandle, uint threadId );

		public functor uint ThreadProc( void* parameter );
		public extern static ThreadHandle CreateThread( SECURITY_ATTRIBUTES& threadAttributes, uintptr stackSize, ThreadProc startAddress, void* parameter, CreateThreadFlags flags, uint& threadId );
		// public extern static ThreadHandle CreateRemoteThread( ProcessHandle process, SECURITY_ATTRIBUTES& threadAttributes, uintptr stackSize, ThreadProc startAddress, void* parameter, uint creationFlags, uint& threadId );
		// public extern static ThreadHandle CreateRemoteThreadEx( ProcessHandle process, SECURITY_ATTRIBUTES& threadAttributes, uintptr stackSize, ThreadProc startAddress, void* parameter, uint creationFlags, LPPROC_THREAD_ATTRIBUTE_LIST attributeList, uint& threadId );

		public extern static ThreadPriority GetThreadPriority( ThreadHandle thread );
		public extern static Boolean32 SetThreadPriority( ThreadHandle thread, ThreadPriority value );

		public extern static uint ResumeThread( ThreadHandle thread );
		public extern static uint SuspendThread( ThreadHandle thread );

		public extern static Boolean32 SwitchToThread();
		public extern static void ExitThread( uint exitCode );
		public extern static Boolean32 TerminateThread( ThreadHandle thread, uint exitCode );
		public extern static Boolean32 GetExitCodeThread( ThreadHandle thread, uint& exitCode );

		public extern static void Sleep( uint milliseconds );
		public extern static uint SleepEx( uint milliseconds, Boolean32 alertable );

		public extern static ThreadErrorMode GetThreadErrorMode();
		public extern static Boolean32 SetThreadErrorMode( ThreadErrorMode newMode, ThreadErrorMode& oldMode );

		public extern static uint TlsAlloc();
		public extern static Boolean32 TlsFree( uint tlsIndex );
		public extern static void* TlsGetValue( uint tlsIndex );
		public extern static Boolean32 TlsSetValue( uint tlsIndex, void* tlsValue );

		/// @{ Thread pool
		public extern static Boolean32 QueueUserWorkItem( ThreadProc function, void* context, uint flags );

		public extern static ThreadPoolHandle CreateThreadpool( void* reserved = null );
		public extern static void CloseThreadpool( ThreadPoolHandle pool );

		public extern static void SetThreadpoolThreadMaximum( ThreadPoolHandle pool, uint max );
		public extern static void SetThreadpoolThreadMinimum( ThreadPoolHandle pool, uint min );

		public extern static ThreadPoolCleanupGroupHandle CreateThreadpoolCleanupGroup();
		public extern static void CloseThreadpoolCleanupGroup( ThreadPoolCleanupGroupHandle handle );

		/// @}
		/// @}

		/// @{ Fibers
		public functor void FiberProc( void* parameter );
		public functor void FlsCallback( void* flsData );

		public extern static FiberHandle ConvertThreadToFiber( void* parameter );
		public extern static Boolean32 ConvertFiberToThread();

		public extern static FiberHandle CreateFiber( uintptr stackSize, FiberProc startAddress, void* parameter );
		public extern static FiberHandle CreateFiberEx( uintptr stackCommitSize, uintptr stackReserveSize, uint flags, FiberProc startAddress, void* parameter );

		public extern static void SwitchToFiber( FiberHandle fiber );
		public extern static void DeleteFiber( FiberHandle fiber );

		public extern static uint FlsAlloc( FlsCallback callback );
		public extern static Boolean32 FlsFree( uint flsIndex );
		public extern static void* FlsGetValue( uint flsIndex );
		public extern static Boolean32 FlsSetValue( uint flsIndex, void* flsData );
		/// @}

		/// @{ IO completion ports

		// create or assign IOCP
		// Listen notifications from:
		//	 ConnectNamedPipe
		//	 DeviceIoControl
		//	 LockFileEx
		//	 ReadDirectoryChangesW
		//	 ReadFile / WriteFile
		//	 TransactNamedPipe
		//	 WaitCommEvent
		//   WSASendMsg / WSASendTo / WSASend / WSARecvFrom / WSARecvMsg / WSARecv
		public extern static IoCompletionPortHandle CreateIoCompletionPort( HANDLE fileHandle, IoCompletionPortHandle existingCompletionPort, uintptr completionKey, uint numberOfConcurrentThreads );

		public extern static Boolean32 BindIoCompletionCallback( HANDLE fileHandle, FileIOCompletionRoutine Function, uint Flags );
		public extern static Boolean32 GetQueuedCompletionStatus( IoCompletionPortHandle completionPort, uint& numberOfBytes, uintptr completionKey, OVERLAPPED*& overlapped, uint dwMilliseconds );
		public extern static Boolean32 GetQueuedCompletionStatusEx( IoCompletionPortHandle completionPort, OVERLAPPED_ENTRY* overlappedEntries, uint count, uint& numEntriesRemoved, uint milliseconds, Boolean32 alertable );
		public extern static Boolean32 PostQueuedCompletionStatus( IoCompletionPortHandle completionPort, uint numberOfBytesTransferred, uintptr cCompletionKey, OVERLAPPED& overlapped );
		/// @}

		/// @{ Mailslots
		[BackendSymbol( Name = "CreateMailslotA" )]
		public extern static MailslotHandle CreateMailslot( CString name, uint maxMessageSize, uint readTimeout, SECURITY_ATTRIBUTES& securityAttributes );
		[BackendSymbol( Name = "CreateMailslotW" )]
		public extern static MailslotHandle CreateMailslot( CUtf16String name, uint maxMessageSize, uint readTimeout, SECURITY_ATTRIBUTES& securityAttributes );

		public extern static Boolean32 GetMailslotInfo( MailslotHandle mailslot, [Out] uint& maxMessageSize, [Out] uint& nextSize, [Out] uint& messageCount, [Out] uint& readTimeout );
		public extern static Boolean32 SetMailslotInfo( MailslotHandle mailslot, uint readTimeout );
		/// @}

		// [Obsolete]
		// public extern static uint GetVersion();
		[BackendSymbol( Name = "GetVersionExA" )]
		public extern static Boolean32 GetVersionEx( OSVERSIONINFOA& versionInfo );
		[BackendSymbol( Name = "GetVersionExW" )]
		public extern static Boolean32 GetVersionEx( OSVERSIONINFOW& versionInfo );

		public extern static Boolean32 GetCommTimeouts( HANDLE hFile, COMMTIMEOUTS* lpCommTimeouts );
		public extern static Boolean32 SetCommTimeouts( HANDLE hFile, COMMTIMEOUTS* lpCommTimeouts );

		public extern static Boolean32 GetCommState( HANDLE hFile, DCB* lpDCB );
		public extern static Boolean32 SetCommState( HANDLE hFile, DCB* lpDCB );

		[BackendSymbol( Name = "GetDefaultCommConfigW" )]
		public extern static Boolean32 GetDefaultCommConfig( CUtf16String lpszName, COMMCONFIG& lpCC, uint& lpdwSize );

		public functor Boolean32 PIMAGE_TLS_CALLBACK( HANDLE moduleHandle, uint reason, void* reserved );

		public extern static void GetSystemInfo( SYSTEM_INFO* lpSystemInfo );

		[BackendSymbol( Name = "FormatMessageW" )]
		public extern static int FormatMessage( int dwFlags, void* lpSource, int dwMessageId, int dwLanguageId, char* lpBuffer, int nSize, void* va_list_arguments );

		public extern static int GetFinalPathNameByHandleW( HANDLE handle, char* path, int bufLen, int flags );

		public static string GetFinalPath( HANDLE handle ) {
			var len = GetFinalPathNameByHandleW( handle, null, 0, 0 );
			if( len <= 0 ) return "";

			var path = new[len] char;
			GetFinalPathNameByHandleW( handle, &path[0], len, 0 );

			if( len > 4 && path[0] == '\\' && path[1] == '\\' && path[2] == '?' && path[3] == '\\' )
				return string.FromUtf16( &path[4], ( uint )( len - 4 - 1 ) );

			return string.FromUtf16( &path[0], ( uint )( len - 1 ) );
		}

		public static string GetLastErrorMessage( SystemErrorCode errorCode ) {
			using( var page = Memory.CachedPages.PopScoped() ) {
				var buffer = ( char* ) page.Value;
				var bufferLength = ( int )( Memory.DefaultPageSize / sizeof( char ) );

				var resultLength = FormatMessage( 0x3200, null, ( int ) errorCode, 0, buffer, bufferLength, null );
				if( resultLength != 0 ) {
					if( resultLength >= 2 && buffer[resultLength - 2] == '\r' && buffer[resultLength - 1] == '\n' ) resultLength -= 2;
					return string.FromUtf16( buffer, ( uint ) resultLength );
				}
			}

			return "Unknown error";
		}
	}

	[ExplicitSize( Size = 28 )]
	[Alignment( Boundary = 4 )]
	public partial struct DCB : IFormattable {
		public DCB() {
			DCBlength = sizeof( DCB );
		}

		[ExplicitOffset( Offset = 0 )]
		public uint DCBlength;
		[ExplicitOffset( Offset = 4 )]
		public uint BaudRate;
		public bool fBinary { get { return ( cast<byte*>( &this )[8] & 1 ) != 0; } set { cast<byte*>( &this )[8] &= 254; cast<byte*>( &this )[8] |= cast<byte>( value ) << 0; } }
		public bool fParity { get { return ( cast<byte*>( &this )[8] & 2 ) != 0; } set { cast<byte*>( &this )[8] &= 253; cast<byte*>( &this )[8] |= cast<byte>( value ) << 1; } }
		public bool fOutxCtsFlow { get { return ( cast<byte*>( &this )[8] & 4 ) != 0; } set { cast<byte*>( &this )[8] &= 251; cast<byte*>( &this )[8] |= cast<byte>( value ) << 2; } }
		public bool fOutxDsrFlow { get { return ( cast<byte*>( &this )[8] & 8 ) != 0; } set { cast<byte*>( &this )[8] &= 247; cast<byte*>( &this )[8] |= cast<byte>( value ) << 3; } }
		public DtrControl fDtrControl { get { return cast<DtrControl>( cast<byte*>( &this )[8] >> 4 & 3 ); } set { cast<byte*>( &this )[8] &= 207; cast<byte*>( &this )[8] |= ( cast<byte>( value.Value() ) << 4 & 48 ); } }
		public bool fDsrSensitivity { get { return ( cast<byte*>( &this )[8] & 64 ) != 0; } set { cast<byte*>( &this )[8] &= 191; cast<byte*>( &this )[8] |= cast<byte>( value ) << 6; } }
		public bool fTXContinueOnXoff { get { return ( cast<byte*>( &this )[8] & 128 ) != 0; } set { cast<byte*>( &this )[8] &= 127; cast<byte*>( &this )[8] |= cast<byte>( value ) << 7; } }
		public bool fOutX { get { return ( cast<byte*>( &this )[9] & 1 ) != 0; } set { cast<byte*>( &this )[9] &= 254; cast<byte*>( &this )[9] |= cast<byte>( value ) << 0; } }
		public bool fInX { get { return ( cast<byte*>( &this )[9] & 2 ) != 0; } set { cast<byte*>( &this )[9] &= 253; cast<byte*>( &this )[9] |= cast<byte>( value ) << 1; } }
		public bool fErrorChar { get { return ( cast<byte*>( &this )[9] & 4 ) != 0; } set { cast<byte*>( &this )[9] &= 251; cast<byte*>( &this )[9] |= cast<byte>( value ) << 2; } }
		public bool fNull { get { return ( cast<byte*>( &this )[9] & 8 ) != 0; } set { cast<byte*>( &this )[9] &= 247; cast<byte*>( &this )[9] |= cast<byte>( value ) << 3; } }
		public RtsControl fRtsControl { get { return cast<RtsControl>( cast<byte*>( &this )[9] >> 4 & 3 ); } set { cast<byte*>( &this )[9] &= 207; cast<byte*>( &this )[9] |= ( cast<byte>( value.Value() ) << 4 & 48 ); } }
		public bool fAbortOnError { get { return ( cast<byte*>( &this )[9] & 64 ) != 0; } set { cast<byte*>( &this )[9] &= 191; cast<byte*>( &this )[9] |= cast<byte>( value ) << 6; } }
		public uint fDummy2 { get { return cast<byte*>( &this )[9] >> 7 | cast<ushort>( cast<byte*>( &this )[10] ) << 1 | cast<uint>( cast<byte*>( &this )[11] ) << 9; } set { cast<byte*>( &this )[9] &= 127; cast<byte*>( &this )[9] |= ( cast<byte>( value ) & 128 ) << 7; cast<byte*>( &this )[10] = cast<byte>( value >> 1 ); cast<byte*>( &this )[11] = cast<byte>( value >> 9 ); } }
		[ExplicitOffset( Offset = 12 )]
		public ushort wReserved;
		[ExplicitOffset( Offset = 14 )]
		public ushort XonLim;
		[ExplicitOffset( Offset = 16 )]
		public ushort XoffLim;
		[ExplicitOffset( Offset = 18 )]
		public byte ByteSize;
		[ExplicitOffset( Offset = 19 )]
		public ParityScheme Parity;
		[ExplicitOffset( Offset = 20 )]
		public StopBitsValue StopBits;
		[ExplicitOffset( Offset = 21 )]
		public sbyte XonChar;
		[ExplicitOffset( Offset = 22 )]
		public sbyte XoffChar;
		[ExplicitOffset( Offset = 23 )]
		public sbyte ErrorChar;
		[ExplicitOffset( Offset = 24 )]
		public sbyte EofChar;
		[ExplicitOffset( Offset = 25 )]
		public sbyte EvtChar;
		[ExplicitOffset( Offset = 26 )]
		public ushort wReserved1;

		public void ToString( StringBuilder builder, string format ) {
			builder.Concat( "DCBlength='", DCBlength, "' BaudRate='", BaudRate, "' fBinary='", fBinary, "' fParity='", fParity, "' fOutxCtsFlow='", fOutxCtsFlow, "' fOutxDsrFlow='", fOutxDsrFlow, "' fDtrControl='", fDtrControl, "' fDsrSensitivity='", fDsrSensitivity, "' fTXContinueOnXoff='", fTXContinueOnXoff, "' fOutX='", fOutX, "' fInX='", fInX, "' fErrorChar='", fErrorChar, "' fNull='", fNull, "' fRtsControl='", fRtsControl, "' fAbortOnError='", fAbortOnError, "' fDummy2='", fDummy2, "' wReserved='", wReserved, "' XonLim='", XonLim, "' XoffLim='", XoffLim, "' ByteSize='", ByteSize, "' Parity='", Parity, "' StopBits='", StopBits, "' XonChar='", XonChar, "' XoffChar='", XoffChar, "' ErrorChar='", ErrorChar, "' EofChar='", EofChar, "' EvtChar='", EvtChar, "' wReserved1='", wReserved1, '\'' );
		}

		public enum DtrControl : byte {
			DTR_CONTROL_DISABLE =   0,
			DTR_CONTROL_ENABLE =    1,
			DTR_CONTROL_HANDSHAKE = 2,
		}

		public enum RtsControl : byte {
			RTS_CONTROL_DISABLE =   0,
			RTS_CONTROL_ENABLE =    1,
			RTS_CONTROL_HANDSHAKE = 2,
			RTS_CONTROL_TOGGLE =    3,
		}

		public enum StopBitsValue : byte {
			ONESTOPBIT =   0,
			ONE5STOPBITS = 1,
			TWOSTOPBITS =  2,
		}

		public enum ParityScheme : byte {
			NOPARITY =    0,
			ODDPARITY =   1,
			EVENPARITY =  2,
			MARKPARITY =  3,
			SPACEPARITY = 4,
		}
	}

	[PrimitiveType( Size = sizeof( uintptr ) )]
	public struct SystemHandle {
		public static thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }
		public static thistype Null { get { return bitcast<thistype>( ( uintptr ) 0 ); } }
		public bool IsValid { get { return ( bitcast<uintptr>( this ) + 1 ) > 1; } }

		public uintptr ID { get { return bitcast<uintptr>( this ); } }
	}

	public struct ThreadPoolHandle : SystemHandle, IDisposable {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }
		public static new thistype Null { get { return bitcast<thistype>( ( uintptr ) 0 ); } }

		public uint ThreadMinimum { set { Kernel32Api.SetThreadpoolThreadMinimum( this, value ); } }
		public uint ThreadMaximum { set { Kernel32Api.SetThreadpoolThreadMaximum( this, value ); } }

		public void Dispose() {
			if( IsValid ) {
				Kernel32Api.CloseThreadpool( this );
				this = Null;
			}
		}
	}

	public struct ThreadPoolCleanupGroupHandle : SystemHandle, IDisposable {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }
		public static new thistype Null { get { return bitcast<thistype>( ( uintptr ) 0 ); } }

		public void Dispose() {
			if( IsValid ) {
				Kernel32Api.CloseThreadpoolCleanupGroup( this );
				this = Null;
			}
		}
	}

	public struct RegisteredWaitHandle : SystemHandle { }

	public struct FindHandle : SystemHandle { }

	public struct FindFileHandle : FindHandle, IDisposable {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }
		public static new thistype Null { get { return bitcast<thistype>( ( uintptr ) 0 ); } }

		public void Close() {
			if( IsValid ) {
				Kernel32Api.FindClose( this );
				this = Invalid;
			}
		}

		public void Dispose() {
			Close();
		}
	}

	public struct FindFileNameHandle : SystemHandle { }
	public struct FindFileStreamHandle : SystemHandle { }

	public struct HANDLE : SystemHandle, IFormattable, IDisposable {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }
		public static new thistype Null { get { return bitcast<thistype>( ( uintptr ) 0 ); } }

		public void Close() {
			if( IsValid ) {
				Kernel32Api.CloseHandle( this );

				this = Invalid;
			}
		}

		public void Dispose() {
			Close();
		}

		void IFormattable.ToString( StringBuilder builder, string format ) {
			uint flags;
			Kernel32Api.GetHandleInformation( this, flags );

			builder.AppendFormat( "{{ {0} Inheritable={1} ProtectFromClose={2} }}", bitcast<void*>( this ), BitOperations.MaskTest( flags, 1 ), BitOperations.MaskTest( flags, 2 ) );
		}
	}

	public struct IOHandle : HANDLE {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }
		public static new thistype Null { get { return bitcast<thistype>( ( uintptr ) 0 ); } }

		public SystemErrorCode Write( TimeSpan timeout, void* buffer, int count, int& total ) { return System.IO.Fiber.FiberInfo.Manager.WriteFile( timeout, this, buffer, count, total ); }
		public SystemErrorCode Read( TimeSpan timeout, void* buffer, int count, int& total ) { return System.IO.Fiber.FiberInfo.Manager.ReadFile( timeout, this, buffer, count, total ); }

		public SystemErrorCode Write( void* buffer, int count, int& total ) { return System.IO.Fiber.FiberInfo.Manager.WriteFile( TimeSpan.Zero, this, buffer, count, total ); }
		public SystemErrorCode Read( void* buffer, int count, int& total ) { return System.IO.Fiber.FiberInfo.Manager.ReadFile( TimeSpan.Zero, this, buffer, count, total ); }
	}

	public struct FileHandle : IOHandle {		
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }
		public static new thistype Null { get { return bitcast<thistype>( ( uintptr ) 0 ); } }

		public static bool Exists( CUtf16String path ) {
			var attr = Kernel32Api.GetFileAttributes( path );
			return attr != uint.MaxValue ? !BitOperations.MaskTest( attr, FileAttribute.FILE_ATTRIBUTE_DIRECTORY ) : false;
		}

		public static bool Delete( CUtf16String path ) {
			return Kernel32Api.DeleteFile( path );
		}
	}
	
	public struct IoCompletionPortHandle : HANDLE {
	}

	public struct HMODULE : HANDLE {
	}

	public struct WaitableTimerHandle : HANDLE {
	}

	public struct TimerQueueHandle : HANDLE, IDisposable {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }

		public new void Close() { Kernel32Api.DeleteTimerQueue( this ); }
		public new void Dispose() { Close(); }
	}

	public struct TimerQueueTimerHandle : HANDLE {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }
	}

	public struct HeapHandle : HANDLE {
		public bool Destroy() { return Kernel32Api.HeapDestroy( this ); }
		public void* Alloc( HeapAllocFlags flags, uint bytes ) { return Kernel32Api.HeapAlloc( this, flags, bytes ); }
		public void* ReAlloc( HeapReAllocFlags flags, void* memory, uint bytes ) { return Kernel32Api.HeapReAlloc( this, flags, memory, bytes ); }
		public bool Free( HeapSerializationFlags flags, void* memory ) { return Kernel32Api.HeapFree( this, flags, memory ); }
		public uint Size( HeapSerializationFlags flags, void* memory ) { return Kernel32Api.HeapSize( this, flags, memory ); }
		public bool Validate( HeapSerializationFlags flags, void* memory ) { return Kernel32Api.HeapValidate( this, flags, memory ); }
		public uint Compact( HeapSerializationFlags flags ) { return Kernel32Api.HeapCompact( this, flags ); }
	}

	public struct EventHandle : HANDLE {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }

		public void Reset() { Kernel32Api.ResetEvent( this ); }
		public void Set() { Kernel32Api.SetEvent( this ); }
	}

	public sealed struct ManualResetEventHandle : EventHandle {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }

		public ManualResetEventHandle() {
			this = bitcast<thistype>( Kernel32Api.CreateEvent( nullref, true, false, CString.Null ) );
		}
	}

	public sealed struct AutoResetEventHandle : EventHandle {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }

		public AutoResetEventHandle() {
			this = bitcast<thistype>( Kernel32Api.CreateEvent( nullref, false, false, CString.Null ) );
		}
	}

	public struct SemaphoreHandle : HANDLE {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }

		public SemaphoreHandle( int initialCount, int maximumCount ) {
			this = Kernel32Api.CreateSemaphore( nullref, initialCount, maximumCount, CString.Null );
		}

		public int Release( int count ) {
			int result;
			Assert.IsTrue( Kernel32Api.ReleaseSemaphore( this, count, result ) );
			return result;
		}

		public void Wait( uint milliseconds = Kernel32Api.INFINITE ) { Kernel32Api.WaitForSingleObject( this, milliseconds ); }
	}

	public struct MutexHandle : HANDLE {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }
	}

	public struct MailslotHandle : HANDLE {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }
	}

	public struct FileMappingHandle : HANDLE {
		public static new thistype Invalid { get { return bitcast<thistype>( uintptr.MaxValue ); } }
	}

	public struct FiberHandle : SystemHandle { }

	public partial struct ThreadHandle : HANDLE {
		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		public ThreadHandle( Kernel32Api.ThreadProc startAddress, void* parameter, uintptr stackSize = 0, CreateThreadFlags flags = CreateThreadFlags.None, uint& threadId = nullref ) {
			this = Kernel32Api.CreateThread( nullref, stackSize, startAddress, parameter, flags, threadId );
		}

		public ThreadHandle( Functors.Action start, uintptr stackSize = 0, CreateThreadFlags flags = CreateThreadFlags.None, uint& threadId = nullref ) {
			this = Kernel32Api.CreateThread( nullref, stackSize, data => { bitcast<Functors.Action>( data )(); return 0; }, bitcast<void*>( start ), flags, threadId );
		}

		public ThreadHandle( Delegates.Action start, uintptr stackSize = 0, CreateThreadFlags flags = CreateThreadFlags.None, uint& threadId = nullref ) {
			cast<RuntimeObjectBase>( start ).AddReference();

			this = Kernel32Api.CreateThread( nullref, stackSize, data => {
				var& @delegate = *( Delegates.Action* ) &data; // dont touch refcount here
				@delegate();
				cast<RuntimeObjectBase>( @delegate ).ReleaseReference();

				return 0;
			}, bitcast<void*>( start ), flags, threadId );
		}

		public uint Resume() { return Kernel32Api.ResumeThread( this ); }
		public uint Suspend() { return Kernel32Api.SuspendThread( this ); }

		public uint Join( uint milliseconds = Kernel32Api.INFINITE ) { return Kernel32Api.WaitForSingleObject( this, milliseconds ); }

		// Pseudo-handle
		// public static ThreadHandle CurrentThread { get { return Kernel32Api.GetCurrentThread(); } }
		public static ThreadHandle CurrentThread { get { return bitcast<ThreadHandle>( uintptr.MaxValue - 1 ); } }

		// public static uint CurrentThreadID { get { return Kernel32Api.GetCurrentThreadId(); } }
		public static uint CurrentThreadID { get { return _TEB.CurrentThreadId; } }

		public static void Sleep( uint milliseconds = uint.MaxValue ) { Kernel32Api.Sleep( milliseconds ); }
		public static uint SleepAlertable( uint milliseconds = uint.MaxValue ) { return Kernel32Api.SleepEx( milliseconds, true ); }
	}

	public partial struct ProcessHandle : HANDLE { }

	public struct NamedPipeHandle : IOHandle {
		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		public static NamedPipeHandle Open( CUtf16String name ) {
			return bitcast<NamedPipeHandle>( Kernel32Api.CreateFile( name, FileAccessRights.GENERIC_READ | FileAccessRights.GENERIC_WRITE, FileShareMode.FILE_SHARE_NONE, nullref, FileCreationDisposition.OPEN_EXISTING, FileCreationFlags.None, HANDLE.Null ) );
		}

		public bool Connect() {
			return Kernel32Api.ConnectNamedPipe( this, nullref );
		}

		public bool Disconnect() {
			return Kernel32Api.DisconnectNamedPipe( this );
		}
	}

	/// Codepages http://msdn.microsoft.com/en-us/library/dd317756(VS.85).aspx
	public enum CodePageID {
		ANSI =        0,
		OEM =         1,
		MAC =         2,
		ThreadANSI =  3,
		Symbol =     42,

		Utf16LE =  1200,
		Utf16BE =  1201,
		Utf32LE = 12000,
		Utf32BE = 12001,
		Utf8 =    65001,
	}

	[Flags]
	public enum VirtualAllocFlags : uint {
		None =                    0,
		MEM_COMMIT =           4096,
		MEM_RESERVE =          8192,
		MEM_RESET =          524288,
		MEM_TOP_DOWN =      1048576,
		MEM_WRITE_WATCH =   2097152,
		MEM_PHYSICAL =      4194304,
		MEM_LARGE_PAGES = 536870912,
	}

	[Flags]
	public enum PageProtectionFlags : uint {
		None =                     0,
		PAGE_NOACCESS =            1,
		PAGE_READONLY =            2,
		PAGE_READWRITE =           4,
		PAGE_WRITECOPY =           8,
		PAGE_EXECUTE =            16,
		PAGE_EXECUTE_READ =       32,
		PAGE_EXECUTE_READWRITE =  64,
		PAGE_EXECUTE_WRITECOPY = 128,
		PAGE_GUARD =             256,
		PAGE_NOCACHE =           512,
		PAGE_WRITECOMBINE =     1024,
	}

	public enum VirtualFreeType : uint {
		MEM_DECOMMIT = 16384,
		MEM_RELEASE =  32768,
	}

	public partial struct CRITICAL_SECTION {
		public CRITICAL_SECTION() { Kernel32Api.InitializeCriticalSection( this ); }
		~CRITICAL_SECTION() { Kernel32Api.DeleteCriticalSection( this ); }
		=CRITICAL_SECTION() { Assert.Fail( "May not be copied" ); }

		/// Can be Entered recursively
		public void Enter() { Kernel32Api.EnterCriticalSection( this ); }
		public void Leave() { Kernel32Api.LeaveCriticalSection( this ); }

		public LockScope ScopeEnter() { return new LockScope( this ); }

		public struct LockScope : IDisposable {
			private readonly declaringtype* _parent;

			public LockScope( declaringtype& section ) {
				_parent = &section;
				_parent->Enter();
			}

			public void Dispose() { _parent->Leave(); }
		}
	}

	public partial struct PROCESS_MEMORY_COUNTERS_EX {
		public PROCESS_MEMORY_COUNTERS_EX() { SelfSize = sizeof( thistype ); }
	}

	public partial struct OSVERSIONINFOA {
		public OSVERSIONINFOA() { SelfSize = sizeof( thistype ); }
	}

	public partial struct OSVERSIONINFOW {
		public OSVERSIONINFOW() { SelfSize = sizeof( thistype ); }
	}

	public partial struct FILETIME : IFormattable {
		public ulong DateTime64 { get { return ( cast<ulong>( HighDateTime ) << 32 ) | LowDateTime; } }

		public static explicit operator DateTime( thistype& @this ) { return new DateTime( bitcast<long>( @this.DateTime64 ) + 0x701CE1722770000L, DateTimeKind.Utc ); }

		void IFormattable.ToString( StringBuilder builder, string format ) {
			builder.Append( ( DateTime ) this );
		}
	}

	public partial struct WIN32_FILE_ATTRIBUTE_DATA : IFormattable {
		public ulong FileSize64 { get { return ( cast<ulong>( FileSizeHigh ) << 32 ) | FileSizeLow; } }

		void IFormattable.ToString( StringBuilder builder, string format ) {
			builder.Concat( "FileAttributes=", FileAttributes, " CreationTime=", CreationTime, " LastAccessTime=", LastAccessTime, " LastWriteTime=", LastWriteTime, " FileSize64=", FileSize64 );
		}
	}

	public partial struct WIN32_FIND_DATAW : IFormattable {
		public ulong FileSize64 { get { return ( cast<ulong>( FileSizeHigh ) << 32 ) | FileSizeLow; } }
		public bool IsDirectory { get { return BitOperations.MaskTest( FileAttributes, FileAttribute.FILE_ATTRIBUTE_DIRECTORY ); } }

		void IFormattable.ToString( StringBuilder builder, string format ) {
			builder.Concat( "FileAttributes=", FileAttributes, " CreationTime=", CreationTime, " LastAccessTime=", LastAccessTime, " LastWriteTime=", LastWriteTime, " FileSize64=", FileSize64, " FileName='", new CUtf16String( &FileName[0] ), "' AlternateFileName='", new CUtf16String( &AlternateFileName[0] ), "'" );
		}
	}

	public enum FileSeekOrigin {
		FILE_BEGIN,
		FILE_CURRENT,
		FILE_END,
	}

	public partial struct STARTUPINFOA {
		public STARTUPINFOA() {
			this = default( thistype );
			SelfSize = sizeof( thistype );
		}
	}

	public partial struct STARTUPINFOW {
		public STARTUPINFOW() {
			this = default( thistype );
			SelfSize = sizeof( thistype );
		}
	}

	[Throwable]
	public struct SystemException : IFormattable {
		public HANDLE Handle = HANDLE.Invalid;
		public SystemErrorCode ErrorCode = 0;

		public SystemException( SystemErrorCode errorCode ) {
			ErrorCode = errorCode;
		}

		public SystemException( HANDLE handle, SystemErrorCode errorCode ) {
			Handle = handle;
			ErrorCode = errorCode;
		}

		public void ToString( StringBuilder builder, string format ) {
			builder.Concat( typeof( thistype ), " { ErrorCode=", ErrorCode );

			builder.Append( " }" );
		}
	}
}