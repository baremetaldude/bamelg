//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.IO;
using System.Net;

namespace Platform.IO {
	// Должен использоваться с неблокирующими сокетами в Fiber'ах либо с блокирующими в тредах
	public class NetworkStream : IStream {
		public static IPlatformErrorHandler DefaultErrorHandler = PlatformErrorHandlerNull.Instance;
		public IPlatformErrorHandler ErrorHandler = DefaultErrorHandler;

		public StreamCapabilities Capabilities { get { return StreamCapabilities.Read | StreamCapabilities.Write; } }
		public StreamingBufferInfo* BufferInfo { get { return null; } }

		protected SocketHandle _handle = SocketHandle.Invalid;
		public SocketHandle Handle {
			get { return _handle; }
			set { Close(); _handle = value; }
		}

		public bool CloseHandle = true;
		public string Context;

		public NetworkStream() {
		}

		public NetworkStream( SocketHandle handle ) {
			_handle = handle;
		}

		~NetworkStream() { Close(); }
		public override void Dispose() { Close(); base.Dispose(); }

		private void Close() {
			if( CloseHandle ) _handle.Close();
			else _handle = SocketHandle.Invalid;
		}

		protected PlatformErrorAction OnLastError( string operation, IFormattable context, SystemErrorCode errorCode ) { return ErrorHandler.OnError( operation, context, errorCode ); }
		protected PlatformErrorAction OnLastError( string operation, SystemErrorCode errorCode ) { return ErrorHandler.OnError( operation, Context, errorCode ); }

		public bool Connect( IPv4Endpoint endpoint ) {
			Close();

			using( var socket = new SocketHandleTCP() ) {
			restart_Connect:
				var status = socket.Connect( endpoint );
				if( !status ) {
					if( OnLastError( "Connect", endpoint, status ) == PlatformErrorAction.Restart ) goto restart_Connect;
					return false;
				}

				socket.NoDelay = true;

				_handle = socket;
				socket = SocketHandleTCP.Invalid;
			}

			return true;
		}

		public bool Connect( IPv6Endpoint endpoint ) {
			Close();

			using( var socket = new SocketHandleTCP() ) {
			restart_Connect:
				var status = socket.Connect( endpoint );
				if( !status ) {
					if( OnLastError( "Connect", endpoint, status ) == PlatformErrorAction.Restart ) goto restart_Connect;
					return false;
				}

				socket.NoDelay = true;

				_handle = socket;
				socket = SocketHandleTCP.Invalid;
			}

			return true;
		}

		public bool Bind( IPv4Endpoint endpoint ) {
			var nativeEndpoint = ( sockaddr_in ) endpoint;

		restart_Bind:
			var status = _handle.Bind( &nativeEndpoint, sizeof( nativeEndpoint ) );

			if( !status ) {
				if( OnLastError( "Bind", endpoint, status ) == PlatformErrorAction.Restart ) goto restart_Bind;
				return false;
			}

			return true;
		}

		public bool Bind( IPv6Endpoint endpoint ) {
			var nativeEndpoint = ( sockaddr_in6 ) endpoint;

		restart_Bind:
			var status = _handle.Bind( &nativeEndpoint, sizeof( nativeEndpoint ) );

			if( !status ) {
				if( OnLastError( "Bind", endpoint, status ) == PlatformErrorAction.Restart ) goto restart_Bind;
				return false;
			}

			return true;
		}

		// Read будет возвращать меньше байт чем ожидается только в случае закрытия соединения
		public int Read( void* buffer, int count ) {
			if( !_handle.IsValid || count == 0 || buffer == null ) return 0;

			var data = ( byte* ) buffer;

			var transmitted = 0;
			for( ; count > 0; ) {
			restart_ReadFile:
				var error = _handle.Read( _timeout, data, count, transmitted );
				if( error != SystemErrorCode.NO_ERROR ) {
					if( OnLastError( "Read", error ) == PlatformErrorAction.Restart ) goto restart_ReadFile;
					break;
				}

				data += transmitted;
				if( transmitted < count ) break;

				count -= transmitted;
			}

			return ( int )( data - ( byte* ) buffer );
		}

		public void Write( void* buffer, int count ) {
			if( !_handle.IsValid || count == 0 || buffer == null ) return;

			var data = ( byte* ) buffer;

			var transmitted = 0;
			for( ; transmitted < count; ) {
			restart_WriteFile:
				var error = _handle.Write( _timeout, data, count, transmitted );
				if( error != SystemErrorCode.NO_ERROR ) {
					if( OnLastError( "Write", error ) == PlatformErrorAction.Restart ) goto restart_WriteFile;
					break;
				}

				data += transmitted;
				count -= transmitted;
			}
		}

		public void Flush( FlushKind flushKind = FlushKind.SynchronizeWrite ) {
		}

		int IStream.Read( vararg MemorySegment segments ) { var result = 0; foreach( var segment in segments ) result += Read( segment.Start, ( int ) segment.Count ); return result; }
		void IStream.Write( vararg MemorySegment segments ) { foreach( var segment in segments ) Write( segment.Start, ( int ) segment.Count ); }

		protected TimeSpan _timeout = TimeSpan.Zero;
		public TimeSpan Timeout { get { return _timeout; } set { _timeout = value; } }

		long IStream.Position { get { return 0; } }
		long IStream.Seek( long offset, SeekOrigin origin ) { return 0; }
	}

	public class UdpStream : NetworkStream, IStream {
		public WsaAddress WriteEndpoint;
		public WsaAddress LastReceiveFrom;

		public UdpStream( SocketHandleUDP handle )
			: base( handle ) {
		}

		public new void Write( void* buffer, int count ) {
			if( !_handle.IsValid || count == 0 || buffer == null ) return;

			var data = ( byte* ) buffer;

			var transmitted = 0;
			for( ; transmitted < count; ) {
			restart_WriteFile:
				var error = _handle.SendTo( _timeout, &WriteEndpoint.Address, WriteEndpoint.Length, data, count, transmitted );
				if( error != SystemErrorCode.NO_ERROR ) {
					if( OnLastError( "SendTo", error ) == PlatformErrorAction.Restart ) goto restart_WriteFile;
					break;
				}

				data += transmitted;
				count -= transmitted;
			}
		}

		public new int Read( void* buffer, int count ) {
			if( !_handle.IsValid || count == 0 || buffer == null ) return 0;

			var data = ( byte* ) buffer;

			var transmitted = 0;
			for( ; count > 0; ) {
			restart_ReadFile:
				var error = _handle.ReceiveFrom( _timeout, &LastReceiveFrom.Address, LastReceiveFrom.Length, data, count, transmitted );
				if( error != SystemErrorCode.NO_ERROR ) {
					if( OnLastError( "ReceiveFrom", error ) == PlatformErrorAction.Restart ) goto restart_ReadFile;
					break;
				}

				data += transmitted;
				if( transmitted < count ) break;

				count -= transmitted;
			}

			return ( int )( data - ( byte* ) buffer );
		}

		int IStream.Read( vararg MemorySegment segments ) { var result = 0; foreach( var segment in segments ) result += Read( segment.Start, ( int ) segment.Count ); return result; }
		void IStream.Write( vararg MemorySegment segments ) { foreach( var segment in segments ) Write( segment.Start, ( int ) segment.Count ); }

		long IStream.Position { get { return 0; } }
		long IStream.Seek( long offset, SeekOrigin origin ) { return 0; }
	}
}