//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.IO;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

using Platform;

namespace Platform.IO {
	public class FileStream : IStream {
		public static IPlatformErrorHandler DefaultErrorHandler = PlatformErrorHandlerAbort.Instance;
		public IPlatformErrorHandler ErrorHandler = DefaultErrorHandler;

		public StreamCapabilities Capabilities { get { return StreamCapabilities.Read | StreamCapabilities.Write; } }
		public StreamingBufferInfo* BufferInfo { get { return null; } }

		private IOHandle _handle = IOHandle.Invalid;
		public IOHandle Handle {
			get { return _handle; }
			set { Close(); _handle = value; }
		}

		public bool CloseHandle = true;
		public string Context;

		// @{ create stream API
		public FileStream() { }
		public FileStream( IOHandle handle ) { _handle = handle; }
		public FileStream( IPlatformErrorHandler errorHandler ) { ErrorHandler = errorHandler; }
		public FileStream( string name, FileAccessRights fDesiredAccess ) { Open( name, fDesiredAccess ); }

		public static FileStream CreateReadStream( string name ) { var result = new FileStream(); result.OpenRead( name ); return result; }
		public static FileStream CreateWriteStream( string name ) { var result = new FileStream(); result.OpenWrite( name ); return result; }
		public static FileStream CreateAppendStream( string name ) { var result = new FileStream(); result.OpenAppend( name ); return result; }
		// @}

		~FileStream() { Close(); }
		public override void Dispose() { Close(); base.Dispose(); }

		public void Close() {
			if( CloseHandle ) _handle.Close();
			else _handle = SocketHandle.Invalid;
		}

		private static FileCreationFlags FiberSpecificFlags { get { return Fiber.IsFiberExecuting ? FileCreationFlags.FILE_FLAG_OVERLAPPED : FileCreationFlags.None; } }

		public bool OpenWrite( string name ) {
			return Open( name, FileAccessRights.FILE_WRITE_DATA, FileCreationDisposition.CREATE_ALWAYS, FileShareMode.FILE_SHARE_READ, FiberSpecificFlags );
		}

		public bool OpenRead( string name ) {
			return Open( name, FileAccessRights.FILE_READ_DATA, FileCreationDisposition.OPEN_EXISTING, FileShareMode.FILE_SHARE_READ, FiberSpecificFlags );
		}

		public bool OpenAppend( string name ) {
			return Open( name, FileAccessRights.FILE_APPEND_DATA, FileCreationDisposition.OPEN_ALWAYS, FileShareMode.FILE_SHARE_READ, FiberSpecificFlags );
			// Kernel32Api.SetFilePointer( _handle, 0, nullref, FileSeekOrigin.FILE_END ); not necessary
		}

		public bool Open( string name, FileAccessRights fDesiredAccess ) {
			return Open( name, fDesiredAccess, ( fDesiredAccess & ( FileAccessRights.GENERIC_WRITE | FileAccessRights.FILE_WRITE_DATA ) ) != 0 ? FileCreationDisposition.CREATE_ALWAYS : FileCreationDisposition.OPEN_EXISTING );
		}

		public bool Open( string name, FileAccessRights fDesiredAccess, FileCreationDisposition fCreationDisposition ) {
			FileShareMode fShareMode;
			if( ( fDesiredAccess & ( FileAccessRights.GENERIC_WRITE | FileAccessRights.FILE_WRITE_DATA ) ) != 0 )
				fShareMode = FileShareMode.FILE_SHARE_NONE;
			else
				fShareMode = FileShareMode.FILE_SHARE_READ;

			return Open( name, fDesiredAccess, fCreationDisposition, fShareMode, FiberSpecificFlags );
		}

		public bool Open( string name, FileAccessRights fDesiredAccess, FileCreationDisposition fCreationDisposition, FileShareMode fShareMode, FileCreationFlags fFlagsAndAttributes = 0 ) {
			if( !Assert.IsTrue( !name.IsNullOrEmpty ) ) return false;
			Close();

			Context = name;

		restart_CreateFile:
			_handle = bitcast<IOHandle>( Kernel32Api.CreateFile( name, fDesiredAccess, fShareMode, nullref, fCreationDisposition, fFlagsAndAttributes, HANDLE.Null ) );
			if( !_handle.IsValid ) {
				if( OnLastError( "CreateFile" ) == PlatformErrorAction.Restart ) goto restart_CreateFile;
				return false;
			}

			return true;
		}

		public string FinalPath {
			get { return Kernel32Api.GetFinalPath( _handle ); }
		}

		public long FileLength {
			get {
				if( !_handle.IsValid ) return 0;

				long length;
				return Kernel32Api.GetFileSizeEx( _handle, length ) ? length : 0;
			}
			set {
				if( !_handle.IsValid ) return;

			restart_SetFilePointerEx:
				long length;
				if( !Kernel32Api.SetFilePointerEx( _handle, value, length, FileSeekOrigin.FILE_BEGIN ) ) {
					if( OnLastError( "SetFilePointerEx" ) == PlatformErrorAction.Restart ) goto restart_SetFilePointerEx;
					return;
				}

			restart_SetEndOfFile:
				if( !Kernel32Api.SetEndOfFile( _handle ) ) { // SystemErrorCode.ERROR_DISK_FULL occurs here
					if( OnLastError( "SetEndOfFile" ) == PlatformErrorAction.Restart ) goto restart_SetEndOfFile;
					return;
				}
			}
		}

		public long Position {
			get {
			restart_SetFilePointerEx:
				long result;
				if( !Kernel32Api.SetFilePointerEx( _handle, 0, result, FileSeekOrigin.FILE_CURRENT ) ) {
					if( OnLastError( "SetFilePointerEx" ) == PlatformErrorAction.Restart ) goto restart_SetFilePointerEx;
					return -1;
				}

				return result;
			}
		}

		private PlatformErrorAction OnLastError( string operation, IFormattable context, SystemErrorCode errorCode ) { return ErrorHandler.OnError( operation, context, errorCode ); }
		private PlatformErrorAction OnLastError( string operation, SystemErrorCode errorCode ) { return ErrorHandler.OnError( operation, Context, errorCode ); }
		private PlatformErrorAction OnLastError( string operation ) { return ErrorHandler.OnError( operation, Context, Kernel32Api.LastError ); }

		#region IStream Members

		public int Read( void* buffer, int count ) {
			if( !_handle.IsValid ) return 0;

		restart_ReadFile:
			int readen;
			var error = _handle.Read( _timeout, buffer, count, readen );
			if( error != SystemErrorCode.NO_ERROR ) {
				if( OnLastError( "Read", error ) == PlatformErrorAction.Restart ) goto restart_ReadFile;
				return readen;
			}

			return ( int ) readen;
		}

		public void Write( void* buffer, int count ) {
			if( !_handle.IsValid ) return;

		restart_WriteFile:
			int written;
			var error = _handle.Write( _timeout, buffer, count, written );
			if( error != SystemErrorCode.NO_ERROR ) {
				if( OnLastError( "Write", error ) == PlatformErrorAction.Restart ) goto restart_WriteFile;
				return;
			}

			Assert.IsTrue( written == count );
		}

		public void Flush( FlushKind flushKind ) {
			if( !_handle.IsValid ) return;

			switch( flushKind ) {
				case FlushKind.SynchronizeWrite:
				restart_FlushFileBuffers:
					if( !Kernel32Api.FlushFileBuffers( _handle ) ) {
						if( OnLastError( "FlushFileBuffers" ) == PlatformErrorAction.Restart ) goto restart_FlushFileBuffers;
						return;
					}

					break;
			}
		}

		#endregion

		int IStream.Read( vararg MemorySegment segments ) { var result = 0; foreach( var segment in segments ) result += Read( segment.Start, ( int ) segment.Count ); return result; }
		void IStream.Write( vararg MemorySegment segments ) { foreach( var segment in segments ) Write( segment.Start, ( int ) segment.Count ); }

		private TimeSpan _timeout = TimeSpan.Zero;
		public TimeSpan Timeout { get { return _timeout; } set { _timeout = value; } }
	}
}