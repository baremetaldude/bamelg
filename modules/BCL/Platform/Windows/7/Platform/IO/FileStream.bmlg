//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//
// All files must be created with overlapped flag, otherwise them cannot be used in fibers later
//

using System;
using System.IO;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

using Platform;

namespace Platform.IO {
	public class FileStream : IStream {
		public TimeSpan WriteTimeout { get; set; }
		public TimeSpan ReadTimeout { get; set; }

		public static IPlatformErrorHandler DefaultErrorHandler = PlatformErrorHandlerAbort.Instance;
		public IPlatformErrorHandler ErrorHandler = DefaultErrorHandler;

		public StreamCapabilities Capabilities { get { return StreamCapabilities.Read | StreamCapabilities.Write | StreamCapabilities.Seek; } }
		public StreamingBufferInfo* BufferInfo { get { return null; } }

		private ulong Offset;

		private IOHandle _handle = IOHandle.Invalid;
		public IOHandle Handle {
			get { return _handle; }
			set { Close(); _handle = value; }
		}

		public bool CloseHandle { get; set; } = true;

		public string Context;

		// @{ create stream API
		public FileStream() { }
		public FileStream( IOHandle handle ) { _handle = handle; }
		public FileStream( IPlatformErrorHandler errorHandler ) { ErrorHandler = errorHandler; }
		public FileStream( string name, FileAccessRights fDesiredAccess ) { Open( name, fDesiredAccess ); }

		public static FileStream CreateReadStream( string name ) { var result = new FileStream(); if( !result.OpenRead( name ) ) return null; return result; }
		public static FileStream CreateWriteStream( string name ) { var result = new FileStream(); if( !result.OpenWrite( name ) ) return null; return result; }
		public static FileStream CreateAppendStream( string name ) { var result = new FileStream(); if( !result.OpenAppend( name ) ) return null; return result; }
		// @}

		~FileStream() { Close(); }
		public override void Dispose() { Close(); base.Dispose(); }

		public void Close() {
			if( CloseHandle ) _handle.Close();
			else _handle = SocketHandle.Invalid;
		}

		public bool OpenWrite( string name ) {
			return Open( name, FileAccessRights.FILE_WRITE_DATA, FileCreationDisposition.CREATE_ALWAYS, FileShareMode.FILE_SHARE_READ, FileCreationFlags.FILE_FLAG_OVERLAPPED );
		}

		public bool OpenRead( string name ) {
			return Open( name, FileAccessRights.FILE_READ_DATA, FileCreationDisposition.OPEN_EXISTING, FileShareMode.FILE_SHARE_READ, FileCreationFlags.FILE_FLAG_OVERLAPPED );
		}

		public bool OpenAppend( string name ) {
			return Open( name, FileAccessRights.FILE_APPEND_DATA, FileCreationDisposition.OPEN_ALWAYS, FileShareMode.FILE_SHARE_READ, FileCreationFlags.FILE_FLAG_OVERLAPPED );
			// Kernel32Api.SetFilePointer( _handle, 0, nullref, FileSeekOrigin.FILE_END ); not necessary
		}

		public bool Open( string name, FileAccessRights fDesiredAccess ) {
			return Open( name, fDesiredAccess, ( fDesiredAccess & ( FileAccessRights.GENERIC_WRITE | FileAccessRights.FILE_WRITE_DATA ) ) != 0 ? FileCreationDisposition.CREATE_ALWAYS : FileCreationDisposition.OPEN_EXISTING );
		}

		public bool Open( string name, FileAccessRights fDesiredAccess, FileCreationDisposition fCreationDisposition ) {
			FileShareMode fShareMode;
			if( ( fDesiredAccess & ( FileAccessRights.GENERIC_WRITE | FileAccessRights.FILE_WRITE_DATA ) ) != 0 )
				fShareMode = FileShareMode.FILE_SHARE_NONE;
			else
				fShareMode = FileShareMode.FILE_SHARE_READ;

			return Open( name, fDesiredAccess, fCreationDisposition, fShareMode, FileCreationFlags.FILE_FLAG_OVERLAPPED );
		}

		public bool Open( string name, FileAccessRights fDesiredAccess, FileCreationDisposition fCreationDisposition, FileShareMode fShareMode, FileCreationFlags fFlagsAndAttributes = 0 ) {
			Close();

			Context = name;

		restart_CreateFile:
			SystemErrorCode error;
			using( Fiber.AsyncCompletionRegion() ) {
				_handle = bitcast<IOHandle>( Kernel32Api.CreateFile( name, fDesiredAccess, fShareMode, nullref, fCreationDisposition, fFlagsAndAttributes, HANDLE.Null ) );
				error = Kernel32Api.LastError;
			}

			if( !_handle.IsValid ) {
				if( OnLastError( "CreateFile", error ) == PlatformErrorAction.Restart ) goto restart_CreateFile;
				return false;
			}

			Offset = 0;
			return true;
		}

		public string FinalPath {
			get { return Kernel32Api.GetFinalPath( _handle ); }
		}

		public long FileLength {
			get {
				if( !_handle.IsValid ) return 0;

				long length;
				return Kernel32Api.GetFileSizeEx( _handle, length ) ? length : 0;
			}
			set {
				if( !_handle.IsValid ) return;

			restart_SetFilePointerEx:
				long length;
				if( !Kernel32Api.SetFilePointerEx( _handle, value, length, FileSeekOrigin.FILE_BEGIN ) ) {
					var error = Kernel32Api.LastError;
					if( OnLastError( "SetFilePointerEx", error ) == PlatformErrorAction.Restart ) goto restart_SetFilePointerEx;
					return;
				}

			restart_SetEndOfFile:
				if( !Kernel32Api.SetEndOfFile( _handle ) ) { // SystemErrorCode.ERROR_DISK_FULL occurs here
					var error = Kernel32Api.LastError;
					if( OnLastError( "SetEndOfFile", error ) == PlatformErrorAction.Restart ) goto restart_SetEndOfFile;
					return;
				}
			}
		}

		public long Position {
			get {
				// restart_SetFilePointerEx:
				// 	long result;
				// 	if( !Kernel32Api.SetFilePointerEx( _handle, 0, result, FileSeekOrigin.FILE_CURRENT ) ) {
				// 		if( OnLastError( "SetFilePointerEx" ) == PlatformErrorAction.Restart ) goto restart_SetFilePointerEx;
				// 		return -1;
				// 	}

				return ( long ) Offset;
			}
		}

		public long Seek( long offset, SeekOrigin origin ) {
			// 	var fileSeekOrigin = FileSeekOrigin.FILE_CURRENT;

			// 	switch( origin ) {
			// 		case SeekOrigin.Begin: fileSeekOrigin = FileSeekOrigin.FILE_BEGIN; break;
			// 		case SeekOrigin.End: fileSeekOrigin = FileSeekOrigin.FILE_END; break;
			// 	}

			// restart_SetFilePointerEx:
			// 	long result;
			// 	if( !Kernel32Api.SetFilePointerEx( _handle, 0, result, fileSeekOrigin ) ) {
			// 		if( OnLastError( "SetFilePointerEx" ) == PlatformErrorAction.Restart ) goto restart_SetFilePointerEx;
			// 		return -1;
			// 	}

			// 	return result;
			return 0;
		}

		private PlatformErrorAction OnLastError( string operation, IFormattable context, SystemErrorCode errorCode ) { return ErrorHandler.OnError( operation, context, errorCode ); }
		private PlatformErrorAction OnLastError( string operation, SystemErrorCode errorCode ) { return ErrorHandler.OnError( operation, Context, errorCode ); }

		#region IStream Members

		public uint Read( void* buffer, uint count ) {
			if( !_handle.IsValid ) return 0;

		restart_ReadFile:
			uint readen;
			var error = _handle.Read( ReadTimeout, Offset, buffer, count, readen );
			Offset += readen;

			if( error == SystemErrorCode.ERROR_HANDLE_EOF )
				return readen;

			if( error != SystemErrorCode.NO_ERROR ) {
				if( OnLastError( "Read", error ) == PlatformErrorAction.Restart ) goto restart_ReadFile;
				return readen;
			}

			return readen;
		}

		public uint Write( void* buffer, uint count ) {
			if( !_handle.IsValid ) return 0;

		restart_WriteFile:
			uint written;
			var error = _handle.Write( WriteTimeout, Offset, buffer, count, written );
			if( error != SystemErrorCode.NO_ERROR ) {
				if( OnLastError( "Write", error ) == PlatformErrorAction.Restart ) goto restart_WriteFile;
				return 0;
			}

			Offset += count;
			return written;

			// restart_WriteFile:
			// 			uint lastWritten;
			// 			uint totalWritten = 0;

			// 			if( _handle.Write( buffer, count, out lastWritten, null ) == 0 ) {
			// 				var lastError = Kernel32Api.LastErrorCode;
			// 				if( lastError == SystemErrorCode.ERROR_DISK_FULL ) {
			// 					var partialCount = count / 2;

			// 					while( partialCount != 0 ) {
			// restart_WriteFile2:
			// 						if( Kernel32Api.WriteFile( _handle, buffer, partialCount, out lastWritten, null ) == 0 ) {
			// 							lastError = Kernel32Api.LastErrorCode;
			// 							if( lastError == SystemErrorCode.ERROR_DISK_FULL ) {
			// 								partialCount >>= 1;
			// 								continue;
			// 							}

			// 							if( ErrorHandler.OnError( "WriteFile", Context, lastError ) == PlatformErrorAction.Restart ) goto restart_WriteFile2;
			// 							return totalWritten;
			// 						}

			// 						buffer = ( byte* ) buffer + lastWritten;
			// 						count -= lastWritten;
			// 						totalWritten += lastWritten;
			// 					}
			// 				}

			// 				if( ErrorHandler.OnError( "WriteFile", Context, lastError ) == PlatformErrorAction.Restart ) goto restart_WriteFile;
			// 				return totalWritten;
			// 			}

			// 			buffer = ( byte* ) buffer + lastWritten;
			// 			count -= lastWritten;
			// 			totalWritten += lastWritten;

			// 			if( count != 0 ) goto restart_WriteFile;

			// 			return totalWritten;
		}

		public void Flush( FlushKind flushKind = FlushKind.DeepWrite ) {
			if( !_handle.IsValid ) return;

			switch( flushKind ) {
				case FlushKind.SynchronizeWrite:
				restart_FlushFileBuffers:
					if( !Kernel32Api.FlushFileBuffers( _handle ) ) {
						var error = Kernel32Api.LastError;
						if( OnLastError( "FlushFileBuffers", error ) == PlatformErrorAction.Restart ) goto restart_FlushFileBuffers;
						return;
					}

					break;
			}
		}

		#endregion

		uint IStream.Read( vararg MemorySegment segments ) {
			var result = 0U;

			foreach( var segment in segments ) {
				var readen = Read( segment.Start, ( uint ) segment.Count );
				result += readen;

				if( readen != segment.Count )
					break;
			}

			return result;
		}

		uint IStream.Write( vararg MemorySegment segments ) {
			var result = 0U;

			foreach( var segment in segments ) {
				var written = Write( segment.Start, ( uint ) segment.Count );
				result += written;

				if( written != segment.Count )
					break;
			}

			return result;
		}

		MemoryMappedView IStream.CreateReadView( uintptr offset, uintptr length ) { return null; }
		MemoryMappedView IStream.CreateWriteView( uintptr offset, uintptr length ) { return null; }
	}
}