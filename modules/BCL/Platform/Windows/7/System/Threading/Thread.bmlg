//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using Platform;

namespace System.Threading {
	public partial struct Thread {
		public uint _threadId;
		public ThreadHandle _thread;

		private bool _implIsCurrent() { return _threadId == ThreadHandle.CurrentThreadID; }

		private static Thread _implStart( DPC* action ) {
			uint threadId;
			var thread = new ThreadHandle( action, 0, CreateThreadFlags.None, threadId );

			return new Thread { _thread = thread, _threadId = threadId };
		}

		private static Thread _implStart( Functors.Action action ) {
			uint threadId;
			var thread = new ThreadHandle( action, 0, CreateThreadFlags.None, threadId );

			return new Thread { _thread = thread, _threadId = threadId };
		}

		private static Thread _implStart( Delegates.Action action ) {
			uint threadId;
			var thread = new ThreadHandle( action, 0, CreateThreadFlags.None, threadId );

			return new Thread { _thread = thread, _threadId = threadId };
		}

		private static Thread _implCurrentThread() { return new Thread { _threadId = ThreadHandle.CurrentThreadID, _thread = ThreadHandle.Invalid }; }

		private static void _implSleep( int milliseconds ) { ThreadHandle.Sleep( ( uint ) milliseconds ); }

		private static void _implYield() { Kernel32Api.SwitchToThread(); }

		private void _implJoin() {
			var thread = _thread;
			if( thread == ThreadHandle.Invalid ) {
				if( _threadId == ThreadHandle.CurrentThreadID ) return;

				thread = Kernel32Api.OpenThread( ThreadAccessRights.SYNCHRONIZE, false, _threadId );
			}

			if( _threadId != ThreadHandle.CurrentThreadID ) thread.Join();
			thread.Dispose();
		}
	}
}