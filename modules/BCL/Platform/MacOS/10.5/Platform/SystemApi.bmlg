//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.Collections;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

using Platform.IO;

namespace Platform.Syscalls {
	[ExternLibrary]
	public static partial struct SystemApi {
		public static IOHandle StdIn { get { return new IOHandle( 0 ); } }
		public static IOHandle StdOut { get { return new IOHandle( 1 ); } }
		public static IOHandle StdErr { get { return new IOHandle( 2 ); } }

		private extern static SystemError* __error();
		public static SystemError LastError { get { return *__error(); } }

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=gettimeofday
		public extern static int gettimeofday( timeval& result, void* timezone );
		public extern static int settimeofday( timeval& value, void* timezone );

		public extern static CUtf8String* environ;

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=pipe
		public extern static int pipe( IOHandle[2]& handle ); // handle[0] for reading, handle[1] for writing

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=wait
		public extern static int wait( void* stat );
		public extern static int waitpid( int pid, int& status, ProcessWaitOptions options );
		// public extern static int waitid( idtype_t idtype, id_t id, siginfo_t& siginfo, ProcessWaitOptions options );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=wait4
		public extern static int wait3( int& status, int options, rusage& rusage );
		public extern static int wait4( int pid, int* status, int options, rusage& rusage );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=lseek
		public extern static long lseek( IOHandle handle, long offset, FileSeekOrigin origin );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getpid
		public extern static int getpid();
		public extern static int getppid();

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/mmap.2.html
		public extern static intptr mmap( void* start, uintptr length, MemoryMapProtection prot, MemoryMapFlags flags, IOHandle file, intptr offset );
		public extern static intptr munmap( void* start, uintptr length );

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/mprotect.2.html
		public extern static intptr mprotect( void* start, uintptr length, MemoryMapProtection prot );

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/mremap.2.html
		// public extern static intptr mremap( void* oldAddress, uintptr oldSize, uintptr newSize, MemoryRemapFlags flags, void* newAddress );

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/madvise.2.html
		// public extern static intptr madvise( void* start, uintptr length, MemoryAdvise advice );

		private const int _vsyscallTCBOffset = 0x10;

		private static Functors.Func<intptr> _vsyscall = GetVSyscallStub; // cached vsyscall ptr
		private static intptr GetVSyscallStub() asm {
			X86_32 {
				push dword ptr gs: [const( _vsyscallTCBOffset )]
				pop dword ptr [[_vsyscall]]
				jmp dword ptr [[_vsyscall]]
			}
		}

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=clock_gettime
		public extern static int clock_gettime( ClockType type, timespec& result );
		public extern static int clock_getres( ClockType type, timespec& result );
		public extern static int clock_settime( ClockType type, timespec& value );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getrlimit
		public extern static int getrlimit( ResourceLimit resource, rlimit& value );
		public extern static int setrlimit( ResourceLimit resource, rlimit& value );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getrusage
		public extern static int getrusage( ResourceUsageKind kind, rusage& usage );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=dup
		public extern static int dup( IOHandle oldfd );
		public extern static int dup2( IOHandle oldfd, IOHandle newfd );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getuid
		public extern static int getuid();
		public extern static int geteuid();

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getgid
		public extern static int getgid();
		public extern static int getegid();

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getpgrp
		public extern static int getpgrp();
		public extern static int getpgid( int pid );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=setpgrp
		public extern static int setpgrp();
		public extern static int setpgid( int pid, int pgid );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getgroups
		public extern static int getgroups( int size, int* list );
		public extern static int setgroups( int size, int* list );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=seteuid
		public extern static int seteuid( int euid );
		public extern static int setegid( int egid );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=setreuid
		public extern static int setreuid( int ruid, int euid );
		public extern static int setregid( int rgid, int egid );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=setsid
		public extern static int setsid();
		public extern static int getsid( int pid );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getresuid
		public extern static int getresuid( int& ruid, int& euid, int& suid );
		public extern static int getresgid( int& rgid, int& egid, int& sgid );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=setresuid
		public extern static int setresuid( int ruid, int euid, int suid );
		public extern static int setresgid( int rgid, int egid, int sgid );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=access
		public extern static int access( CUtf8String pathname, AccessTest mode );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=execve
		public extern static int execve( CUtf8String path, CUtf8String* argv, CUtf8String* envp );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=kill
		public extern static int kill( int pid, Signal signal );
		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=killpg
		public extern static int killpg( int pgrp, Signal signal );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=sigqueue
		public extern static int sigqueue( int pid, Signal signal, void* data );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=signal ; better to use sigaction
		public extern static Functors.Action<int> signal( Signal signal, Functors.Action<int> handler );
		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=sigaction
		public extern static int sigaction( SignalCode signum, sigaction& @new, sigaction& old );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=sigprocmask
		public extern static int sigprocmask( ApplySignalCommand command, sigset_t& @new, sigset_t& old );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=sigpending
		public extern static int sigpending( sigset_t& result );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=sigwaitinfo
		public extern static int sigwaitinfo( sigset_t& set, siginfo_t& info );
		public extern static int sigtimedwait( sigset_t& set, siginfo_t& info, timespec& timeout );

		public const Functors.Action<int> SIG_IGN = bitcast<Functors.Action<int>>( 1 );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=chroot
		public extern static SystemError chroot( CUtf8String path );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getdtablesize
		public extern static int getdtablesize();

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=chown
		public extern static int chown( CUtf8String file, int owner, int group );
		public extern static int lchown( CUtf8String file, int owner, int group );
		public extern static int fchown( IOHandle handle, int owner, int group );
		public extern static int fchownat( IOHandle directory, CUtf8String pathname, int owner, int group, SymlinkFollowOption option );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=link
		public extern static int link( CUtf8String source, CUtf8String target ); // hardlink
		public extern static int linkat( IOHandle olddirfd, CUtf8String oldpath, int newdirfd, CUtf8String newpath, SymlinkFollowOption option );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=symlink
		public extern static int symlink( CUtf8String source, CUtf8String target ); // symlink
		public extern static int symlinkat( CUtf8String oldpath, int newdirfd, CUtf8String newpath );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=readlink
		public extern static int readlink( CUtf8String path, byte* buffer, uint length );
		public extern static int readlinkat( IOHandle directory, CUtf8String pathname, byte* result, uint length );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=rename
		public extern static int rename( CUtf8String source, CUtf8String destination );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=fork
		public extern static int fork();
		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=vfork
		public extern static int vfork();

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=_exit
		public extern static void _exit( int code );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=rmdir
		public extern static int rmdir( CUtf8String path );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=chdir
		public extern static int chdir( CUtf8String path );
		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=fchdir
		public extern static int fchdir( IOHandle handle );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=stat
		public extern static int stat( CUtf8String path, stat& result );
		public extern static int fstat( IOHandle handle, stat& result );
		public extern static int lstat( CUtf8String path, stat& result );
		public extern static int fstatat( IOHandle directory, CUtf8String pathname, stat& buffer, SymlinkFollowOption option );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=mkdir
		public extern static int mkdir( CUtf8String path, Permission permission );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=chmod
		public extern static int chmod( CUtf8String path, Permission permission );
		public extern static int fchmod( IOHandle handle, Permission permission );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=open
		public extern static IOHandle open( CUtf8String name, FctlValue flags, int permissions );
		public extern static IOHandle openat( IOHandle directory, CUtf8String name, FctlValue flags, SymlinkFollowOption option );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=close
		public extern static int close( IOHandle handle );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=unlink
		public extern static int unlink( CUtf8String name );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=fsync
		public extern static int fsync( IOHandle handle );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=read
		public extern static int read( IOHandle handle, void* buffer, int count );
		public extern static int readv( IOHandle handle, iovec* vector, uint count );
		public extern static int pread( IOHandle handle, void* buf, uint nbytes, uint offset );
		public extern static int preadv( IOHandle handle, iovec* iov, int iovcnt, uint offset );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=write
		public extern static int write( IOHandle handle, void* buffer, int count );
		public extern static int writev( IOHandle handle, iovec* vector, uint count );
		public extern static int pwrite( IOHandle handle, void* buf, uint count, uint offset );
		public extern static int pwritev( IOHandle handle, iovec* iov, int iovcnt, uint offset );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=ioctl
		public extern static int ioctl( IOHandle handle, Ioctls option, void* result );
		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=fcntl
		// public extern static int fcntl( IOHandle handle, FctlCommand option );
		public extern static int fcntl( IOHandle handle, FctlCommand option, FctlValue value );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=kqueue
		public extern static KQueueHandle kqueue();
		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=kevent
		public extern static int kevent( KQueueHandle handle, kevent* changelist, int numChanges, kevent* eventlist, int numEvents, timespec& timeout );

		// EV_SET(&kev, ident, filter, flags, fflags, data, udata);
		// EV_SET64(&kev, ident, filter, flags, fflags, data, udata, ext[_], ext[1]);


		// KQueueHandle

		internal const uint RawErrorsMax = 125;

		internal static int raw_syscall( SystemCall code ) asm {
			X86_32 {
				mov eax, [esp + 4] // code
				push eax

				int 0x80
				add esp, 4

				ret
			}
		}

		internal static int raw_syscall( SystemCall code, int p1 ) asm {
			X86_32 {
				mov eax, [esp + 4]       // code

				push dword ptr [esp + 8] // p1
				push eax

				int 0x80
				add esp, 8

				ret
			}
		}

		internal static int raw_syscall( SystemCall code, int p1, int p2 ) asm {
			X86_32 {
				mov eax, [esp + 4]        // code

				push dword ptr [esp + 12] // p2
				push dword ptr [esp + 12] // p1
				push eax

				int 0x80
				add esp, 12

				ret
			}
		}

		internal static int raw_syscall( SystemCall code, int p1, int p2, int p3 ) asm {
			X86_32 {
				mov eax, [esp + 4]        // code

				push dword ptr [esp + 16] // p3
				push dword ptr [esp + 16] // p2
				push dword ptr [esp + 16] // p1
				push eax

				int 0x80
				add esp, 16

				ret
			}
		}

		internal static int raw_syscall( SystemCall code, int p1, int p2, int p3, int p4 ) asm {
			X86_32 {
				mov eax, [esp + 4]        // code

				push dword ptr [esp + 20] // p4
				push dword ptr [esp + 20] // p3
				push dword ptr [esp + 20] // p2
				push dword ptr [esp + 20] // p1

				int 0x80
				add esp, 20

				ret
			}
		}

		internal static int raw_syscall( SystemCall code, int p1, int p2, int p3, int p4, int p5 ) asm {
			X86_32 {
				mov eax, [esp + 4]        // code

				push dword ptr [esp + 24] // p5
				push dword ptr [esp + 24] // p4
				push dword ptr [esp + 24] // p3
				push dword ptr [esp + 24] // p2
				push dword ptr [esp + 24] // p1

				int 0x80
				add esp, 24

				ret
			}
		}

		internal static int raw_syscall( SystemCall code, int p1, int p2, int p3, int p4, int p5, int p6 ) asm {
			X86_32 {
				mov eax, [esp + 4]        // code

				push dword ptr [esp + 28] // p6
				push dword ptr [esp + 28] // p5
				push dword ptr [esp + 28] // p4
				push dword ptr [esp + 28] // p3
				push dword ptr [esp + 28] // p2
				push dword ptr [esp + 28] // p1

				int 0x80
				add esp, 28

				ret
			}
		}

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getdents
		public extern static int getdents( IOHandle handle, dirent* dirp, int length );
		public extern static int getdirentries( IOHandle handle, dirent* buffer, int length, int& position );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=socket
		public extern static SocketHandle socket( ProtocolFamily protocolFamily, SocketType type, IPProtocol protocol );
		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=socketpair
		public extern static int socketpair( ProtocolFamily protocolFamily, SocketType type, IPProtocol protocol, SocketHandle[2]& handle );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=connect
		public extern static int connect( SocketHandle handle, sockaddr& address, int length );
		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=bind
		public extern static int bind( SocketHandle handle, sockaddr& address, int length );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=listen
		public extern static int listen( SocketHandle handle, int backlog );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=accept
		public extern static SocketHandle accept( SocketHandle handle, sockaddr& clientAddress, int& addressLength );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getpeername
		public extern static int getpeername( SocketHandle handle, sockaddr& clientAddress, int& addressLength );
		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getsockname
		public extern static int getsockname( SocketHandle handle, sockaddr& addr, int& addrlen );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=shutdown
		public extern static int shutdown( SocketHandle handle, SocketShutdownOptions options );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=send
		public extern static int send( SocketHandle handle, void* data, int length, TransmissionFlags flags );
		public extern static int sendto( SocketHandle handle, void* buf, int length, TransmissionFlags flags, sockaddr& address, int addressLength );
		public extern static int sendmsg( SocketHandle handle, msghdr* message, TransmissionFlags flags );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=recv
		public extern static int recv( SocketHandle handle, void* data, int length, TransmissionFlags flags );
		public extern static int recvfrom( SocketHandle handle, void* buf, int length, TransmissionFlags flags, sockaddr& src_addr, int& addressLength );
		public extern static int recvmsg( SocketHandle handle, msghdr* message, TransmissionFlags flags );

		/// http://www.freebsd.org/cgi/man.cgi?sektion=2&query=getsockopt
		public extern static int getsockopt( SocketHandle handle, SocketPropertyGroup category, int property, void* value, int& length );
		public extern static int setsockopt( SocketHandle handle, SocketPropertyGroup category, int property, void* value, int length );

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/poll.2.html
		public extern static int poll( pollfd* descriptors, int count, int timeoutMilliseconds );

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/getitimer.2.html
		public extern static int getitimer( int which, itimerval& curr_value );
		public extern static int setitimer( int which, itimerval& new_value, itimerval& old_value );

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/faccessat.2.html
		public extern static int faccessat( IOHandle directory, CUtf8String pathname, AccessTest mode, SymlinkFollowOption flags );

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/futimesat.2.html
		public extern static int futimesat( IOHandle directory, CUtf8String path, timeval[2]& times );

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/mkdirat.2.html
		public extern static int mkdirat( IOHandle directory, CUtf8String pathname, Permission permission );

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/fchmodat.2.html
		public extern static int fchmodat( IOHandle directory, CUtf8String pathname, Permission permission, SymlinkFollowOption option );

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/unlinkat.2.html
		public extern static int unlinkat( IOHandle directory, CUtf8String pathname, SymlinkFollowOption option );

		/// http://www.kernel.org/doc/man-pages/online/pages/man2/renameat.2.html
		public extern static int renameat( IOHandle olddirfd, CUtf8String oldpath, int newdirfd, CUtf8String newpath );

		// public extern static int thr_create( ucontext_t& ctx, intptr& id, int flags );
		// public extern static int thr_new( thr_param& param, int param_size );
		public extern static int thr_self( intptr& id );
		public extern static void thr_exit( intptr& state );
		public extern static int thr_kill( intptr id, int sig );
		// public extern static int thr_kill2( pid_t pid, intptr id, int sig );
		public extern static int thr_suspend( timespec& timeout );
		public extern static int thr_wake( long id );
		public extern static int thr_set_name( long id, CUtf8String name );

		[ExternLibrary]
		public static struct Sctp {
			/// http://linux.die.net/man/3/sctp_bindx
			public extern static int sctp_bindx( SocketHandleSCTP sd, sockaddr* addrs, int addrcnt, int flags );
			// /// http://linux.die.net/man/3/sctp_connectx
			// public extern static int sctp_connectx( SocketHandleSCTP sd, sockaddr* addrs, int addrcnt, sctp_assoc_t* id );
			// /// http://linux.die.net/man/3/sctp_peeloff
			// public extern static int sctp_peeloff( SocketHandleSCTP sd, sctp_assoc_t assoc_id );
			// /// http://linux.die.net/man/3/sctp_opt_info
			// public extern static int sctp_opt_info( SocketHandleSCTP sd, sctp_assoc_t id, int opt, void* arg, socklen_t* size );
			// /// http://linux.die.net/man/3/sctp_getpaddrs
			// public extern static int sctp_getpaddrs( SocketHandleSCTP sd, sctp_assoc_t id, sockaddr** addrs );
			// /// http://linux.die.net/man/3/sctp_freepaddrs
			// public extern static int sctp_freepaddrs( sockaddr* addrs );
			// /// http://linux.die.net/man/3/sctp_getladdrs
			// public extern static int sctp_getladdrs( SocketHandleSCTP sd, sctp_assoc_t id, sockaddr** addrs );
			// /// http://linux.die.net/man/3/sctp_freeladdrs
			// public extern static int sctp_freeladdrs( sockaddr* addrs );
			/// http://linux.die.net/man/3/sctp_sendmsg
			public extern static int sctp_sendmsg( SocketHandleSCTP socket, void* data, int length, sockaddr& to, int tolen, uint ppid, SctpSendFlags flags, ushort stream_no, uint timetolive, uint context );
			/// http://linux.die.net/man/3/sctp_send
			public extern static int sctp_send( SocketHandleSCTP socket, void* data, int length, sctp_sndrcvinfo& sinfo, SctpSendFlags flags );
			/// http://linux.die.net/man/3/sctp_recvmsg
			public extern static int sctp_recvmsg( SocketHandleSCTP s, void* data, int length, sockaddr& from, int& fromLength, sctp_sndrcvinfo& info, int& flags );

			// public extern static int sctp_getaddrlen( sa_family_t family );
		}
	}

	public struct KQueueHandle : IOHandle {
		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		public KQueueHandle() {
			this = SystemApi.kqueue();
		}

		/// @{ For debugging purposes only. You must aggreagte changed events before wait in 'kevent()'
		public void Modify( kevent* newEvents, int length ) {
			Assert.Syscall( SystemApi.kevent( this, newEvents, length, null, 0, nullref ) );
		}

		public void Modify( vararg kevent newEvents ) {
			Modify( newEvents, ( int ) newEvents.Length );
		}

		/// @}
	}

	public partial struct kevent : IFormattable {
		public kevent() { }

		public kevent( IOHandle ident, KEventFilter filter, KEventAction flags )
			: this( ident.ID, filter, flags, 0, 0, null ) {
		}

		public kevent( IOHandle ident, KEventFilter filter, KEventAction flags, void* udata )
			: this( ident.ID, filter, flags, 0, 0, udata ) {
		}

		public kevent( Signal signal, KEventAction flags, void* udata )
			: this( ( uint ) signal, KEventFilter.EVFILT_SIGNAL, flags, 0, 0, udata ) {
		}

		public kevent( uint ident, TimeSpan interval, KEventAction flags, void* udata )
			: this( ident, KEventFilter.EVFILT_TIMER, flags, 0, ( int ) interval.TotalMilliseconds, udata ) {
		}

		public kevent( uint ident, KEventFilter filter, KEventAction flags, uint fflags, int data, void* udata ) {
			this.ident = ident;
			this.filter = filter;
			this.flags = flags;
			this.fflags = fflags;
			this.data = data;
			this.udata = udata;
		}

		public void ToString( StringBuilder builder, string format ) {
			builder.AppendFormat( "{{ ident={0} filter={1} flags={2} fflags={3} data={4} udata={5} }}", ident, filter, flags, fflags, data, udata );
		}
	}

	public partial struct sigset_t {
		public sigset_t() { Auxlib.AuxlibApi.sigemptyset( this ); }
		public sigset_t( vararg Signal signals )
			: this() {
			Add( vararg( signals, signals.Length ) );
		}

		public void Empty() { Auxlib.AuxlibApi.sigemptyset( this ); }
		public void Fill() { Auxlib.AuxlibApi.sigfillset( this ); }

		public void Add( vararg Signal signals ) { foreach( var signal in signals ) Add( signal ); }
		public void Remove( vararg Signal signals ) { foreach( var signal in signals ) Remove( signal ); }

		public void Add( Signal signal ) { Auxlib.AuxlibApi.sigaddset( this, signal ); }
		public void Remove( Signal signal ) { Auxlib.AuxlibApi.sigdelset( this, signal ); }

		public bool Contains( Signal signal ) { return Auxlib.AuxlibApi.sigismember( this, signal ) == 0; }

		private const int MaxSignals = sizeof( thistype ) * 8;

		public yield<Signal> GetEnumerator() {
			var accessor = new BitArrayAccessor( ( uint* ) &this, MaxSignals );
			for( var i = 0; i < MaxSignals; ++i ) {
				if( accessor[i] )
					yield return ( Signal )( i + 1 );
			}
		}
	}

	[PrimitiveType( Size = sizeof( uint ) )]
	public struct IOHandle : IFormattable {
		public static IOHandle Invalid { get { return new IOHandle( -1 ); } }
		public bool IsValid { get { return this != Invalid; } }

		public IOHandle( int handle ) {
			this = bitcast<IOHandle>( handle );
		}

		public void Close() {
			if( this != Invalid )
				Assert.Syscall( SystemApi.close( this ) );

			this = Invalid;
		}

		public void Dispose() {
			Close();
		}

		public bool IsClosedOnExec {
			get {
				FctlValue options;
				if( !Assert.Syscall( options = ( FctlValue ) SystemApi.fcntl( this, FctlCommand.F_GETFD, 0 ) ) )
					return false;

				return ( options & FctlValue.FD_CLOEXEC ) != 0;
			}
			set {
				FctlValue options;
				if( !Assert.Syscall( options = ( FctlValue ) SystemApi.fcntl( this, FctlCommand.F_GETFD, 0 ) ) )
					return;

				options = ( FctlValue ) BitOperations.MaskSet( options.Value(), FctlValue.FD_CLOEXEC.Value(), value );

				Assert.Syscall( SystemApi.fcntl( this, FctlCommand.F_SETFD, options ) );
			}
		}

		public bool IsNonBlocking {
			get {
				FctlValue options;
				if( !Assert.Syscall( options = ( FctlValue ) SystemApi.fcntl( this, FctlCommand.F_GETFL, 0 ) ) )
					return false;

				return ( options & FctlValue.O_NONBLOCK ) != 0;
			}
			set {
				FctlValue options;
				if( !Assert.Syscall( options = ( FctlValue ) SystemApi.fcntl( this, FctlCommand.F_GETFL, 0 ) ) )
					return;

				options = ( FctlValue ) BitOperations.MaskSet( options.Value(), FctlValue.O_NONBLOCK.Value(), value );

				Assert.Syscall( SystemApi.fcntl( this, FctlCommand.F_SETFL, options ) );
			}
		}

		public int AvailableBytes {
			get {
				int result;
				Assert.Syscall( SystemApi.ioctl( this, Ioctls.FIONREAD, &result ) );
				return result;
			}
		}

		public void DropAvailableBytes() {
			uint bufferLength;
			byte* buffer;
			var available = AvailableBytes;

			if( !IO.Fiber.GetIOBuffer( buffer, bufferLength ) ) {
				bufferLength = 16384;
				buffer = stackalloc byte[bufferLength];
			}

			while( available > 0 ) {
				var readen = SystemApi.read( this, buffer, Math.Min( available, ( int ) bufferLength ) );
				if( readen <= 0 ) break;

				available -= readen;
			}
		}

		public uint ID {
			get { return bitcast<uint>( this ); }
		}

		protected void DumpRelevantData( StringBuilder builder ) {
			builder.AppendFormat( " ID={0} nonblock={1} cloexec={2}", ID, IsNonBlocking, IsClosedOnExec );

			int availableBytes;
			if( SystemApi.ioctl( this, Ioctls.FIONREAD, &availableBytes ) >= 0 ) builder.AppendFormat( " AvailableBytes={0}", availableBytes );
			else builder.AppendFormat( " AvailableBytes={0}", "---" );
		}

		public void ToString( StringBuilder builder, string format ) {
			builder.Append( "{" );
			DumpRelevantData( builder );
			builder.Append( " }" );
		}
	}

	public partial struct sockaddr {
		public byte Length;
		public ProtocolFamily ProtocolFamily;
	}

	public partial struct sockaddr_in : sockaddr, IFormattable {
		public sockaddr_in( System.Net.IPv4Address address, ushort port ) {
			Length = sizeof( thistype );
			ProtocolFamily = Platform.Syscalls.ProtocolFamily.PF_INET;
			Address = address.UIntData;
			Port = port;
		}
		public static explicit operator sockaddr_in( System.Net.IPv4Endpoint& endpoint ) {
			return new sockaddr_in( endpoint.Address, endpoint.Port );
		}

		public static explicit operator System.Net.IPv4Endpoint( sockaddr_in& @this ) {
			return new System.Net.IPv4Endpoint( new System.Net.IPv4Address( @this.Address ), @this.Port );
		}

		public void ToString( StringBuilder builder, string format ) {
			cast<System.Net.IPv4Endpoint>( this ).ToString( builder, format );
		}
	}

	// public partial struct sockaddr_in6 : sockaddr, IFormattable {
	// 	public sockaddr_in6( System.Net.IPv6Address address, ushort port ) {
	// 		ProtocolFamily = Platform.Syscalls.ProtocolFamily.PF_INET6;
	// 		Address = address.Data;
	// 		Port = port;
	// 	}

	// 	public static explicit operator sockaddr_in6( System.Net.IPv6Endpoint& endpoint ) {
	// 		return new sockaddr_in6( endpoint.Address, endpoint.Port );
	// 	}

	// 	public static explicit operator System.Net.IPv6Endpoint( sockaddr_in6& @this ) {
	// 		return new System.Net.IPv6Endpoint( new System.Net.IPv6Address( @this.Address ), @this.Port );
	// 	}

	// 	public void ToString( StringBuilder builder, string format ) {
	// 		cast<System.Net.IPv6Endpoint>( this ).ToString( builder, format );
	// 	}
	// }

	public partial struct sockaddr_un : sockaddr {
		public sockaddr_un( Utf8String path ) {
			if( !Assert.IsTrue( path.ByteLength < Path.Length ) ) return;

			ProtocolFamily = Platform.Syscalls.ProtocolFamily.PF_UNIX;
			Memory.Copy( &Path[0], path.GetChars(), path.ByteLength + 1 );
		}

		public bool IsAbstract { get { return Path[0] == 0; } }
	}

	public struct FileHandle : IOHandle {
		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		public FileHandle( CUtf8String name, FctlValue flags, int permissions ) {
			Assert.Syscall( this = bitcast<FileHandle>( SystemApi.open( name, flags, permissions ) ) );
		}

		public void Write( vararg iovec vectors ) {
			Assert.Syscall( SystemApi.writev( this, &vectors[0], vectors.Length ) );
		}

		public int Read( vararg iovec vectors ) {
			int result;
			Assert.Syscall( result = SystemApi.readv( this, &vectors[0], vectors.Length ) );
			return result;
		}
	}

	public struct PipeHandle : IOHandle {
		public const int ReadEnd = 0;
		public const int WriteEnd = 1;

		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		public int Write( void* buffer, int count ) {
			int result = 0;
			Assert.Syscall( result = SystemApi.write( this, buffer, count ) );
			return result;
		}

		public int Read( void* buffer, int count ) {
			int result = 0;
			Assert.Syscall( result = SystemApi.read( this, buffer, count ) );
			return result;
		}

		public void WriteByte( byte value ) { Write( &value, sizeof( value ) ); }
	}

	[StructLayoutSequential]
	struct accept_filter_arg {
		byte[16] af_name;
		byte[256 - 16] af_arg;
	}

	public struct SocketHandle : IOHandle, IFormattable {
		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		public bool Listen( int backlog ) {
			return Assert.Syscall( SystemApi.listen( this, backlog ) );
		}

		public int Send( vararg iovec data ) {
			int result = 0;
			Assert.Syscall( result = SystemApi.writev( this, data, data.Length ) );
			return result;
		}

		public int Send( void* buffer, int count ) {
			if( Fiber.Enabled ) {
				var result = 0;

			restart:
				// SystemApi.ErrorNumber = SystemError.None;
				var written = SystemApi.write( this, buffer, count );
				var errno = SystemApi.LastError;

				if( Fiber.Trace & Fiber.Enabled ) Console.WriteLine( "[{0:D2}]----> Send    errno: {1}; written == {2}; count = {3}\t{4}.{4:ffffff}", Fiber.Current->ID, errno, written, count, DateTime.Now );
				// if( errno == SystemError.EINPROGRESS ) Console.WriteLine( "[{0:D2}] Send EINPROGRESS: {1}", Fiber.Current->ID, written );

				if( written <= 0 )
					switch( errno ) {
						case SystemError.None: return written;
						case SystemError.EINTR: goto restart;

						case SystemError.EAGAIN:
						case SystemError.EINPROGRESS: {
								if( written == -1 ) { Fiber.WaitForWrite( this ); goto restart; }
								buffer = ( byte* ) buffer + written;
								result += written;
								count -= written;
								if( count > 0 && written > 0 ) goto restart; // ensure all bytes are send

								return result;
							}

						default:
							Assert.Fail( "{0} Handle={1}", errno, ID );
							return result;
					}
				else
					return written;
			}
			else {
				int result = 0;
				Assert.Syscall( result = SystemApi.write( this, buffer, count ) );
				return result;
			}
		}

		public int Receive( void* buffer, int count ) {
			if( Fiber.Enabled ) {
			restart:
				// SystemApi.ErrorNumber = SystemError.None;
				var readen = SystemApi.read( this, buffer, count );
				var errno = SystemApi.LastError;

				if( Fiber.Trace & Fiber.Enabled ) Console.WriteLine( "[{0:D2}]<---- Receive errno: {1}; readen = {2}; count = {3}; avail = {4}\t{5}.{5:ffffff}", Fiber.Current->ID, errno, readen, count, AvailableBytes, DateTime.Now );
				// if( errno == SystemError.EINPROGRESS ) Console.WriteLine( "[{0:D2}] Receive EINPROGRESS: {1}", Fiber.Current->ID, readen );

				if( readen <= 0 )
					switch( errno ) {
						case SystemError.None: return readen;
						case SystemError.EINTR: goto restart;

						case SystemError.EAGAIN:
						case SystemError.EINPROGRESS: {
								if( readen == -1 ) { Fiber.WaitForRead( this ); goto restart; }
								if( readen <= 0 ) Console.WriteLine( "readen == {0}", readen );
								return readen;
							}

						default:
							Assert.Fail( "{0} Handle={1} count={2} readen={3} buffer={4}", errno, ID, count, readen, buffer );
							return 0;
					}
				else
					return readen;
			}
			else {
				int result = 0;
				Assert.Syscall( result = SystemApi.read( this, buffer, count ) );
				return result;
			}
		}

		public TimeSpan ReadTimeout {
			get {
				var result = default( timeval );
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_RCVTIMEO, &result, sizeof( result ) ) );
				return ( TimeSpan ) result;
			}
			set {
				var timeout = new timeval( value );
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_RCVTIMEO, &timeout, sizeof( timeout ) ) );
			}
		}

		public TimeSpan WriteTimeout {
			get {
				var result = default( timeval );
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_SNDTIMEO, &result, sizeof( result ) ) );
				return ( TimeSpan ) result;
			}
			set {
				var timeout = new timeval( value );
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_SNDTIMEO, &timeout, sizeof( timeout ) ) );
			}
		}

		public bool ReuseAddress {
			get {
				Boolean32 result = false;
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_REUSEADDR, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Boolean32 result = value;
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_REUSEADDR, &result, sizeof( result ) ) );
			}
		}

		public bool IsListening {
			get {
				Boolean32 result = false;
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_ACCEPTCONN, &result, sizeof( result ) ) );
				return result;
			}
		}

		public bool IsBroadcast {
			get {
				Boolean32 result = false;
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_BROADCAST, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Boolean32 result = value;
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_BROADCAST, &result, sizeof( result ) ) );
			}
		}

		public bool IsDebugged {
			get {
				Boolean32 result = false;
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_DEBUG, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Boolean32 result = value;
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_DEBUG, &result, sizeof( result ) ) );
			}
		}

		public bool IsRouteDisabled {
			get {
				Boolean32 result = false;
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_DONTROUTE, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Boolean32 result = value;
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_DONTROUTE, &result, sizeof( result ) ) );
			}
		}

		public bool IsTimpestampEnabled {
			get {
				Boolean32 result = false;
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_TIMESTAMP, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Boolean32 result = value;
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_TIMESTAMP, &result, sizeof( result ) ) );
			}
		}

		public int SendBufferSize {
			get {
				int result = 0;
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_SNDBUF, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_SNDBUF, &value, sizeof( value ) ) );
			}
		}

		public int ReceiveBufferSize {
			get {
				int result = 0;
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_RCVBUF, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_RCVBUF, &value, sizeof( value ) ) );
			}
		}

		public bool AttachAcceptFilter( CString name, CString parameter = "" ) {
			var value = default( accept_filter_arg );
			CString.Copy( new CString( &value.af_name[0] ), name );
			CString.Copy( new CString( &value.af_arg[0] ), parameter );

			if( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_ACCEPTFILTER, &value, sizeof( value ) ) < 0 ) {
				var errno = SystemApi.LastError;
				if( errno == SystemError.ENOENT ) return false;

				return Assert.Syscall( -1 );
			}

			return true;
		}

		protected new void DumpRelevantData( StringBuilder builder ) {
			base.DumpRelevantData( builder );

			builder.AppendFormat( " Listen={0} sndbuf={1} rcvbuf={2} timestamp={3} donroute={4} debugged={5} broadcast={6} reuse={7} ReadTimeout={8} WriteTimeout={9}", IsListening, SendBufferSize, ReceiveBufferSize, IsTimpestampEnabled, IsRouteDisabled, IsDebugged, IsBroadcast, ReuseAddress, ReadTimeout, WriteTimeout );
		}

		public new void ToString( StringBuilder builder, string format ) {
			builder.Append( "{" );
			DumpRelevantData( builder );
			builder.Append( " }" );
		}
	}

	// http://www.kernel.org/doc/man-pages/online/pages/man7/unix.7.html
	public struct SocketHandleLocal : SocketHandle {
		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		public SocketHandleLocal( SocketType type ) {
			Assert.Syscall( this = bitcast<SocketHandleLocal>( SystemApi.socket( ProtocolFamily.PF_UNIX, type, IPProtocol.IPPROTO_IP ) ) );
			if( Fiber.Enabled ) IsNonBlocking = true;

			if( Fiber.Trace ) Console.WriteLine( "{0}.{0:ffffff} Socket created: ID={1} errno={2} Fiber.Enabled={3} nonbl={4}", DateTime.UtcNow, ID, SystemApi.LastError, Fiber.Enabled, IsNonBlocking );
		}

		public bool Connect( Utf8String path ) {
			return Connect( path, false );
		}

		public bool Connect( Utf8String path, bool waitForReceive ) {
			var nativeEndpoint = new sockaddr_un( path );

			if( Fiber.Enabled ) {
				var result = SystemApi.connect( this, nativeEndpoint, sizeof( nativeEndpoint ) );
				var errno = SystemApi.LastError;

				if( Fiber.Trace & Fiber.Enabled ) Console.WriteLine( "[{0:D2}]----> Connect '{1}' errno: {2}", Fiber.Current->ID, ID, errno );
				// Console.WriteLine( "Connected: Handle={0} path='{1}'", ID, path );

				switch( errno ) {
					case SystemError.None:
						return result == 0;

					case SystemError.EAGAIN:
					case SystemError.EINPROGRESS: {
							var result2 = Fiber.WaitForConnect( this, waitForReceive );
							return result2;
						}

					default:
						Assert.Syscall( result );
						return false;
				}
			}
			else
				return Assert.Syscall( SystemApi.connect( this, nativeEndpoint, sizeof( nativeEndpoint ) ) );
		}

		public bool Bind( Utf8String path ) {
			var nativeEndpoint = new sockaddr_un( path );
			return SystemApi.bind( this, nativeEndpoint, sizeof( nativeEndpoint ) ) == 0;
		}

		public static bool Exists( Utf8String path ) {
			stat stat;
			if( SystemApi.stat( path, stat ) < 0 ) return false;

			return stat.IsSocket;
		}

		// public bool ReceiveCredentials {
		// 	get {
		// 		int result;
		// 		Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_PASSCRED, &result, sizeof( result ) ) ); // SOL_SOCKET for historical reasons
		// 		return result != 0;
		// 	}
		// 	set {
		// 		var result = ( int ) value;
		// 		Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_PASSCRED, &result, sizeof( result ) ) ); // SOL_SOCKET for historical reasons
		// 	}
		// }

		// public ucred PeerCredentials {
		// 	get {
		// 		ucred result;
		// 		Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_PEERCRED, &result, sizeof( result ) ) ); // SOL_SOCKET for historical reasons
		// 		return result;
		// 	}
		// }

		public static SocketHandleLocal[2] CreatePair( SocketType type = SocketType.SOCK_DGRAM ) {
			SocketHandle[2] result;
			Assert.Syscall( SystemApi.socketpair( ProtocolFamily.PF_UNIX, type, IPProtocol.IPPROTO_IP, result ) );
			return bitcast<SocketHandleLocal[2]>( result );
		}
	}

	// http://www.freebsd.org/cgi/man.cgi?query=tcp&sektion=4&apropos=0&manpath=FreeBSD+8.2-RELEASE
	public struct SocketHandleTCP : SocketHandle, IFormattable {
		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		public SocketHandleTCP() {
			Assert.Syscall( this = bitcast<SocketHandleTCP>( SystemApi.socket( ProtocolFamily.PF_INET, SocketType.SOCK_STREAM, IPProtocol.IPPROTO_TCP ) ) );
			if( Fiber.Enabled ) IsNonBlocking = true;

			if( Fiber.Trace ) Console.WriteLine( "{0}.{0:ffffff} Socket created: ID={1} errno={2} Fiber.Enabled={3} nonbl={4}", DateTime.UtcNow, ID, SystemApi.LastError, Fiber.Enabled, IsNonBlocking );
		}

		public bool Connect( System.Net.IPv4Endpoint endpoint ) {
			return Connect( endpoint, false );
		}

		public bool Connect( System.Net.IPv4Endpoint endpoint, bool waitForReceive ) {
			var nativeEndpoint = new sockaddr_in( endpoint.Address, endpoint.Port );

			if( Fiber.Enabled ) {
				var result = SystemApi.connect( this, nativeEndpoint, sizeof( nativeEndpoint ) );
				var errno = SystemApi.LastError;

				if( Fiber.Trace ) Console.WriteLine( "[{0:D2}]----> Connect '{1}' errno: {2}", Fiber.Current->ID, ID, errno );

				switch( errno ) {
					case SystemError.None:
						return result == 0;

					case SystemError.EAGAIN:
					case SystemError.EINPROGRESS: {
							var result2 = Fiber.WaitForConnect( this, waitForReceive );
							return result2;
						}

					default:
						Assert.Syscall( result );
						return false;
				}
			}
			else
				return Assert.Syscall( SystemApi.connect( this, nativeEndpoint, sizeof( nativeEndpoint ) ) );
		}

		public bool Bind( System.Net.IPv4Endpoint endpoint ) {
			var nativeEndpoint = new sockaddr_in( endpoint.Address, endpoint.Port );
			return SystemApi.bind( this, nativeEndpoint, sizeof( nativeEndpoint ) ) == 0;
		}

		public static bool IsIPv4PortFree( ushort port ) {
			var handle = SystemApi.socket( ProtocolFamily.PF_INET, SocketType.SOCK_STREAM, IPProtocol.IPPROTO_TCP );
			handle.ReuseAddress = true;

			var nativeEndpoint = new sockaddr_in( System.Net.IPv4Address.Loopback, port );
			var result = SystemApi.bind( handle, nativeEndpoint, sizeof( nativeEndpoint ) );

			handle.Close();
			return result == 0;
		}

		// If true - send first packet immediately and fill buffer until acknowledgment is received
		// Note: TCP_CORK and TCP_NODELAY are mutually exclusive  before Linux 2.5.71
		public bool ImmediateDelivery {
			get {
				Boolean32 result = false; // for some reason I got VG warning here
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_TCP, TcpProperty.TCP_NODELAY, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Boolean32 result = value;
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_TCP, TcpProperty.TCP_NODELAY, &result, sizeof( result ) ) );
			}
		}

		// http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html
		public bool KeepAliveEnabled {
			get {
				Boolean32 result = false;
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_KEEPALIVE, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Boolean32 result = value;
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SOCKET, SocketProperty.SO_KEEPALIVE, &result, sizeof( result ) ) );
			}
		}

		// public int KeepAliveProbesMax {
		// 	get {
		// 		int result;
		// 		Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_TCP, TcpProperty.TCP_KEEPCNT, &result, sizeof( result ) ) );
		// 		return result;
		// 	}
		// 	set {
		// 		Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_TCP, TcpProperty.TCP_KEEPCNT, &value, sizeof( value ) ) );
		// 	}
		// }

		// public int KeepAliveIdleSeconds {
		// 	get {
		// 		int result;
		// 		Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_TCP, TcpProperty.TCP_KEEPIDLE, &result, sizeof( result ) ) );
		// 		return result;
		// 	}
		// 	set {
		// 		Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_TCP, TcpProperty.TCP_KEEPIDLE, &value, sizeof( value ) ) );
		// 	}
		// }

		// public int KeepAliveProbingIntervalSeconds {
		// 	get {
		// 		int result;
		// 		Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_TCP, TcpProperty.TCP_KEEPINTVL, &result, sizeof( result ) ) );
		// 		return result;
		// 	}
		// 	set {
		// 		Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_TCP, TcpProperty.TCP_KEEPINTVL, &value, sizeof( value ) ) );
		// 	}
		// }

		// http://en.wikipedia.org/wiki/Maximum_segment_size
		public int MaximumSegmentSize {
			get {
				int result = 0;
				Assert.Syscall( SystemApi.getsockopt( this, SocketPropertyGroup.SOL_TCP, TcpProperty.TCP_MAXSEG, &result, sizeof( result ) ) );
				return result;
			}
			set {
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_TCP, TcpProperty.TCP_MAXSEG, &value, sizeof( value ) ) );
			}
		}

		protected new void DumpRelevantData( StringBuilder builder ) {
			var keepAlive = KeepAliveEnabled;

			base.DumpRelevantData( builder );

			builder.AppendFormat( " NoDelay={0} MSS={1} KeepAlive={2}", ImmediateDelivery, MaximumSegmentSize, keepAlive );
			// if( keepAlive )
			//	builder.AppendFormat( " KeepAliveProbesMax={0} KeepAliveProbingIntervalSeconds={1} KeepAliveIdleSeconds={2}", KeepAliveProbesMax, KeepAliveProbingIntervalSeconds, KeepAliveIdleSeconds );
		}

		public new void ToString( StringBuilder builder, string format ) {
			builder.Append( "{" );
			DumpRelevantData( builder );
			builder.Append( " }" );
		}
	}

	// http://www.kernel.org/doc/man-pages/online/pages/man7/udp.7.html
	public struct SocketHandleUDP : SocketHandle, IFormattable {
		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		public SocketHandleUDP() {
			Assert.Syscall( this = bitcast<SocketHandleUDP>( SystemApi.socket( ProtocolFamily.PF_INET, SocketType.SOCK_DGRAM, IPProtocol.IPPROTO_UDP ) ) );
		}

		public bool Bind( System.Net.IPv4Endpoint endpoint ) {
			var nativeEndpoint = new sockaddr_in( endpoint.Address, endpoint.Port );
			return SystemApi.bind( this, nativeEndpoint, sizeof( nativeEndpoint ) ) == 0;
		}

		public static bool IsIPv4PortFree( ushort port ) {
			var handle = SystemApi.socket( ProtocolFamily.PF_INET, SocketType.SOCK_DGRAM, IPProtocol.IPPROTO_UDP );
			handle.ReuseAddress = true;

			var nativeEndpoint = new sockaddr_in { ProtocolFamily = ProtocolFamily.PF_INET, Port = port, Address = System.Net.IPv4Address.Loopback.UIntData };
			var result = SystemApi.bind( handle, nativeEndpoint, sizeof( nativeEndpoint ) );

			handle.Close();
			return result == 0;
		}

		public int Send( sockaddr_in& address, void* buffer, int count ) {
			int result = 0;
			Assert.Syscall( result = SystemApi.sendto( this, buffer, count, TransmissionFlags.None, address, sizeof( address ) ) );
			return result;
		}

		public int Receive( sockaddr_in& address, void* buffer, int count ) {
			int result = 0;
			Assert.Syscall( result = SystemApi.recvfrom( this, buffer, count, TransmissionFlags.None, address, sizeof( address ) ) );
			return result;
		}

		protected new void DumpRelevantData( StringBuilder builder ) {
			base.DumpRelevantData( builder );
		}

		public new void ToString( StringBuilder builder, string format ) {
			builder.Append( "{" );
			DumpRelevantData( builder );
			builder.Append( " }" );
		}
	}

	public struct SocketHandleRaw : SocketHandle, IFormattable {
		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		public SocketHandleRaw() {
			Assert.Syscall( this = bitcast<SocketHandleRaw>( SystemApi.socket( ProtocolFamily.PF_INET, SocketType.SOCK_RAW, IPProtocol.IPPROTO_ICMP ) ) );
		}

		public int Send( sockaddr_in& address, void* buffer, int count ) {
			int result = 0;
			Assert.Syscall( result = SystemApi.sendto( this, buffer, count, TransmissionFlags.None, address, sizeof( address ) ) );
			return result;
		}

		public int Receive( sockaddr_in& address, void* buffer, int count ) {
			int result = 0;
			Assert.Syscall( result = SystemApi.recvfrom( this, buffer, count, TransmissionFlags.None, address, sizeof( address ) ) );
			return result;
		}

		protected new void DumpRelevantData( StringBuilder builder ) {
			base.DumpRelevantData( builder );
		}

		public new void ToString( StringBuilder builder, string format ) {
			builder.Append( "{" );
			DumpRelevantData( builder );
			builder.Append( " }" );
		}
	}

	public struct SocketHandleSCTP : SocketHandle, IFormattable {
		public static new thistype Invalid { get { return bitcast<thistype>( basetype.Invalid ); } }

		public sctp_initmsg InitMessage {
			set {
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SCTP, SctpProperty.SCTP_INITMSG, &value, sizeof( value ) ) );
			}
		}

		public sctp_event_subscribe Events {
			set {
				Assert.Syscall( SystemApi.setsockopt( this, SocketPropertyGroup.SOL_SCTP, SctpProperty.SCTP_EVENTS, &value, sizeof( value ) ) );
			}
		}

		protected new void DumpRelevantData( StringBuilder builder ) {
			base.DumpRelevantData( builder );
		}

		public new void ToString( StringBuilder builder, string format ) {
			builder.Append( "{" );
			DumpRelevantData( builder );
			builder.Append( " }" );
		}
	}

	[Flags]
	public enum Permission {
		None,

		OthersExecute,
		OthersWrite,
		OthersRead,

		GroupExecute,
		GroupWrite,
		GroupRead,

		OwnerExecute,
		OwnerWrite,
		OwnerRead,
	}

	public partial struct dirent {
		public int INode;
		public int Offset;
		public ushort Length;
		public DirectoryEntryType Type;
		public byte[1] Name; // variable-length
	}

	public partial struct stat {
		public bool IsFile { get { return !IsDirectory; } }
		public bool IsDirectory { get { return ( st_mode & StatFlags.S_IFDIR ) == StatFlags.S_IFDIR; } }
		public bool IsSymlink { get { return ( st_mode & StatFlags.S_IFLNK ) == StatFlags.S_IFLNK; } }
		public bool IsCharacterSpecial { get { return ( st_mode & StatFlags.S_IFCHR ) == StatFlags.S_IFCHR; } }
		public bool IsSocket { get { return ( st_mode & StatFlags.S_IFSOCK ) == StatFlags.S_IFSOCK; } }

		// public DateTime CreationTime { get { return ( DateTime ) st_ctim; } }
		// public DateTime LastAccessTime { get { return ( DateTime ) st_atim; } }
		// public DateTime LastModificationTime { get { return ( DateTime ) st_mtim; } }
	}

	public partial struct iovec {
		public iovec( void* address, uint length ) { Address = address; Length = length; }

		public static implicit operator iovec( MemorySegment& value ) { return new iovec( value.Start, ( uint ) value.Count ); }
	}

	public static partial struct AdaptationLayer {
		public static FileSeekOrigin MapSeekOrigin( System.IO.SeekOrigin value ) {
			[CheckAllEnumValues]
			switch( value ) {
				case System.IO.SeekOrigin.Begin: return FileSeekOrigin.SEEK_SET;
				case System.IO.SeekOrigin.Current: return FileSeekOrigin.SEEK_CUR;
				case System.IO.SeekOrigin.End: return FileSeekOrigin.SEEK_END;
			}

			Assert.InvalidParameter( nameof( value ) );
			return FileSeekOrigin.SEEK_SET;
		}

		public static System.IO.SeekOrigin MapSeekOrigin( FileSeekOrigin value ) {
			[CheckAllEnumValues]
			switch( value ) {
				case FileSeekOrigin.SEEK_SET: return System.IO.SeekOrigin.Begin;
				case FileSeekOrigin.SEEK_CUR: return System.IO.SeekOrigin.Current;
				case FileSeekOrigin.SEEK_END: return System.IO.SeekOrigin.End;
			}

			Assert.InvalidParameter( nameof( value ) );
			return System.IO.SeekOrigin.Begin;
		}

		// public const bool IsMemorySegmentLayoutEqualsToIovec = memberinfo( MemorySegment.Start ).ByteOffset == memberinfo( iovec.Address ).ByteOffset && sizeof( MemorySegment ) == sizeof( iovec );
		public const bool IsMemorySegmentLayoutEqualsToIovec = sizeof( MemorySegment ) == sizeof( iovec );
	}

	[Flags]
	public enum MemoryMapProtection : int {
		PROT_EXEC =  4,
		PROT_READ =  1,
		PROT_WRITE = 2,
		PROT_NONE =  0,
	}

	[Flags]
	public enum MemoryMapFlags : int {
		MAP_FIXED =        16,
		MAP_SHARED =        1,
		MAP_PRIVATE =       2,
		MAP_DENYWRITE =  2048,
		MAP_EXECUTABLE = 4096,
		MAP_NORESERVE = 16384,
		MAP_LOCKED =     8192,
		MAP_GROWSDOWN =   256,
		MAP_ANONYMOUS =    32,
		MAP_ANON =         32,
		MAP_FILE =          0,
		MAP_POPULATE =  32768,
		MAP_NONBLOCK =  65536,
	}

	public enum MemoryRemapFlags : uint {
		None =           0,
		MREMAP_MAYMOVE = 1,
	}

	public enum MemoryAdvise : uint {
		MADV_NORMAL =     0,
		MADV_RANDOM =     1,
		MADV_SEQUENTIAL = 2,
		MADV_WILLNEED =   3,
		MADV_DONTNEED =   4,
	}
}