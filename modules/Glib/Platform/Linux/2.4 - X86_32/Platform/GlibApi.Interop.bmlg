//
// Created by Eugeny Grishul
//
// See license at http://bamelg.com/license.txt
//

using System;
using System.Runtime.InteropServices;

using Platform.Libc;

namespace Platform.Glib {
	[ExternLibrary( Image = "/usr/lib/libglib-2.0.so" )]
	public static partial struct GlibApi {
		public extern static GArray* g_array_append_vals( GArray* array, void* data, uint len );
		public extern static sbyte* g_array_free( GArray* array, Boolean32 freeSegment );
		public extern static GArray* g_array_insert_vals( GArray* array, uint index_, void* data, uint len );
		public extern static GArray* g_array_new( Boolean32 zeroTerminated, Boolean32 clear_, uint elementSize );
		public extern static GArray* g_array_prepend_vals( GArray* array, void* data, uint len );
		public extern static GArray* g_array_remove_index( GArray* array, uint index_ );
		public extern static GArray* g_array_remove_index_fast( GArray* array, uint index_ );
		public extern static GArray* g_array_remove_range( GArray* array, uint index_, uint length );
		public extern static GArray* g_array_set_size( GArray* array, uint length );
		public extern static GArray* g_array_sized_new( Boolean32 zeroTerminated, Boolean32 clear_, uint elementSize, uint reservedSize );
		public extern static void g_array_sort( GArray* array, Functors.Func<void*, void*, int> compareFunc );
		public extern static void g_array_sort_with_data( GArray* array, Functors.Func<void*, void*, void*, int> compareFunc, void* userData );
		public extern static GByteArray* g_byte_array_append( GByteArray* array, byte* data, uint len );
		public extern static byte* g_byte_array_free( GByteArray* array, Boolean32 freeSegment );
		public extern static GByteArray* g_byte_array_new();
		public extern static GByteArray* g_byte_array_prepend( GByteArray* array, byte* data, uint len );
		public extern static GByteArray* g_byte_array_remove_index( GByteArray* array, uint index_ );
		public extern static GByteArray* g_byte_array_remove_index_fast( GByteArray* array, uint index_ );
		public extern static GByteArray* g_byte_array_remove_range( GByteArray* array, uint index_, uint length );
		public extern static GByteArray* g_byte_array_set_size( GByteArray* array, uint length );
		public extern static GByteArray* g_byte_array_sized_new( uint reservedSize );
		public extern static void g_byte_array_sort( GByteArray* array, Functors.Func<void*, void*, int> compareFunc );
		public extern static void g_byte_array_sort_with_data( GByteArray* array, Functors.Func<void*, void*, void*, int> compareFunc, void* userData );
		public extern static void g_ptr_array_add( GPtrArray* array, void* data );
		public extern static void g_ptr_array_foreach( GPtrArray* array, Functors.Action<void*, void*> func, void* userData );
		public extern static void** g_ptr_array_free( GPtrArray* array, Boolean32 freeSeg );
		public extern static GPtrArray* g_ptr_array_new();
		public extern static Boolean32 g_ptr_array_remove( GPtrArray* array, void* data );
		public extern static Boolean32 g_ptr_array_remove_fast( GPtrArray* array, void* data );
		public extern static void* g_ptr_array_remove_index( GPtrArray* array, uint index_ );
		public extern static void* g_ptr_array_remove_index_fast( GPtrArray* array, uint index_ );
		public extern static void g_ptr_array_remove_range( GPtrArray* array, uint index_, uint length );
		public extern static void g_ptr_array_set_size( GPtrArray* array, int length );
		public extern static GPtrArray* g_ptr_array_sized_new( uint reservedSize );
		public extern static void g_ptr_array_sort( GPtrArray* array, Functors.Func<void*, void*, int> compareFunc );
		public extern static void g_ptr_array_sort_with_data( GPtrArray* array, Functors.Func<void*, void*, void*, int> compareFunc, void* userData );

		public extern static CUtf8String g_intern_static_string( CUtf8String @string );
		public extern static CUtf8String g_intern_string( CUtf8String @string );
		public extern static uint g_quark_from_static_string( sbyte* @string );
		public extern static uint g_quark_from_string( sbyte* @string );
		[BackendHintReadNone]
		public extern static sbyte* g_quark_to_string( uint quark );
		public extern static uint g_quark_try_string( sbyte* @string );

		public extern static void g_clear_error( GError** err );
		public extern static GError* g_error_copy( GError* error );
		public extern static void g_error_free( GError* error );
		public extern static Boolean32 g_error_matches( GError* error, uint domain, int code );
		public extern static GError* g_error_new_literal( uint domain, int code, CUtf8String message );
		public extern static void g_propagate_error( GError** dest, GError* src );

		public extern static void g_atexit( Functors.Action func );
		public extern static sbyte* g_basename( CUtf8String fileName );
		[BackendHintReadNone]
		public extern static int g_bit_nth_lsf( uintptr mask, int nthBit );
		[BackendHintReadNone]
		public extern static int g_bit_nth_msf( uintptr mask, int nthBit );
		[BackendHintReadNone]
		public extern static uint g_bit_storage( uintptr number );
		public extern static sbyte* g_find_program_in_path( sbyte* program );
		public extern static sbyte* g_get_application_name();
		public extern static sbyte* g_get_current_dir();
		public extern static sbyte* g_get_home_dir();
		public extern static sbyte* g_get_host_name();
		public extern static sbyte** g_get_language_names();
		public extern static sbyte* g_get_prgname();
		public extern static sbyte* g_get_real_name();
		public extern static sbyte** g_get_system_config_dirs();
		public extern static sbyte** g_get_system_data_dirs();
		public extern static sbyte* g_get_tmp_dir();
		public extern static sbyte* g_get_user_cache_dir();
		public extern static sbyte* g_get_user_config_dir();
		public extern static sbyte* g_get_user_data_dir();
		public extern static sbyte* g_get_user_name();
		public extern static sbyte* g_get_user_special_dir( GUserDirectory directory );
		public extern static sbyte* g_getenv( sbyte* variable );
		public extern static sbyte** g_listenv();
		public extern static void g_nullify_pointer( void** nullifyLocation );
		public extern static uint g_parse_debug_string( sbyte* @string, GDebugKey* keys, uint nkeys );
		public extern static sbyte* g_path_get_basename( CUtf8String fileName );
		public extern static sbyte* g_path_get_dirname( CUtf8String fileName );
		public extern static Boolean32 g_path_is_absolute( CUtf8String fileName );
		public extern static sbyte* g_path_skip_root( CUtf8String fileName );
		public extern static void g_set_application_name( CUtf8String applicationName );
		public extern static void g_set_prgname( CUtf8String prgname );
		public extern static Boolean32 g_setenv( sbyte* variable, sbyte* value, Boolean32 overwrite );
		public extern static uint g_trash_stack_height( GTrashStack** stackP );
		public extern static void* g_trash_stack_peek( GTrashStack** stackP );
		public extern static void* g_trash_stack_pop( GTrashStack** stackP );
		public extern static void g_trash_stack_push( GTrashStack** stackP, void* dataP );
		public extern static void g_unsetenv( sbyte* variable );
		public extern static int g_vsnprintf( sbyte* @string, uintptr n, sbyte* format, sbyte* args );
		public extern static sbyte* glib_check_version( uint requiredMajor, uint requiredMinor, uint requiredMicro );

		public extern static void g_atomic_int_add( int* @atomic, int val );
		public extern static Boolean32 g_atomic_int_compare_and_exchange( int* @atomic, int oldval, int newval );
		public extern static int g_atomic_int_exchange_and_add( int* @atomic, int val );
		public extern static int g_atomic_int_get( int* @atomic );
		public extern static void g_atomic_int_set( int* @atomic, int newval );
		public extern static Boolean32 g_atomic_pointer_compare_and_exchange( void** @atomic, void* oldval, void* newval );
		public extern static void* g_atomic_pointer_get( void** @atomic );
		public extern static void g_atomic_pointer_set( void** @atomic, void* newval );

		public extern static void* g_once_impl( GOnce* once, Functors.Func<void*, void*> func, void* arg );
		public extern static Boolean32 g_once_init_enter( uint* valueLocation );
		public extern static Boolean32 g_once_init_enter_impl( uint* valueLocation );
		public extern static void g_once_init_leave( uint* valueLocation, uint initializationValue );
		public extern static void g_static_mutex_free( GStaticMutex* mutex );
		public extern static GMutex* g_static_mutex_get_mutex_impl( GMutex** mutex );
		public extern static void g_static_mutex_init( GStaticMutex* mutex );
		public extern static void g_static_private_free( GStaticPrivate* privateKey );
		public extern static void* g_static_private_get( GStaticPrivate* privateKey );
		public extern static void g_static_private_init( GStaticPrivate* privateKey );
		public extern static void g_static_private_set( GStaticPrivate* privateKey, void* data, Functors.Action<void*> notify );
		public extern static void g_static_rec_mutex_free( GStaticRecMutex* mutex );
		public extern static void g_static_rec_mutex_init( GStaticRecMutex* mutex );
		public extern static void g_static_rec_mutex_lock( GStaticRecMutex* mutex );
		public extern static void g_static_rec_mutex_lock_full( GStaticRecMutex* mutex, uint depth );
		public extern static Boolean32 g_static_rec_mutex_trylock( GStaticRecMutex* mutex );
		public extern static void g_static_rec_mutex_unlock( GStaticRecMutex* mutex );
		public extern static uint g_static_rec_mutex_unlock_full( GStaticRecMutex* mutex );
		public extern static void g_static_rw_lock_free( GStaticRWLock* lock );
		public extern static void g_static_rw_lock_init( GStaticRWLock* lock );
		public extern static void g_static_rw_lock_reader_lock( GStaticRWLock* lock );
		public extern static Boolean32 g_static_rw_lock_reader_trylock( GStaticRWLock* lock );
		public extern static void g_static_rw_lock_reader_unlock( GStaticRWLock* lock );
		public extern static void g_static_rw_lock_writer_lock( GStaticRWLock* lock );
		public extern static Boolean32 g_static_rw_lock_writer_trylock( GStaticRWLock* lock );
		public extern static void g_static_rw_lock_writer_unlock( GStaticRWLock* lock );
		public extern static GThread* g_thread_create_full( Functors.Func<void*, void*> func, void* data, uintptr stackSize, Boolean32 joinable, Boolean32 bound, GThreadPriority priority, GError** error );
		public extern static uint g_thread_error_quark();
		public extern static void g_thread_exit( void* retval );
		public extern static void g_thread_foreach( Functors.Action<void*, void*> threadFunc, void* userData );
		public extern static void* g_thread_join( GThread* thread );
		public extern static GThread* g_thread_self();
		public extern static void g_thread_set_priority( GThread* thread, GThreadPriority priority );

		public extern static int g_async_queue_length( GAsyncQueue* queue );
		public extern static int g_async_queue_length_unlocked( GAsyncQueue* queue );
		public extern static void g_async_queue_lock( GAsyncQueue* queue );
		public extern static GAsyncQueue* g_async_queue_new();
		public extern static void* g_async_queue_pop( GAsyncQueue* queue );
		public extern static void* g_async_queue_pop_unlocked( GAsyncQueue* queue );
		public extern static void g_async_queue_push( GAsyncQueue* queue, void* data );
		public extern static void g_async_queue_push_sorted( GAsyncQueue* queue, void* data, Functors.Func<void*, void*, void*, int> func, void* userData );
		public extern static void g_async_queue_push_sorted_unlocked( GAsyncQueue* queue, void* data, Functors.Func<void*, void*, void*, int> func, void* userData );
		public extern static void g_async_queue_push_unlocked( GAsyncQueue* queue, void* data );
		public extern static GAsyncQueue* g_async_queue_ref( GAsyncQueue* queue );
		public extern static void g_async_queue_ref_unlocked( GAsyncQueue* queue );
		public extern static void g_async_queue_sort( GAsyncQueue* queue, Functors.Func<void*, void*, void*, int> func, void* userData );
		public extern static void g_async_queue_sort_unlocked( GAsyncQueue* queue, Functors.Func<void*, void*, void*, int> func, void* userData );
		public extern static void* g_async_queue_timed_pop( GAsyncQueue* queue, GTimeVal* endTime );
		public extern static void* g_async_queue_timed_pop_unlocked( GAsyncQueue* queue, GTimeVal* endTime );
		public extern static void* g_async_queue_try_pop( GAsyncQueue* queue );
		public extern static void* g_async_queue_try_pop_unlocked( GAsyncQueue* queue );
		public extern static void g_async_queue_unlock( GAsyncQueue* queue );
		public extern static void g_async_queue_unref( GAsyncQueue* queue );
		public extern static void g_async_queue_unref_and_unlock( GAsyncQueue* queue );

		public extern static void g_on_error_query( CUtf8String prgName );
		public extern static void g_on_error_stack_trace( CUtf8String prgName );

		public extern static byte* g_base64_decode( CUtf8String text, uint* outLen );
		public extern static uint g_base64_decode_step( sbyte* in, uint len, byte* out, int* state, uint* save );
		public extern static sbyte* g_base64_encode( byte* data, uint len );
		public extern static uint g_base64_encode_close( Boolean32 breakLines, sbyte* out, int* state, int* save );
		public extern static uint g_base64_encode_step( byte* in, uint len, Boolean32 breakLines, sbyte* out, int* state, int* save );

		public extern static void g_bookmark_file_add_application( GBookmarkFile* bookmark, sbyte* uri, CUtf8String name, sbyte* exec );
		public extern static void g_bookmark_file_add_group( GBookmarkFile* bookmark, sbyte* uri, sbyte* group );
		public extern static uint g_bookmark_file_error_quark();
		public extern static void g_bookmark_file_free( GBookmarkFile* bookmark );
		public extern static intptr g_bookmark_file_get_added( GBookmarkFile* bookmark, sbyte* uri, GError** error );
		public extern static Boolean32 g_bookmark_file_get_app_info( GBookmarkFile* bookmark, sbyte* uri, CUtf8String name, sbyte** exec, uint* count, intptr* stamp, GError** error );
		public extern static sbyte** g_bookmark_file_get_applications( GBookmarkFile* bookmark, sbyte* uri, uint* length, GError** error );
		public extern static sbyte* g_bookmark_file_get_description( GBookmarkFile* bookmark, sbyte* uri, GError** error );
		public extern static sbyte** g_bookmark_file_get_groups( GBookmarkFile* bookmark, sbyte* uri, uint* length, GError** error );
		public extern static Boolean32 g_bookmark_file_get_icon( GBookmarkFile* bookmark, sbyte* uri, sbyte** href, sbyte** mimeType, GError** error );
		public extern static Boolean32 g_bookmark_file_get_is_private( GBookmarkFile* bookmark, sbyte* uri, GError** error );
		public extern static sbyte* g_bookmark_file_get_mime_type( GBookmarkFile* bookmark, sbyte* uri, GError** error );
		public extern static intptr g_bookmark_file_get_modified( GBookmarkFile* bookmark, sbyte* uri, GError** error );
		public extern static int g_bookmark_file_get_size( GBookmarkFile* bookmark );
		public extern static sbyte* g_bookmark_file_get_title( GBookmarkFile* bookmark, sbyte* uri, GError** error );
		public extern static sbyte** g_bookmark_file_get_uris( GBookmarkFile* bookmark, uint* length );
		public extern static intptr g_bookmark_file_get_visited( GBookmarkFile* bookmark, sbyte* uri, GError** error );
		public extern static Boolean32 g_bookmark_file_has_application( GBookmarkFile* bookmark, sbyte* uri, CUtf8String name, GError** error );
		public extern static Boolean32 g_bookmark_file_has_group( GBookmarkFile* bookmark, sbyte* uri, sbyte* group, GError** error );
		public extern static Boolean32 g_bookmark_file_has_item( GBookmarkFile* bookmark, sbyte* uri );
		public extern static Boolean32 g_bookmark_file_load_from_data( GBookmarkFile* bookmark, sbyte* data, uint length, GError** error );
		public extern static Boolean32 g_bookmark_file_load_from_data_dirs( GBookmarkFile* bookmark, sbyte* file, sbyte** fullPath, GError** error );
		public extern static Boolean32 g_bookmark_file_load_from_file( GBookmarkFile* bookmark, CUtf8String filename, GError** error );
		public extern static Boolean32 g_bookmark_file_move_item( GBookmarkFile* bookmark, sbyte* oldUri, sbyte* newUri, GError** error );
		public extern static GBookmarkFile* g_bookmark_file_new();
		public extern static Boolean32 g_bookmark_file_remove_application( GBookmarkFile* bookmark, sbyte* uri, CUtf8String name, GError** error );
		public extern static Boolean32 g_bookmark_file_remove_group( GBookmarkFile* bookmark, sbyte* uri, sbyte* group, GError** error );
		public extern static Boolean32 g_bookmark_file_remove_item( GBookmarkFile* bookmark, sbyte* uri, GError** error );
		public extern static void g_bookmark_file_set_added( GBookmarkFile* bookmark, sbyte* uri, intptr added );
		public extern static Boolean32 g_bookmark_file_set_app_info( GBookmarkFile* bookmark, sbyte* uri, CUtf8String name, sbyte* exec, int count, intptr stamp, GError** error );
		public extern static void g_bookmark_file_set_description( GBookmarkFile* bookmark, sbyte* uri, CUtf8String description );
		public extern static void g_bookmark_file_set_groups( GBookmarkFile* bookmark, sbyte* uri, sbyte** groups, uint length );
		public extern static void g_bookmark_file_set_icon( GBookmarkFile* bookmark, sbyte* uri, sbyte* href, sbyte* mimeType );
		public extern static void g_bookmark_file_set_is_private( GBookmarkFile* bookmark, sbyte* uri, Boolean32 isPrivate );
		public extern static void g_bookmark_file_set_mime_type( GBookmarkFile* bookmark, sbyte* uri, sbyte* mimeType );
		public extern static void g_bookmark_file_set_modified( GBookmarkFile* bookmark, sbyte* uri, intptr modified );
		public extern static void g_bookmark_file_set_title( GBookmarkFile* bookmark, sbyte* uri, sbyte* title );
		public extern static void g_bookmark_file_set_visited( GBookmarkFile* bookmark, sbyte* uri, intptr visited );
		public extern static sbyte* g_bookmark_file_to_data( GBookmarkFile* bookmark, uint* length, GError** error );
		public extern static Boolean32 g_bookmark_file_to_file( GBookmarkFile* bookmark, CUtf8String filename, GError** error );

		public extern static void* g_slice_alloc( uint blockSize );
		public extern static void* g_slice_alloc0( uint blockSize );
		public extern static void* g_slice_copy( uint blockSize, void* memBlock );
		public extern static void g_slice_free_chain_with_offset( uint blockSize, void* memChain, uint nextOffset );
		public extern static void g_slice_free1( uint blockSize, void* memBlock );
		public extern static long g_slice_get_config( GSliceConfig ckey );
		public extern static long* g_slice_get_config_state( GSliceConfig ckey, long address, uint* nValues );
		public extern static void g_slice_set_config( GSliceConfig ckey, long value );

		public extern static void g_allocator_free( GAllocator* allocator );
		public extern static GAllocator* g_allocator_new( CUtf8String name, uint nPreallocs );
		public extern static void g_blow_chunks();
		public extern static void g_free( void* mem );
		public extern static void* g_malloc( uintptr nBytes );
		public extern static void* g_malloc0( uintptr nBytes );
		public extern static void* g_mem_chunk_alloc( GMemChunk* memChunk );
		public extern static void* g_mem_chunk_alloc0( GMemChunk* memChunk );
		public extern static void g_mem_chunk_clean( GMemChunk* memChunk );
		public extern static void g_mem_chunk_destroy( GMemChunk* memChunk );
		public extern static void g_mem_chunk_free( GMemChunk* memChunk, void* mem );
		public extern static void g_mem_chunk_info();
		public extern static GMemChunk* g_mem_chunk_new( CUtf8String name, int atomSize, uintptr areaSize, int type );
		public extern static void g_mem_chunk_print( GMemChunk* memChunk );
		public extern static void g_mem_chunk_reset( GMemChunk* memChunk );
		public extern static Boolean32 g_mem_is_system_malloc();
		public extern static void g_mem_profile();
		public extern static void g_mem_set_vtable( GMemVTable* vtable );
		public extern static void* g_realloc( void* mem, uintptr nBytes );
		public extern static void* g_try_malloc( uintptr nBytes );
		public extern static void* g_try_malloc0( uintptr nBytes );
		public extern static void* g_try_realloc( void* mem, uintptr nBytes );

		public extern static GList* g_list_alloc();
		public extern static GList* g_list_append( GList* list, void* data );
		public extern static GList* g_list_concat( GList* list1, GList* list2 );
		public extern static GList* g_list_copy( GList* list );
		public extern static GList* g_list_delete_link( GList* list, GList* link_ );
		public extern static GList* g_list_find( GList* list, void* data );
		public extern static GList* g_list_find_custom( GList* list, void* data, Functors.Func<void*, void*, int> func );
		public extern static GList* g_list_first( GList* list );
		public extern static void g_list_foreach( GList* list, Functors.Action<void*, void*> func, void* userData );
		public extern static void g_list_free( GList* list );
		public extern static void g_list_free_1( GList* list );
		public extern static int g_list_index( GList* list, void* data );
		public extern static GList* g_list_insert( GList* list, void* data, int position );
		public extern static GList* g_list_insert_before( GList* list, GList* sibling, void* data );
		public extern static GList* g_list_insert_sorted( GList* list, void* data, Functors.Func<void*, void*, int> func );
		public extern static GList* g_list_insert_sorted_with_data( GList* list, void* data, Functors.Func<void*, void*, void*, int> func, void* userData );
		public extern static GList* g_list_last( GList* list );
		public extern static uint g_list_length( GList* list );
		public extern static GList* g_list_nth( GList* list, uint n );
		public extern static void* g_list_nth_data( GList* list, uint n );
		public extern static GList* g_list_nth_prev( GList* list, uint n );
		public extern static void g_list_pop_allocator();
		public extern static int g_list_position( GList* list, GList* llink );
		public extern static GList* g_list_prepend( GList* list, void* data );
		public extern static void g_list_push_allocator( void* allocator );
		public extern static GList* g_list_remove( GList* list, void* data );
		public extern static GList* g_list_remove_all( GList* list, void* data );
		public extern static GList* g_list_remove_link( GList* list, GList* llink );
		public extern static GList* g_list_reverse( GList* list );
		public extern static GList* g_list_sort( GList* list, Functors.Func<void*, void*, int> compareFunc );
		public extern static GList* g_list_sort_with_data( GList* list, Functors.Func<void*, void*, void*, int> compareFunc, void* userData );

		public extern static void g_cache_destroy( GCache* cache );
		public extern static void* g_cache_insert( GCache* cache, void* key );
		public extern static void g_cache_key_foreach( GCache* cache, Functors.Action<void*, void*, void*> func, void* userData );
		public extern static GCache* g_cache_new( Functors.Func<void*, void*> valueNewFunc, Functors.Action<void*> valueDestroyFunc, Functors.Func<void*, void*> keyDupFunc, Functors.Action<void*> keyDestroyFunc, Functors.Func<void*, uint> hashKeyFunc, Functors.Func<void*, uint> hashValueFunc, Functors.Func<void*, void*, Boolean32> keyEqualFunc );
		public extern static void g_cache_remove( GCache* cache, void* value );
		public extern static void g_cache_value_foreach( GCache* cache, Functors.Action<void*, void*, void*> func, void* userData );

		public extern static void g_completion_add_items( GCompletion* cmp, GList* items );
		public extern static void g_completion_clear_items( GCompletion* cmp );
		public extern static GList* g_completion_complete( GCompletion* cmp, sbyte* prefix, sbyte** newPrefix );
		public extern static GList* g_completion_complete_utf8( GCompletion* cmp, sbyte* prefix, sbyte** newPrefix );
		public extern static void g_completion_free( GCompletion* cmp );
		public extern static GCompletion* g_completion_new( Functors.Func<void*, sbyte*> func );
		public extern static void g_completion_remove_items( GCompletion* cmp, GList* items );
		public extern static void g_completion_set_compare( GCompletion* cmp, Functors.Func<sbyte*, sbyte*, uint, int> strncmpFunc );

		public extern static sbyte* g_convert( sbyte* str, int len, sbyte* toCodeset, sbyte* fromCodeset, uint* bytesRead, uint* bytesWritten, GError** error );
		public extern static uint g_convert_error_quark();
		public extern static sbyte* g_convert_with_fallback( sbyte* str, int len, sbyte* toCodeset, sbyte* fromCodeset, sbyte* fallback, uint* bytesRead, uint* bytesWritten, GError** error );
		public extern static sbyte* g_convert_with_iconv( sbyte* str, int len, GIConv* converter, uint* bytesRead, uint* bytesWritten, GError** error );
		public extern static sbyte* g_filename_display_basename( CUtf8String filename );
		public extern static sbyte* g_filename_display_name( CUtf8String filename );
		public extern static sbyte* g_filename_from_uri( sbyte* uri, sbyte** hostname, GError** error );
		public extern static sbyte* g_filename_from_utf8( sbyte* utf8string, int len, uint* bytesRead, uint* bytesWritten, GError** error );
		public extern static sbyte* g_filename_to_uri( CUtf8String filename, CUtf8String hostname, GError** error );
		public extern static sbyte* g_filename_to_utf8( sbyte* opsysstring, int len, uint* bytesRead, uint* bytesWritten, GError** error );
		public extern static Boolean32 g_get_filename_charsets( sbyte*** charsets );
		public extern static uint g_iconv( GIConv* converter, sbyte** inbuf, uint* inbytesLeft, sbyte** outbuf, uint* outbytesLeft );
		public extern static int g_iconv_close( GIConv* converter );
		public extern static GIConv* g_iconv_open( sbyte* toCodeset, sbyte* fromCodeset );
		public extern static sbyte* g_locale_from_utf8( sbyte* utf8string, int len, uint* bytesRead, uint* bytesWritten, GError** error );
		public extern static sbyte* g_locale_to_utf8( sbyte* opsysstring, int len, uint* bytesRead, uint* bytesWritten, GError** error );
		public extern static sbyte** g_uri_list_extract_uris( sbyte* uriList );

		public extern static void g_datalist_clear( GData** datalist );
		public extern static void g_datalist_foreach( GData** datalist, Functors.Action<uint, void*, void*> func, void* userData );
		public extern static uint g_datalist_get_flags( GData** datalist );
		public extern static void* g_datalist_id_get_data( GData** datalist, uint keyId );
		public extern static void* g_datalist_id_remove_no_notify( GData** datalist, uint keyId );
		public extern static void g_datalist_id_set_data_full( GData** datalist, uint keyId, void* data, Functors.Action<void*> destroyFunc );
		public extern static void g_datalist_init( GData** datalist );
		public extern static void g_datalist_set_flags( GData** datalist, uint flags );
		public extern static void g_datalist_unset_flags( GData** datalist, uint flags );
		public extern static void g_dataset_destroy( void* datasetLocation );
		public extern static void g_dataset_foreach( void* datasetLocation, Functors.Action<uint, void*, void*> func, void* userData );
		public extern static void* g_dataset_id_get_data( void* datasetLocation, uint keyId );
		public extern static void* g_dataset_id_remove_no_notify( void* datasetLocation, uint keyId );
		public extern static void g_dataset_id_set_data_full( void* datasetLocation, uint keyId, void* data, Functors.Action<void*> destroyFunc );

		public extern static void g_date_add_days( GDate* date, uint nDays );
		public extern static void g_date_add_months( GDate* date, uint nMonths );
		public extern static void g_date_add_years( GDate* date, uint nYears );
		public extern static void g_date_clamp( GDate* date, GDate* minDate, GDate* maxDate );
		public extern static void g_date_clear( GDate* date, uint nDates );
		public extern static int g_date_compare( GDate* lhs, GDate* rhs );
		public extern static int g_date_days_between( GDate* date1, GDate* date2 );
		public extern static void g_date_free( GDate* date );
		public extern static byte g_date_get_day( GDate* date );
		public extern static uint g_date_get_day_of_year( GDate* date );
		[BackendHintReadNone]
		public extern static byte g_date_get_days_in_month( GDateMonth month, ushort year );
		public extern static uint g_date_get_iso8601_week_of_year( GDate* date );
		public extern static uint g_date_get_julian( GDate* date );
		public extern static uint g_date_get_monday_week_of_year( GDate* date );
		[BackendHintReadNone]
		public extern static byte g_date_get_monday_weeks_in_year( ushort year );
		public extern static GDateMonth g_date_get_month( GDate* date );
		public extern static uint g_date_get_sunday_week_of_year( GDate* date );
		[BackendHintReadNone]
		public extern static byte g_date_get_sunday_weeks_in_year( ushort year );
		public extern static GDateWeekday g_date_get_weekday( GDate* date );
		public extern static ushort g_date_get_year( GDate* date );
		public extern static Boolean32 g_date_is_first_of_month( GDate* date );
		public extern static Boolean32 g_date_is_last_of_month( GDate* date );
		[BackendHintReadNone]
		public extern static Boolean32 g_date_is_leap_year( ushort year );
		public extern static GDate* g_date_new();
		public extern static GDate* g_date_new_dmy( byte day, GDateMonth month, ushort year );
		public extern static GDate* g_date_new_julian( uint julianDay );
		public extern static void g_date_order( GDate* date1, GDate* date2 );
		public extern static void g_date_set_day( GDate* date, byte day );
		public extern static void g_date_set_dmy( GDate* date, byte day, GDateMonth month, ushort y );
		public extern static void g_date_set_julian( GDate* date, uint julianDate );
		public extern static void g_date_set_month( GDate* date, GDateMonth month );
		public extern static void g_date_set_parse( GDate* date, sbyte* str );
		public extern static void g_date_set_time( GDate* date, int time_ );
		public extern static void g_date_set_time_t( GDate* date, intptr timet );
		public extern static void g_date_set_time_val( GDate* date, GTimeVal* timeval );
		public extern static void g_date_set_year( GDate* date, ushort year );
		public extern static uint g_date_strftime( sbyte* s, uint slen, sbyte* format, GDate* date );
		public extern static void g_date_subtract_days( GDate* date, uint nDays );
		public extern static void g_date_subtract_months( GDate* date, uint nMonths );
		public extern static void g_date_subtract_years( GDate* date, uint nYears );
		public extern static void g_date_to_struct_tm( GDate* date, tm* tm );
		public extern static Boolean32 g_date_valid( GDate* date );
		[BackendHintReadNone]
		public extern static Boolean32 g_date_valid_day( byte day );
		[BackendHintReadNone]
		public extern static Boolean32 g_date_valid_dmy( byte day, GDateMonth month, ushort year );
		[BackendHintReadNone]
		public extern static Boolean32 g_date_valid_julian( uint julianDate );
		[BackendHintReadNone]
		public extern static Boolean32 g_date_valid_month( GDateMonth month );
		[BackendHintReadNone]
		public extern static Boolean32 g_date_valid_weekday( GDateWeekday weekday );
		[BackendHintReadNone]
		public extern static Boolean32 g_date_valid_year( ushort year );

		public extern static void g_dir_close( GDir* dir );
		public extern static GDir* g_dir_open( sbyte* path, uint flags, GError** error );
		public extern static sbyte* g_dir_read_name( GDir* dir );
		public extern static void g_dir_rewind( GDir* dir );

		public extern static sbyte* g_build_filenamev( sbyte** args );
		public extern static sbyte* g_build_pathv( sbyte* separator, sbyte** args );
		public extern static GFileError g_file_error_from_errno( int errNo );
		public extern static uint g_file_error_quark();
		public extern static Boolean32 g_file_get_contents( CUtf8String filename, sbyte** contents, uint* length, GError** error );
		public extern static int g_file_open_tmp( sbyte* tmpl, sbyte** nameUsed, GError** error );
		public extern static sbyte* g_file_read_link( CUtf8String filename, GError** error );
		public extern static Boolean32 g_file_set_contents( CUtf8String filename, sbyte* contents, int length, GError** error );
		public extern static Boolean32 g_file_test( CUtf8String filename, GFileTest test );
		public extern static int g_mkdir_with_parents( CUtf8String pathname, int mode );
		public extern static int g_mkstemp( sbyte* tmpl );

		[BackendHintReadNone]
		public extern static Boolean32 g_direct_equal( void* v1, void* v2 );
		[BackendHintReadNone]
		public extern static uint g_direct_hash( void* v );
		public extern static void g_hash_table_destroy( GHashTable* hashTable );
		public extern static void* g_hash_table_find( GHashTable* hashTable, Functors.Func<void*, void*, void*, Boolean32> predicate, void* userData );
		public extern static void g_hash_table_foreach( GHashTable* hashTable, Functors.Action<void*, void*, void*> func, void* userData );
		public extern static uint g_hash_table_foreach_remove( GHashTable* hashTable, Functors.Func<void*, void*, void*, Boolean32> func, void* userData );
		public extern static uint g_hash_table_foreach_steal( GHashTable* hashTable, Functors.Func<void*, void*, void*, Boolean32> func, void* userData );
		public extern static GList* g_hash_table_get_keys( GHashTable* hashTable );
		public extern static GList* g_hash_table_get_values( GHashTable* hashTable );
		public extern static void g_hash_table_insert( GHashTable* hashTable, void* key, void* value );
		public extern static void* g_hash_table_lookup( GHashTable* hashTable, void* key );
		public extern static Boolean32 g_hash_table_lookup_extended( GHashTable* hashTable, void* lookupKey, void** origKey, void** value );
		public extern static GHashTable* g_hash_table_new( Functors.Func<void*, uint> hashFunc, Functors.Func<void*, void*, Boolean32> keyEqualFunc );
		public extern static GHashTable* g_hash_table_new_full( Functors.Func<void*, uint> hashFunc, Functors.Func<void*, void*, Boolean32> keyEqualFunc, Functors.Action<void*> keyDestroyFunc, Functors.Action<void*> valueDestroyFunc );
		public extern static GHashTable* g_hash_table_ref( GHashTable* hashTable );
		public extern static Boolean32 g_hash_table_remove( GHashTable* hashTable, void* key );
		public extern static void g_hash_table_remove_all( GHashTable* hashTable );
		public extern static void g_hash_table_replace( GHashTable* hashTable, void* key, void* value );
		public extern static uint g_hash_table_size( GHashTable* hashTable );
		public extern static Boolean32 g_hash_table_steal( GHashTable* hashTable, void* key );
		public extern static void g_hash_table_steal_all( GHashTable* hashTable );
		public extern static void g_hash_table_unref( GHashTable* hashTable );
		public extern static Boolean32 g_int_equal( void* v1, void* v2 );
		public extern static uint g_int_hash( void* v );
		public extern static Boolean32 g_str_equal( void* v1, void* v2 );
		public extern static uint g_str_hash( void* v );

		public extern static GHook* g_hook_alloc( GHookList* hookList );
		public extern static int g_hook_compare_ids( GHook* newHook, GHook* sibling );
		public extern static Boolean32 g_hook_destroy( GHookList* hookList, uintptr hookId );
		public extern static void g_hook_destroy_link( GHookList* hookList, GHook* hook );
		public extern static GHook* g_hook_find( GHookList* hookList, Boolean32 needValids, Functors.Func<GHook*, void*, Boolean32> func, void* data );
		public extern static GHook* g_hook_find_data( GHookList* hookList, Boolean32 needValids, void* data );
		public extern static GHook* g_hook_find_func( GHookList* hookList, Boolean32 needValids, void* func );
		public extern static GHook* g_hook_find_func_data( GHookList* hookList, Boolean32 needValids, void* func, void* data );
		public extern static GHook* g_hook_first_valid( GHookList* hookList, Boolean32 mayBeInCall );
		public extern static void g_hook_free( GHookList* hookList, GHook* hook );
		public extern static GHook* g_hook_get( GHookList* hookList, uintptr hookId );
		public extern static void g_hook_insert_before( GHookList* hookList, GHook* sibling, GHook* hook );
		public extern static void g_hook_insert_sorted( GHookList* hookList, GHook* hook, Functors.Func<GHook*, GHook*, int> func );
		public extern static void g_hook_list_clear( GHookList* hookList );
		public extern static void g_hook_list_init( GHookList* hookList, uint hookSize );
		public extern static void g_hook_list_invoke( GHookList* hookList, Boolean32 mayRecurse );
		public extern static void g_hook_list_invoke_check( GHookList* hookList, Boolean32 mayRecurse );
		public extern static void g_hook_list_marshal( GHookList* hookList, Boolean32 mayRecurse, Functors.Action<GHook*, void*> marshaller, void* marshalData );
		public extern static void g_hook_list_marshal_check( GHookList* hookList, Boolean32 mayRecurse, Functors.Func<GHook*, void*, Boolean32> marshaller, void* marshalData );
		public extern static GHook* g_hook_next_valid( GHookList* hookList, GHook* hook, Boolean32 mayBeInCall );
		public extern static void g_hook_prepend( GHookList* hookList, GHook* hook );
		public extern static GHook* g_hook_ref( GHookList* hookList, GHook* hook );
		public extern static void g_hook_unref( GHookList* hookList, GHook* hook );

		public extern static GSList* g_slist_alloc();
		public extern static GSList* g_slist_append( GSList* list, void* data );
		public extern static GSList* g_slist_concat( GSList* list1, GSList* list2 );
		public extern static GSList* g_slist_copy( GSList* list );
		public extern static GSList* g_slist_delete_link( GSList* list, GSList* link_ );
		public extern static GSList* g_slist_find( GSList* list, void* data );
		public extern static GSList* g_slist_find_custom( GSList* list, void* data, Functors.Func<void*, void*, int> func );
		public extern static void g_slist_foreach( GSList* list, Functors.Action<void*, void*> func, void* userData );
		public extern static void g_slist_free( GSList* list );
		public extern static void g_slist_free_1( GSList* list );
		public extern static int g_slist_index( GSList* list, void* data );
		public extern static GSList* g_slist_insert( GSList* list, void* data, int position );
		public extern static GSList* g_slist_insert_before( GSList* slist, GSList* sibling, void* data );
		public extern static GSList* g_slist_insert_sorted( GSList* list, void* data, Functors.Func<void*, void*, int> func );
		public extern static GSList* g_slist_insert_sorted_with_data( GSList* list, void* data, Functors.Func<void*, void*, void*, int> func, void* userData );
		public extern static GSList* g_slist_last( GSList* list );
		public extern static uint g_slist_length( GSList* list );
		public extern static GSList* g_slist_nth( GSList* list, uint n );
		public extern static void* g_slist_nth_data( GSList* list, uint n );
		public extern static void g_slist_pop_allocator();
		public extern static int g_slist_position( GSList* list, GSList* llink );
		public extern static GSList* g_slist_prepend( GSList* list, void* data );
		public extern static void g_slist_push_allocator( void* dummy );
		public extern static GSList* g_slist_remove( GSList* list, void* data );
		public extern static GSList* g_slist_remove_all( GSList* list, void* data );
		public extern static GSList* g_slist_remove_link( GSList* list, GSList* link_ );
		public extern static GSList* g_slist_reverse( GSList* list );
		public extern static GSList* g_slist_sort( GSList* list, Functors.Func<void*, void*, int> compareFunc );
		public extern static GSList* g_slist_sort_with_data( GSList* list, Functors.Func<void*, void*, void*, int> compareFunc, void* userData );

		public extern static uint g_child_watch_add( int pid, Functors.Action<int, int, void*> function, void* data );
		public extern static uint g_child_watch_add_full( GlibTaskPriority priority, int pid, Functors.Action<int, int, void*> function, void* data, Functors.Action<void*> notify );
		public extern static GSource* g_child_watch_source_new( int pid );
		public extern static void g_get_current_time( GTimeVal* result );
		public extern static uint g_idle_add( Functors.Func<void*, Boolean32> function, void* data );
		public extern static uint g_idle_add_full( GlibTaskPriority priority, Functors.Func<void*, Boolean32> function, void* data, Functors.Action<void*> notify );
		public extern static Boolean32 g_idle_remove_by_data( void* data );
		public extern static GSource* g_idle_source_new();
		public extern static Boolean32 g_main_context_acquire( GMainContext* context );
		public extern static void g_main_context_add_poll( GMainContext* context, GPollFD* fd, int priority );
		public extern static int g_main_context_check( GMainContext* context, int maxPriority, GPollFD* fds, int nFds );
		public extern static GMainContext* g_main_context_default();
		public extern static void g_main_context_dispatch( GMainContext* context );
		public extern static GSource* g_main_context_find_source_by_funcs_user_data( GMainContext* context, GSourceFuncs* funcs, void* userData );
		public extern static GSource* g_main_context_find_source_by_id( GMainContext* context, uint sourceId );
		public extern static GSource* g_main_context_find_source_by_user_data( GMainContext* context, void* userData );
		public extern static Functors.Func<GPollFD*, uint, int, int> g_main_context_get_poll_func( GMainContext* context );
		public extern static Boolean32 g_main_context_is_owner( GMainContext* context );
		public extern static Boolean32 g_main_context_iteration( GMainContext* context, Boolean32 mayBlock );
		public extern static GMainContext* g_main_context_new();
		public extern static Boolean32 g_main_context_pending( GMainContext* context );
		public extern static Boolean32 g_main_context_prepare( GMainContext* context, int* priority );
		public extern static int g_main_context_query( GMainContext* context, int maxPriority, int* timeout_, GPollFD* fds, int nFds );
		public extern static GMainContext* g_main_context_ref( GMainContext* context );
		public extern static void g_main_context_release( GMainContext* context );
		public extern static void g_main_context_remove_poll( GMainContext* context, GPollFD* fd );
		public extern static void g_main_context_set_poll_func( GMainContext* context, Functors.Func<GPollFD*, uint, int, int> func );
		public extern static void g_main_context_unref( GMainContext* context );
		public extern static Boolean32 g_main_context_wait( GMainContext* context, GCond* cond, GMutex* mutex );
		public extern static void g_main_context_wakeup( GMainContext* context );
		public extern static GSource* g_main_current_source();
		public extern static int g_main_depth();
		public extern static GMainContext* g_main_loop_get_context( GMainLoop* loop );
		public extern static Boolean32 g_main_loop_is_running( GMainLoop* loop );
		public extern static GMainLoop* g_main_loop_new( GMainContext* context, Boolean32 isRunning );
		public extern static void g_main_loop_quit( GMainLoop* loop );
		public extern static GMainLoop* g_main_loop_ref( GMainLoop* loop );
		public extern static void g_main_loop_run( GMainLoop* loop );
		public extern static void g_main_loop_unref( GMainLoop* loop );
		public extern static void g_source_add_poll( GSource* source, GPollFD* fd );
		public extern static uint g_source_attach( GSource* source, GMainContext* context );
		public extern static void g_source_destroy( GSource* source );
		public extern static Boolean32 g_source_get_can_recurse( GSource* source );
		public extern static GMainContext* g_source_get_context( GSource* source );
		public extern static void g_source_get_current_time( GSource* source, GTimeVal* timeval );
		public extern static uint g_source_get_id( GSource* source );
		public extern static int g_source_get_priority( GSource* source );
		public extern static Boolean32 g_source_is_destroyed( GSource* source );
		public extern static GSource* g_source_new( GSourceFuncs* sourceFuncs, uint structSize );
		public extern static GSource* g_source_ref( GSource* source );
		public extern static Boolean32 g_source_remove( uint tag );
		public extern static Boolean32 g_source_remove_by_funcs_user_data( GSourceFuncs* funcs, void* userData );
		public extern static Boolean32 g_source_remove_by_user_data( void* userData );
		public extern static void g_source_remove_poll( GSource* source, GPollFD* fd );
		public extern static void g_source_set_callback( GSource* source, Functors.Func<void*, Boolean32> func, void* data, Functors.Action<void*> notify );
		public extern static void g_source_set_callback_indirect( GSource* source, void* callbackData, GSourceCallbackFuncs* callbackFuncs );
		public extern static void g_source_set_can_recurse( GSource* source, Boolean32 canRecurse );
		public extern static void g_source_set_funcs( GSource* source, GSourceFuncs* funcs );
		public extern static void g_source_set_priority( GSource* source, int priority );
		public extern static void g_source_unref( GSource* source );
		public extern static uint g_timeout_add( uint interval, Functors.Func<void*, Boolean32> function, void* data );
		public extern static uint g_timeout_add_full( GlibTaskPriority priority, uint interval, Functors.Func<void*, Boolean32> function, void* data, Functors.Action<void*> notify );
		public extern static uint g_timeout_add_seconds( uint interval, Functors.Func<void*, Boolean32> function, void* data );
		public extern static uint g_timeout_add_seconds_full( GlibTaskPriority priority, uint interval, Functors.Func<void*, Boolean32> function, void* data, Functors.Action<void*> notify );
		public extern static GSource* g_timeout_source_new( uint interval );
		public extern static GSource* g_timeout_source_new_seconds( uint interval );

		public extern static Boolean32 g_get_charset( sbyte** charset );
		public extern static ushort* g_ucs4_to_utf16( uint* str, intptr len, intptr* itemsRead, intptr* itemsWritten, GError** error );
		public extern static sbyte* g_ucs4_to_utf8( uint* str, intptr len, intptr* itemsRead, intptr* itemsWritten, GError** error );
		[BackendHintReadNone]
		public extern static GUnicodeBreakType g_unichar_break_type( uint c );
		[BackendHintReadNone]
		public extern static int g_unichar_combining_class( uint uc );
		[BackendHintReadNone]
		public extern static int g_unichar_digit_value( uint c );
		public extern static Boolean32 g_unichar_get_mirror_char( uint ch, uint* mirroredCh );
		[BackendHintReadNone]
		public extern static GUnicodeScript g_unichar_get_script( uint ch );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_isalnum( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_isalpha( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_iscntrl( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_isdefined( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_isdigit( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_isgraph( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_islower( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_ismark( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_isprint( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_ispunct( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_isspace( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_istitle( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_isupper( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_iswide( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_iswide_cjk( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_isxdigit( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_iszerowidth( uint c );
		public extern static int g_unichar_to_utf8( uint c, sbyte* outbuf );
		[BackendHintReadNone]
		public extern static uint g_unichar_tolower( uint c );
		[BackendHintReadNone]
		public extern static uint g_unichar_totitle( uint c );
		[BackendHintReadNone]
		public extern static uint g_unichar_toupper( uint c );
		[BackendHintReadNone]
		public extern static GUnicodeType g_unichar_type( uint c );
		[BackendHintReadNone]
		public extern static Boolean32 g_unichar_validate( uint ch );
		[BackendHintReadNone]
		public extern static int g_unichar_xdigit_value( uint c );
		public extern static uint* g_unicode_canonical_decomposition( uint ch, uint* resultLen );
		public extern static void g_unicode_canonical_ordering( uint* @string, uint len );
		public extern static uint* g_utf16_to_ucs4( ushort* str, intptr len, intptr* itemsRead, intptr* itemsWritten, GError** error );
		public extern static sbyte* g_utf16_to_utf8( ushort* str, intptr len, intptr* itemsRead, intptr* itemsWritten, GError** error );
		public extern static sbyte* g_utf8_casefold( sbyte* str, int len );
		[BackendHintReadOnly]
		public extern static int g_utf8_collate( sbyte* str1, sbyte* str2 );
		public extern static sbyte* g_utf8_collate_key( sbyte* str, int len );
		public extern static sbyte* g_utf8_collate_key_for_filename( sbyte* str, int len );
		[BackendHintReadOnly]
		public extern static sbyte* g_utf8_find_next_char( sbyte* p, sbyte* end );
		[BackendHintReadOnly]
		public extern static sbyte* g_utf8_find_prev_char( sbyte* str, sbyte* p );
		[BackendHintReadOnly]
		public extern static uint g_utf8_get_char( sbyte* p );
		[BackendHintReadOnly]
		public extern static uint g_utf8_get_char_validated( sbyte* p, int maxLen );
		public extern static sbyte* g_utf8_normalize( sbyte* str, int len, GNormalizeMode mode );
		[BackendHintReadOnly]
		public extern static sbyte* g_utf8_offset_to_pointer( sbyte* str, intptr offset );
		[BackendHintReadOnly]
		public extern static intptr g_utf8_pointer_to_offset( sbyte* str, sbyte* pos );
		[BackendHintReadOnly]
		public extern static sbyte* g_utf8_prev_char( sbyte* p );
		public extern static sbyte* g_utf8_strchr( sbyte* p, int len, uint c );
		public extern static sbyte* g_utf8_strdown( sbyte* str, int len );
		[BackendHintReadOnly]
		public extern static intptr g_utf8_strlen( sbyte* p, int max );
		public extern static sbyte* g_utf8_strncpy( sbyte* dest, sbyte* src, uint n );
		public extern static sbyte* g_utf8_strrchr( sbyte* p, int len, uint c );
		public extern static sbyte* g_utf8_strreverse( sbyte* str, int len );
		public extern static sbyte* g_utf8_strup( sbyte* str, int len );
		public extern static uint* g_utf8_to_ucs4( sbyte* str, intptr len, intptr* itemsRead, intptr* itemsWritten, GError** error );
		public extern static uint* g_utf8_to_ucs4_fast( sbyte* str, intptr len, intptr* itemsWritten );
		public extern static ushort* g_utf8_to_utf16( sbyte* str, intptr len, intptr* itemsRead, intptr* itemsWritten, GError** error );
		public extern static Boolean32 g_utf8_validate( sbyte* str, int maxLen, sbyte** end );

		public extern static GString* g_string_append( GString* @string, sbyte* val );
		public extern static GString* g_string_append_c( GString* @string, sbyte c );
		public extern static GString* g_string_append_len( GString* @string, sbyte* val, int len );
		public extern static GString* g_string_append_unichar( GString* @string, uint wc );
		public extern static void g_string_append_vprintf( GString* @string, sbyte* format, sbyte* args );
		public extern static GString* g_string_ascii_down( GString* @string );
		public extern static GString* g_string_ascii_up( GString* @string );
		public extern static GString* g_string_assign( GString* @string, sbyte* rval );
		public extern static void g_string_chunk_clear( GStringChunk* chunk );
		public extern static void g_string_chunk_free( GStringChunk* chunk );
		public extern static sbyte* g_string_chunk_insert( GStringChunk* chunk, sbyte* @string );
		public extern static sbyte* g_string_chunk_insert_const( GStringChunk* chunk, sbyte* @string );
		public extern static sbyte* g_string_chunk_insert_len( GStringChunk* chunk, sbyte* @string, int len );
		public extern static GStringChunk* g_string_chunk_new( uint size );
		public extern static GString* g_string_down( GString* @string );
		public extern static Boolean32 g_string_equal( GString* v, GString* v2 );
		public extern static GString* g_string_erase( GString* @string, int pos, int len );
		public extern static sbyte* g_string_free( GString* @string, Boolean32 freeSegment );
		public extern static uint g_string_hash( GString* str );
		public extern static GString* g_string_insert( GString* @string, int pos, sbyte* val );
		public extern static GString* g_string_insert_c( GString* @string, int pos, sbyte c );
		public extern static GString* g_string_insert_len( GString* @string, int pos, sbyte* val, int len );
		public extern static GString* g_string_insert_unichar( GString* @string, int pos, uint wc );
		public extern static GString* g_string_new( sbyte* init );
		public extern static GString* g_string_new_len( sbyte* init, int len );
		public extern static GString* g_string_overwrite( GString* @string, uint pos, sbyte* val );
		public extern static GString* g_string_overwrite_len( GString* @string, uint pos, sbyte* val, int len );
		public extern static GString* g_string_prepend( GString* @string, sbyte* val );
		public extern static GString* g_string_prepend_c( GString* @string, sbyte c );
		public extern static GString* g_string_prepend_len( GString* @string, sbyte* val, int len );
		public extern static GString* g_string_prepend_unichar( GString* @string, uint wc );
		public extern static GString* g_string_set_size( GString* @string, uint len );
		public extern static GString* g_string_sized_new( uint dflSize );
		public extern static GString* g_string_truncate( GString* @string, uint len );
		public extern static GString* g_string_up( GString* @string );
		public extern static void g_string_vprintf( GString* @string, sbyte* format, sbyte* args );

		public extern static uint g_io_add_watch( GIOChannel* channel, GIOCondition condition, Functors.Func<GIOChannel*, GIOCondition, void*, Boolean32> func, void* userData );
		public extern static uint g_io_add_watch_full( GIOChannel* channel, int priority, GIOCondition condition, Functors.Func<GIOChannel*, GIOCondition, void*, Boolean32> func, void* userData, Functors.Action<void*> notify );
		public extern static void g_io_channel_close( GIOChannel* channel );
		public extern static GIOChannelError g_io_channel_error_from_errno( int en );
		public extern static uint g_io_channel_error_quark();
		public extern static GIOStatus g_io_channel_flush( GIOChannel* channel, GError** error );
		public extern static GIOCondition g_io_channel_get_buffer_condition( GIOChannel* channel );
		public extern static uint g_io_channel_get_buffer_size( GIOChannel* channel );
		public extern static Boolean32 g_io_channel_get_buffered( GIOChannel* channel );
		public extern static Boolean32 g_io_channel_get_close_on_unref( GIOChannel* channel );
		public extern static sbyte* g_io_channel_get_encoding( GIOChannel* channel );
		public extern static GIOFlags g_io_channel_get_flags( GIOChannel* channel );
		public extern static sbyte* g_io_channel_get_line_term( GIOChannel* channel, int* length );
		public extern static void g_io_channel_init( GIOChannel* channel );
		public extern static GIOChannel* g_io_channel_new_file( CUtf8String filename, sbyte* mode, GError** error );
		public extern static GIOError g_io_channel_read( GIOChannel* channel, sbyte* buf, uint count, uint* bytesRead );
		public extern static GIOStatus g_io_channel_read_chars( GIOChannel* channel, sbyte* buf, uint count, uint* bytesRead, GError** error );
		public extern static GIOStatus g_io_channel_read_line( GIOChannel* channel, sbyte** strReturn, uint* length, uint* terminatorPos, GError** error );
		public extern static GIOStatus g_io_channel_read_line_string( GIOChannel* channel, GString* buffer, uint* terminatorPos, GError** error );
		public extern static GIOStatus g_io_channel_read_to_end( GIOChannel* channel, sbyte** strReturn, uint* length, GError** error );
		public extern static GIOStatus g_io_channel_read_unichar( GIOChannel* channel, uint* thechar, GError** error );
		public extern static GIOChannel* g_io_channel_ref( GIOChannel* channel );
		public extern static GIOError g_io_channel_seek( GIOChannel* channel, long offset, GSeekType type );
		public extern static GIOStatus g_io_channel_seek_position( GIOChannel* channel, long offset, GSeekType type, GError** error );
		public extern static void g_io_channel_set_buffer_size( GIOChannel* channel, uint size );
		public extern static void g_io_channel_set_buffered( GIOChannel* channel, Boolean32 buffered );
		public extern static void g_io_channel_set_close_on_unref( GIOChannel* channel, Boolean32 doClose );
		public extern static GIOStatus g_io_channel_set_encoding( GIOChannel* channel, sbyte* encoding, GError** error );
		public extern static GIOStatus g_io_channel_set_flags( GIOChannel* channel, GIOFlags flags, GError** error );
		public extern static void g_io_channel_set_line_term( GIOChannel* channel, sbyte* lineTerm, int length );
		public extern static GIOStatus g_io_channel_shutdown( GIOChannel* channel, Boolean32 flush, GError** err );
		public extern static int g_io_channel_unix_get_fd( GIOChannel* channel );
		public extern static GIOChannel* g_io_channel_unix_new( int fd );
		public extern static void g_io_channel_unref( GIOChannel* channel );
		public extern static GIOError g_io_channel_write( GIOChannel* channel, sbyte* buf, uint count, uint* bytesWritten );
		public extern static GIOStatus g_io_channel_write_chars( GIOChannel* channel, sbyte* buf, int count, uint* bytesWritten, GError** error );
		public extern static GIOStatus g_io_channel_write_unichar( GIOChannel* channel, uint thechar, GError** error );
		public extern static GSource* g_io_create_watch( GIOChannel* channel, GIOCondition condition );

		public extern static uint g_key_file_error_quark();
		public extern static void g_key_file_free( GKeyFile* keyFile );
		public extern static Boolean32 g_key_file_get_boolean( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, GError** error );
		public extern static int* g_key_file_get_boolean_list( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, uint* length, GError** error );
		public extern static sbyte* g_key_file_get_comment( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, GError** error );
		public extern static double g_key_file_get_double( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, GError** error );
		public extern static double* g_key_file_get_double_list( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, uint* length, GError** error );
		public extern static sbyte** g_key_file_get_groups( GKeyFile* keyFile, uint* length );
		public extern static int g_key_file_get_integer( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, GError** error );
		public extern static int* g_key_file_get_integer_list( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, uint* length, GError** error );
		public extern static sbyte** g_key_file_get_keys( GKeyFile* keyFile, CUtf8String groupName, uint* length, GError** error );
		public extern static sbyte* g_key_file_get_locale_string( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, sbyte* locale, GError** error );
		public extern static sbyte** g_key_file_get_locale_string_list( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, sbyte* locale, uint* length, GError** error );
		public extern static sbyte* g_key_file_get_start_group( GKeyFile* keyFile );
		public extern static sbyte* g_key_file_get_string( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, GError** error );
		public extern static sbyte** g_key_file_get_string_list( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, uint* length, GError** error );
		public extern static sbyte* g_key_file_get_value( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, GError** error );
		public extern static Boolean32 g_key_file_has_group( GKeyFile* keyFile, CUtf8String groupName );
		public extern static Boolean32 g_key_file_has_key( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, GError** error );
		public extern static Boolean32 g_key_file_load_from_data( GKeyFile* keyFile, sbyte* data, uint length, GKeyFileFlags flags, GError** error );
		public extern static Boolean32 g_key_file_load_from_data_dirs( GKeyFile* keyFile, sbyte* file, sbyte** fullPath, GKeyFileFlags flags, GError** error );
		public extern static Boolean32 g_key_file_load_from_dirs( GKeyFile* keyFile, sbyte* file, sbyte** searchDirs, sbyte** fullPath, GKeyFileFlags flags, GError** error );
		public extern static Boolean32 g_key_file_load_from_file( GKeyFile* keyFile, sbyte* file, GKeyFileFlags flags, GError** error );
		public extern static GKeyFile* g_key_file_new();
		public extern static void g_key_file_remove_comment( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, GError** error );
		public extern static void g_key_file_remove_group( GKeyFile* keyFile, CUtf8String groupName, GError** error );
		public extern static void g_key_file_remove_key( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, GError** error );
		public extern static void g_key_file_set_boolean( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, Boolean32 value );
		public extern static void g_key_file_set_boolean_list( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, int* list, uint length );
		public extern static void g_key_file_set_comment( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, sbyte* comment, GError** error );
		public extern static void g_key_file_set_double( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, double value );
		public extern static void g_key_file_set_double_list( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, double* list, uint length );
		public extern static void g_key_file_set_integer( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, int value );
		public extern static void g_key_file_set_integer_list( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, int* list, uint length );
		public extern static void g_key_file_set_list_separator( GKeyFile* keyFile, sbyte separator );
		public extern static void g_key_file_set_locale_string( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, sbyte* locale, sbyte* @string );
		public extern static void g_key_file_set_locale_string_list( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, sbyte* locale, sbyte** list, uint length );
		public extern static void g_key_file_set_string( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, sbyte* @string );
		public extern static void g_key_file_set_string_list( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, sbyte** list, uint length );
		public extern static void g_key_file_set_value( GKeyFile* keyFile, CUtf8String groupName, sbyte* key, sbyte* value );
		public extern static sbyte* g_key_file_to_data( GKeyFile* keyFile, uint* length, GError** error );

		public extern static void g_mapped_file_free( GMappedFile* file );
		public extern static sbyte* g_mapped_file_get_contents( GMappedFile* file );
		public extern static uint g_mapped_file_get_length( GMappedFile* file );
		public extern static GMappedFile* g_mapped_file_new( CUtf8String filename, Boolean32 writable, GError** error );

		public extern static uint g_markup_error_quark();
		public extern static sbyte* g_markup_escape_text( CUtf8String text, int length );
		public extern static Boolean32 g_markup_parse_context_end_parse( GMarkupParseContext* context, GError** error );
		public extern static void g_markup_parse_context_free( GMarkupParseContext* context );
		public extern static sbyte* g_markup_parse_context_get_element( GMarkupParseContext* context );
		public extern static void g_markup_parse_context_get_position( GMarkupParseContext* context, int* lineNumber, int* charNumber );
		public extern static GMarkupParseContext* g_markup_parse_context_new( GMarkupParser* parser, GMarkupParseFlags flags, void* userData, Functors.Action<void*> userDataDnotify );
		public extern static Boolean32 g_markup_parse_context_parse( GMarkupParseContext* context, CUtf8String text, int textLen, GError** error );
		public extern static sbyte* g_markup_vprintf_escaped( sbyte* format, sbyte* args );

		public extern static void g_assert_warning( sbyte* logDomain, sbyte* file, int line, sbyte* prettyFunction, sbyte* expression );
		public extern static void g_log_default_handler( sbyte* logDomain, GLogLevelFlags logLevel, sbyte* message, void* unusedData );
		public extern static void g_log_remove_handler( sbyte* logDomain, uint handlerId );
		public extern static GLogLevelFlags g_log_set_always_fatal( GLogLevelFlags fatalMask );
		public extern static Functors.Action<sbyte*, GLogLevelFlags, sbyte*, void*> g_log_set_default_handler( Functors.Action<sbyte*, GLogLevelFlags, sbyte*, void*> logFunc, void* userData );
		public extern static GLogLevelFlags g_log_set_fatal_mask( sbyte* logDomain, GLogLevelFlags fatalMask );
		public extern static uint g_log_set_handler( sbyte* logDomain, GLogLevelFlags logLevels, Functors.Action<sbyte*, GLogLevelFlags, sbyte*, void*> logFunc, void* userData );
		public extern static void g_logv( sbyte* logDomain, GLogLevelFlags logLevel, sbyte* format, sbyte* args );
		public extern static uint g_printf_string_upper_bound( sbyte* format, sbyte* args );
		public extern static void g_return_if_fail_warning( sbyte* logDomain, sbyte* prettyFunction, sbyte* expression );
		public extern static Functors.Action<sbyte*> g_set_print_handler( Functors.Action<sbyte*> func );
		public extern static Functors.Action<sbyte*> g_set_printerr_handler( Functors.Action<sbyte*> func );

		public extern static int g_node_child_index( GNode* node, void* data );
		public extern static int g_node_child_position( GNode* node, GNode* child );
		public extern static void g_node_children_foreach( GNode* node, GTraverseFlags flags, Functors.Action<GNode*, void*> func, void* data );
		public extern static GNode* g_node_copy( GNode* node );
		public extern static GNode* g_node_copy_deep( GNode* node, Functors.Func<void*, void*, void*> copyFunc, void* data );
		public extern static uint g_node_depth( GNode* node );
		public extern static void g_node_destroy( GNode* root );
		public extern static GNode* g_node_find( GNode* root, GTraverseType order, GTraverseFlags flags, void* data );
		public extern static GNode* g_node_find_child( GNode* node, GTraverseFlags flags, void* data );
		public extern static GNode* g_node_first_sibling( GNode* node );
		public extern static GNode* g_node_get_root( GNode* node );
		public extern static GNode* g_node_insert( GNode* parent, int position, GNode* node );
		public extern static GNode* g_node_insert_after( GNode* parent, GNode* sibling, GNode* node );
		public extern static GNode* g_node_insert_before( GNode* parent, GNode* sibling, GNode* node );
		public extern static Boolean32 g_node_is_ancestor( GNode* node, GNode* descendant );
		public extern static GNode* g_node_last_child( GNode* node );
		public extern static GNode* g_node_last_sibling( GNode* node );
		public extern static uint g_node_max_height( GNode* root );
		public extern static uint g_node_n_children( GNode* node );
		public extern static uint g_node_n_nodes( GNode* root, GTraverseFlags flags );
		public extern static GNode* g_node_new( void* data );
		public extern static GNode* g_node_nth_child( GNode* node, uint n );
		public extern static void g_node_pop_allocator();
		public extern static GNode* g_node_prepend( GNode* parent, GNode* node );
		public extern static void g_node_push_allocator( void* dummy );
		public extern static void g_node_reverse_children( GNode* node );
		public extern static void g_node_traverse( GNode* root, GTraverseType order, GTraverseFlags flags, int maxDepth, Functors.Func<GNode*, void*, Boolean32> func, void* data );
		public extern static void g_node_unlink( GNode* node );

		public extern static void g_option_context_add_group( GOptionContext* context, GOptionGroup* group );
		public extern static void g_option_context_add_main_entries( GOptionContext* context, GOptionEntry* entries, sbyte* translationDomain );
		public extern static void g_option_context_free( GOptionContext* context );
		public extern static sbyte* g_option_context_get_description( GOptionContext* context );
		public extern static sbyte* g_option_context_get_help( GOptionContext* context, Boolean32 mainHelp, GOptionGroup* group );
		public extern static Boolean32 g_option_context_get_help_enabled( GOptionContext* context );
		public extern static Boolean32 g_option_context_get_ignore_unknown_options( GOptionContext* context );
		public extern static GOptionGroup* g_option_context_get_main_group( GOptionContext* context );
		public extern static sbyte* g_option_context_get_summary( GOptionContext* context );
		public extern static GOptionContext* g_option_context_new( sbyte* parameterString );
		public extern static Boolean32 g_option_context_parse( GOptionContext* context, int* argc, sbyte*** argv, GError** error );
		public extern static void g_option_context_set_description( GOptionContext* context, CUtf8String description );
		public extern static void g_option_context_set_help_enabled( GOptionContext* context, Boolean32 helpEnabled );
		public extern static void g_option_context_set_ignore_unknown_options( GOptionContext* context, Boolean32 ignoreUnknown );
		public extern static void g_option_context_set_main_group( GOptionContext* context, GOptionGroup* group );
		public extern static void g_option_context_set_summary( GOptionContext* context, sbyte* summary );
		public extern static void g_option_context_set_translate_func( GOptionContext* context, Functors.Func<sbyte*, void*, sbyte*> func, void* data, Functors.Action<void*> destroyNotify );
		public extern static void g_option_context_set_translation_domain( GOptionContext* context, sbyte* domain );
		public extern static uint g_option_error_quark();
		public extern static void g_option_group_add_entries( GOptionGroup* group, GOptionEntry* entries );
		public extern static void g_option_group_free( GOptionGroup* group );
		public extern static GOptionGroup* g_option_group_new( CUtf8String name, CUtf8String description, CUtf8String helpDescription, void* userData, Functors.Action<void*> destroy );
		public extern static void g_option_group_set_error_hook( GOptionGroup* group, Functors.Action<GOptionContext*, GOptionGroup*, void*, GError**> errorFunc );
		public extern static void g_option_group_set_parse_hooks( GOptionGroup* group, Functors.Func<GOptionContext*, GOptionGroup*, void*, GError**, Boolean32> preParseFunc, Functors.Func<GOptionContext*, GOptionGroup*, void*, GError**, Boolean32> postParseFunc );
		public extern static void g_option_group_set_translate_func( GOptionGroup* group, Functors.Func<sbyte*, void*, sbyte*> func, void* data, Functors.Action<void*> destroyNotify );
		public extern static void g_option_group_set_translation_domain( GOptionGroup* group, sbyte* domain );

		public extern static Boolean32 g_pattern_match( GPatternSpec* pspec, uint stringLength, sbyte* @string, sbyte* stringReversed );
		public extern static Boolean32 g_pattern_match_simple( sbyte* pattern, sbyte* @string );
		public extern static Boolean32 g_pattern_match_string( GPatternSpec* pspec, sbyte* @string );
		public extern static Boolean32 g_pattern_spec_equal( GPatternSpec* pspec1, GPatternSpec* pspec2 );
		public extern static void g_pattern_spec_free( GPatternSpec* pspec );
		public extern static GPatternSpec* g_pattern_spec_new( sbyte* pattern );

		[BackendHintReadNone]
		public extern static uint g_spaced_primes_closest( uint num );

		public extern static void g_qsort_with_data( void* pbase, int totalElems, uint size, Functors.Func<void*, void*, void*, int> compareFunc, void* userData );

		public extern static void g_queue_clear( GQueue* queue );
		public extern static GQueue* g_queue_copy( GQueue* queue );
		public extern static void g_queue_delete_link( GQueue* queue, GList* link_ );
		public extern static GList* g_queue_find( GQueue* queue, void* data );
		public extern static GList* g_queue_find_custom( GQueue* queue, void* data, Functors.Func<void*, void*, int> func );
		public extern static void g_queue_foreach( GQueue* queue, Functors.Action<void*, void*> func, void* userData );
		public extern static void g_queue_free( GQueue* queue );
		public extern static uint g_queue_get_length( GQueue* queue );
		public extern static int g_queue_index( GQueue* queue, void* data );
		public extern static void g_queue_init( GQueue* queue );
		public extern static void g_queue_insert_after( GQueue* queue, GList* sibling, void* data );
		public extern static void g_queue_insert_before( GQueue* queue, GList* sibling, void* data );
		public extern static void g_queue_insert_sorted( GQueue* queue, void* data, Functors.Func<void*, void*, void*, int> func, void* userData );
		public extern static Boolean32 g_queue_is_empty( GQueue* queue );
		public extern static int g_queue_link_index( GQueue* queue, GList* link_ );
		public extern static GQueue* g_queue_new();
		public extern static void* g_queue_peek_head( GQueue* queue );
		public extern static GList* g_queue_peek_head_link( GQueue* queue );
		public extern static void* g_queue_peek_nth( GQueue* queue, uint n );
		public extern static GList* g_queue_peek_nth_link( GQueue* queue, uint n );
		public extern static void* g_queue_peek_tail( GQueue* queue );
		public extern static GList* g_queue_peek_tail_link( GQueue* queue );
		public extern static void* g_queue_pop_head( GQueue* queue );
		public extern static GList* g_queue_pop_head_link( GQueue* queue );
		public extern static void* g_queue_pop_nth( GQueue* queue, uint n );
		public extern static GList* g_queue_pop_nth_link( GQueue* queue, uint n );
		public extern static void* g_queue_pop_tail( GQueue* queue );
		public extern static GList* g_queue_pop_tail_link( GQueue* queue );
		public extern static void g_queue_push_head( GQueue* queue, void* data );
		public extern static void g_queue_push_head_link( GQueue* queue, GList* link_ );
		public extern static void g_queue_push_nth( GQueue* queue, void* data, int n );
		public extern static void g_queue_push_nth_link( GQueue* queue, int n, GList* link_ );
		public extern static void g_queue_push_tail( GQueue* queue, void* data );
		public extern static void g_queue_push_tail_link( GQueue* queue, GList* link_ );
		public extern static void g_queue_remove( GQueue* queue, void* data );
		public extern static void g_queue_remove_all( GQueue* queue, void* data );
		public extern static void g_queue_reverse( GQueue* queue );
		public extern static void g_queue_sort( GQueue* queue, Functors.Func<void*, void*, void*, int> compareFunc, void* userData );
		public extern static void g_queue_unlink( GQueue* queue, GList* link_ );

		public extern static GRand* g_rand_copy( GRand* rand_ );
		public extern static double g_rand_double( GRand* rand_ );
		public extern static double g_rand_double_range( GRand* rand_, double begin, double end );
		public extern static void g_rand_free( GRand* rand_ );
		public extern static uint g_rand_int( GRand* rand_ );
		public extern static int g_rand_int_range( GRand* rand_, int begin, int end );
		public extern static GRand* g_rand_new();
		public extern static GRand* g_rand_new_with_seed( uint seed );
		public extern static GRand* g_rand_new_with_seed_array( uint* seed, uint seedLength );
		public extern static void g_rand_set_seed( GRand* rand_, uint seed );
		public extern static void g_rand_set_seed_array( GRand* rand_, uint* seed, uint seedLength );
		public extern static double g_random_double();
		public extern static double g_random_double_range( double begin, double end );
		public extern static uint g_random_int();
		public extern static int g_random_int_range( int begin, int end );
		public extern static void g_random_set_seed( uint seed );

		public extern static int g_relation_count( GRelation* relation, void* key, int field );
		public extern static int g_relation_delete( GRelation* relation, void* key, int field );
		public extern static void g_relation_destroy( GRelation* relation );
		public extern static void g_relation_index( GRelation* relation, int field, Functors.Func<void*, uint> hashFunc, Functors.Func<void*, void*, Boolean32> keyEqualFunc );
		public extern static GRelation* g_relation_new( int fields );
		public extern static void g_relation_print( GRelation* relation );
		public extern static GTuples* g_relation_select( GRelation* relation, void* key, int field );
		public extern static void g_tuples_destroy( GTuples* tuples );
		public extern static void* g_tuples_index( GTuples* tuples, int index_, int field );

		public extern static sbyte* g_match_info_expand_references( GMatchInfo* matchInfo, sbyte* stringToExpand, GError** error );
		public extern static sbyte* g_match_info_fetch( GMatchInfo* matchInfo, int matchNum );
		public extern static sbyte** g_match_info_fetch_all( GMatchInfo* matchInfo );
		public extern static sbyte* g_match_info_fetch_named( GMatchInfo* matchInfo, CUtf8String name );
		public extern static Boolean32 g_match_info_fetch_named_pos( GMatchInfo* matchInfo, CUtf8String name, int* startPos, int* endPos );
		public extern static Boolean32 g_match_info_fetch_pos( GMatchInfo* matchInfo, int matchNum, int* startPos, int* endPos );
		public extern static void g_match_info_free( GMatchInfo* matchInfo );
		public extern static int g_match_info_get_match_count( GMatchInfo* matchInfo );
		public extern static GRegex* g_match_info_get_regex( GMatchInfo* matchInfo );
		public extern static sbyte* g_match_info_get_string( GMatchInfo* matchInfo );
		public extern static Boolean32 g_match_info_is_partial_match( GMatchInfo* matchInfo );
		public extern static Boolean32 g_match_info_matches( GMatchInfo* matchInfo );
		public extern static Boolean32 g_match_info_next( GMatchInfo* matchInfo, GError** error );
		public extern static Boolean32 g_regex_check_replacement( sbyte* replacement, int* hasReferences, GError** error );
		public extern static uint g_regex_error_quark();
		public extern static sbyte* g_regex_escape_string( sbyte* @string, int length );
		public extern static int g_regex_get_capture_count( GRegex* regex );
		public extern static int g_regex_get_max_backref( GRegex* regex );
		public extern static sbyte* g_regex_get_pattern( GRegex* regex );
		public extern static int g_regex_get_string_number( GRegex* regex, CUtf8String name );
		public extern static Boolean32 g_regex_match( GRegex* regex, sbyte* @string, GRegexMatchFlags matchOptions, GMatchInfo** matchInfo );
		public extern static Boolean32 g_regex_match_all( GRegex* regex, sbyte* @string, GRegexMatchFlags matchOptions, GMatchInfo** matchInfo );
		public extern static Boolean32 g_regex_match_all_full( GRegex* regex, sbyte* @string, int stringLen, int startPosition, GRegexMatchFlags matchOptions, GMatchInfo** matchInfo, GError** error );
		public extern static Boolean32 g_regex_match_full( GRegex* regex, sbyte* @string, int stringLen, int startPosition, GRegexMatchFlags matchOptions, GMatchInfo** matchInfo, GError** error );
		public extern static Boolean32 g_regex_match_simple( sbyte* pattern, sbyte* @string, GRegexCompileFlags compileOptions, GRegexMatchFlags matchOptions );
		public extern static GRegex* g_regex_new( sbyte* pattern, GRegexCompileFlags compileOptions, GRegexMatchFlags matchOptions, GError** error );
		public extern static GRegex* g_regex_ref( GRegex* regex );
		public extern static sbyte* g_regex_replace( GRegex* regex, sbyte* @string, int stringLen, int startPosition, sbyte* replacement, GRegexMatchFlags matchOptions, GError** error );
		public extern static sbyte* g_regex_replace_eval( GRegex* regex, sbyte* @string, int stringLen, int startPosition, GRegexMatchFlags matchOptions, Functors.Func<GMatchInfo*, GString*, void*, Boolean32> eval, void* userData, GError** error );
		public extern static sbyte* g_regex_replace_literal( GRegex* regex, sbyte* @string, int stringLen, int startPosition, sbyte* replacement, GRegexMatchFlags matchOptions, GError** error );
		public extern static sbyte** g_regex_split( GRegex* regex, sbyte* @string, GRegexMatchFlags matchOptions );
		public extern static sbyte** g_regex_split_full( GRegex* regex, sbyte* @string, int stringLen, int startPosition, GRegexMatchFlags matchOptions, int maxTokens, GError** error );
		public extern static sbyte** g_regex_split_simple( sbyte* pattern, sbyte* @string, GRegexCompileFlags compileOptions, GRegexMatchFlags matchOptions );
		public extern static void g_regex_unref( GRegex* regex );

		public extern static uint g_scanner_cur_line( GScanner* scanner );
		public extern static uint g_scanner_cur_position( GScanner* scanner );
		public extern static GTokenType g_scanner_cur_token( GScanner* scanner );
		public extern static GTokenValue g_scanner_cur_value( GScanner* scanner );
		public extern static void g_scanner_destroy( GScanner* scanner );
		public extern static Boolean32 g_scanner_eof( GScanner* scanner );
		public extern static GTokenType g_scanner_get_next_token( GScanner* scanner );
		public extern static void g_scanner_input_file( GScanner* scanner, int inputFd );
		public extern static void g_scanner_input_text( GScanner* scanner, CUtf8String text, uint textLen );
		public extern static void* g_scanner_lookup_symbol( GScanner* scanner, sbyte* symbol );
		public extern static GScanner* g_scanner_new( GScannerConfig* configTempl );
		public extern static GTokenType g_scanner_peek_next_token( GScanner* scanner );
		public extern static void g_scanner_scope_add_symbol( GScanner* scanner, uint scopeId, sbyte* symbol, void* value );
		public extern static void g_scanner_scope_foreach_symbol( GScanner* scanner, uint scopeId, Functors.Action<void*, void*, void*> func, void* userData );
		public extern static void* g_scanner_scope_lookup_symbol( GScanner* scanner, uint scopeId, sbyte* symbol );
		public extern static void g_scanner_scope_remove_symbol( GScanner* scanner, uint scopeId, sbyte* symbol );
		public extern static uint g_scanner_set_scope( GScanner* scanner, uint scopeId );
		public extern static void g_scanner_sync_file_offset( GScanner* scanner );
		public extern static void g_scanner_unexp_token( GScanner* scanner, GTokenType expectedToken, sbyte* identifierSpec, sbyte* symbolSpec, CUtf8String symbolName, sbyte* message, int isError );

		public extern static GSequenceIter* g_sequence_append( GSequence* seq, void* data );
		public extern static void g_sequence_foreach( GSequence* seq, Functors.Action<void*, void*> func, void* userData );
		public extern static void g_sequence_foreach_range( GSequenceIter* begin, GSequenceIter* end, Functors.Action<void*, void*> func, void* userData );
		public extern static void g_sequence_free( GSequence* seq );
		public extern static void* g_sequence_get( GSequenceIter* iter );
		public extern static GSequenceIter* g_sequence_get_begin_iter( GSequence* seq );
		public extern static GSequenceIter* g_sequence_get_end_iter( GSequence* seq );
		public extern static GSequenceIter* g_sequence_get_iter_at_pos( GSequence* seq, int pos );
		public extern static int g_sequence_get_length( GSequence* seq );
		public extern static GSequenceIter* g_sequence_insert_before( GSequenceIter* iter, void* data );
		public extern static GSequenceIter* g_sequence_insert_sorted( GSequence* seq, void* data, Functors.Func<void*, void*, void*, int> cmpFunc, void* cmpData );
		public extern static GSequenceIter* g_sequence_insert_sorted_iter( GSequence* seq, void* data, Functors.Func<GSequenceIter*, GSequenceIter*, void*, int> iterCmp, void* cmpData );
		public extern static int g_sequence_iter_compare( GSequenceIter* a, GSequenceIter* b );
		public extern static int g_sequence_iter_get_position( GSequenceIter* iter );
		public extern static GSequence* g_sequence_iter_get_sequence( GSequenceIter* iter );
		public extern static Boolean32 g_sequence_iter_is_begin( GSequenceIter* iter );
		public extern static Boolean32 g_sequence_iter_is_end( GSequenceIter* iter );
		public extern static GSequenceIter* g_sequence_iter_move( GSequenceIter* iter, int delta );
		public extern static GSequenceIter* g_sequence_iter_next( GSequenceIter* iter );
		public extern static GSequenceIter* g_sequence_iter_prev( GSequenceIter* iter );
		public extern static void g_sequence_move( GSequenceIter* src, GSequenceIter* dest );
		public extern static void g_sequence_move_range( GSequenceIter* dest, GSequenceIter* begin, GSequenceIter* end );
		public extern static GSequence* g_sequence_new( Functors.Action<void*> dataDestroy );
		public extern static GSequenceIter* g_sequence_prepend( GSequence* seq, void* data );
		public extern static GSequenceIter* g_sequence_range_get_midpoint( GSequenceIter* begin, GSequenceIter* end );
		public extern static void g_sequence_remove( GSequenceIter* iter );
		public extern static void g_sequence_remove_range( GSequenceIter* begin, GSequenceIter* end );
		public extern static GSequenceIter* g_sequence_search( GSequence* seq, void* data, Functors.Func<void*, void*, void*, int> cmpFunc, void* cmpData );
		public extern static GSequenceIter* g_sequence_search_iter( GSequence* seq, void* data, Functors.Func<GSequenceIter*, GSequenceIter*, void*, int> iterCmp, void* cmpData );
		public extern static void g_sequence_set( GSequenceIter* iter, void* data );
		public extern static void g_sequence_sort( GSequence* seq, Functors.Func<void*, void*, void*, int> cmpFunc, void* cmpData );
		public extern static void g_sequence_sort_changed( GSequenceIter* iter, Functors.Func<void*, void*, void*, int> cmpFunc, void* cmpData );
		public extern static void g_sequence_sort_changed_iter( GSequenceIter* iter, Functors.Func<GSequenceIter*, GSequenceIter*, void*, int> iterCmp, void* cmpData );
		public extern static void g_sequence_sort_iter( GSequence* seq, Functors.Func<GSequenceIter*, GSequenceIter*, void*, int> cmpFunc, void* cmpData );
		public extern static void g_sequence_swap( GSequenceIter* a, GSequenceIter* b );

		public extern static uint g_shell_error_quark();
		public extern static Boolean32 g_shell_parse_argv( sbyte* commandLine, int* argcp, sbyte*** argvp, GError** error );
		public extern static sbyte* g_shell_quote( sbyte* unquotedString );
		public extern static sbyte* g_shell_unquote( sbyte* quotedString, GError** error );

		public extern static Boolean32 g_spawn_async( sbyte* workingDirectory, sbyte** argv, sbyte** envp, GSpawnFlags flags, Functors.Action<void*> childSetup, void* userData, int* childPid, GError** error );
		public extern static Boolean32 g_spawn_async_with_pipes( sbyte* workingDirectory, sbyte** argv, sbyte** envp, GSpawnFlags flags, Functors.Action<void*> childSetup, void* userData, int* childPid, int* standardInput, int* standardOutput, int* standardError, GError** error );
		public extern static void g_spawn_close_pid( int pid );
		public extern static Boolean32 g_spawn_command_line_async( sbyte* commandLine, GError** error );
		public extern static Boolean32 g_spawn_command_line_sync( sbyte* commandLine, sbyte** standardOutput, sbyte** standardError, int* exitStatus, GError** error );
		public extern static uint g_spawn_error_quark();
		public extern static Boolean32 g_spawn_sync( sbyte* workingDirectory, sbyte** argv, sbyte** envp, GSpawnFlags flags, Functors.Action<void*> childSetup, void* userData, sbyte** standardOutput, sbyte** standardError, int* exitStatus, GError** error );

		[BackendHintReadNone]
		public extern static int g_ascii_digit_value( sbyte c );
		public extern static sbyte* g_ascii_dtostr( sbyte* buffer, int bufLen, double d );
		public extern static sbyte* g_ascii_formatd( sbyte* buffer, int bufLen, sbyte* format, double d );
		public extern static int g_ascii_strcasecmp( sbyte* s1, sbyte* s2 );
		public extern static sbyte* g_ascii_strdown( sbyte* str, int len );
		public extern static int g_ascii_strncasecmp( sbyte* s1, sbyte* s2, uint n );
		public extern static double g_ascii_strtod( sbyte* nptr, sbyte** endptr );
		public extern static long g_ascii_strtoll( sbyte* nptr, sbyte** endptr, uint @base );
		public extern static ulong g_ascii_strtoull( sbyte* nptr, sbyte** endptr, uint @base );
		public extern static sbyte* g_ascii_strup( sbyte* str, int len );
		[BackendHintReadNone]
		public extern static sbyte g_ascii_tolower( sbyte c );
		[BackendHintReadNone]
		public extern static sbyte g_ascii_toupper( sbyte c );
		[BackendHintReadNone]
		public extern static int g_ascii_xdigit_value( sbyte c );
		public extern static void* g_memdup( void* mem, uint byteSize );
		public extern static sbyte* g_stpcpy( sbyte* dest, sbyte* src );
		public extern static Boolean32 g_str_has_prefix( sbyte* str, sbyte* prefix );
		public extern static Boolean32 g_str_has_suffix( sbyte* str, sbyte* suffix );
		public extern static sbyte* g_strcanon( sbyte* @string, sbyte* validChars, sbyte substitutor );
		public extern static int g_strcasecmp( sbyte* s1, sbyte* s2 );
		public extern static sbyte* g_strchomp( sbyte* @string );
		public extern static sbyte* g_strchug( sbyte* @string );
		public extern static sbyte* g_strcompress( sbyte* source );
		public extern static sbyte* g_strdelimit( sbyte* @string, sbyte* delimiters, sbyte newDelimiter );
		public extern static sbyte* g_strdown( sbyte* @string );
		public extern static sbyte* g_strdup( sbyte* str );
		public extern static sbyte* g_strdup_vprintf( sbyte* format, sbyte* args );
		public extern static sbyte** g_strdupv( sbyte** strArray );
		[BackendHintReadNone]
		public extern static sbyte* g_strerror( int errnum );
		public extern static sbyte* g_strescape( sbyte* source, sbyte* exceptions );
		public extern static void g_strfreev( sbyte** strArray );
		public extern static sbyte* g_strip_context( sbyte* msgid, sbyte* msgval );
		public extern static sbyte* g_strjoinv( sbyte* separator, sbyte** strArray );
		public extern static uint g_strlcat( sbyte* dest, sbyte* src, uint destSize );
		public extern static uint g_strlcpy( sbyte* dest, sbyte* src, uint destSize );
		public extern static int g_strncasecmp( sbyte* s1, sbyte* s2, uint n );
		public extern static sbyte* g_strndup( sbyte* str, uint n );
		public extern static sbyte* g_strnfill( uint length, sbyte fillChar );
		public extern static sbyte* g_strreverse( sbyte* @string );
		public extern static sbyte* g_strrstr( sbyte* haystack, sbyte* needle );
		public extern static sbyte* g_strrstr_len( sbyte* haystack, int haystackLen, sbyte* needle );
		[BackendHintReadNone]
		public extern static sbyte* g_strsignal( int signum );
		public extern static sbyte** g_strsplit( sbyte* @string, sbyte* delimiter, int maxTokens );
		public extern static sbyte** g_strsplit_set( sbyte* @string, sbyte* delimiters, int maxTokens );
		public extern static sbyte* g_strstr_len( sbyte* haystack, int haystackLen, sbyte* needle );
		public extern static double g_strtod( sbyte* nptr, sbyte** endptr );
		public extern static sbyte* g_strup( sbyte* @string );
		public extern static uint g_strv_length( sbyte** strArray );

		public extern static void g_thread_pool_free( GThreadPool* pool, Boolean32 immediate, Boolean32 wait_ );
		public extern static uint g_thread_pool_get_max_idle_time();
		public extern static int g_thread_pool_get_max_threads( GThreadPool* pool );
		public extern static int g_thread_pool_get_max_unused_threads();
		public extern static uint g_thread_pool_get_num_threads( GThreadPool* pool );
		public extern static uint g_thread_pool_get_num_unused_threads();
		public extern static GThreadPool* g_thread_pool_new( Functors.Action<void*, void*> func, void* userData, int maxThreads, Boolean32 exclusive, GError** error );
		public extern static void g_thread_pool_push( GThreadPool* pool, void* data, GError** error );
		public extern static void g_thread_pool_set_max_idle_time( uint interval );
		public extern static void g_thread_pool_set_max_threads( GThreadPool* pool, int maxThreads, GError** error );
		public extern static void g_thread_pool_set_max_unused_threads( int maxThreads );
		public extern static void g_thread_pool_set_sort_function( GThreadPool* pool, Functors.Func<void*, void*, void*, int> func, void* userData );
		public extern static void g_thread_pool_stop_unused_threads();
		public extern static uint g_thread_pool_unprocessed( GThreadPool* pool );

		public extern static void g_time_val_add( GTimeVal* time_, intptr microseconds );
		public extern static Boolean32 g_time_val_from_iso8601( sbyte* isoDate, GTimeVal* time_ );
		public extern static sbyte* g_time_val_to_iso8601( GTimeVal* time_ );
		public extern static void g_timer_continue( GTimer* timer );
		public extern static void g_timer_destroy( GTimer* timer );
		public extern static double g_timer_elapsed( GTimer* timer, uintptr* microseconds );
		public extern static GTimer* g_timer_new();
		public extern static void g_timer_reset( GTimer* timer );
		public extern static void g_timer_start( GTimer* timer );
		public extern static void g_timer_stop( GTimer* timer );
		public extern static void g_usleep( uintptr microseconds );

		public extern static void g_tree_destroy( GTree* tree );
		public extern static void g_tree_foreach( GTree* tree, Functors.Func<void*, void*, void*, Boolean32> func, void* userData );
		public extern static int g_tree_height( GTree* tree );
		public extern static void g_tree_insert( GTree* tree, void* key, void* value );
		public extern static void* g_tree_lookup( GTree* tree, void* key );
		public extern static Boolean32 g_tree_lookup_extended( GTree* tree, void* lookupKey, void** origKey, void** value );
		public extern static GTree* g_tree_new( Functors.Func<void*, void*, int> keyCompareFunc );
		public extern static GTree* g_tree_new_full( Functors.Func<void*, void*, void*, int> keyCompareFunc, void* keyCompareData, Functors.Action<void*> keyDestroyFunc, Functors.Action<void*> valueDestroyFunc );
		public extern static GTree* g_tree_new_with_data( Functors.Func<void*, void*, void*, int> keyCompareFunc, void* keyCompareData );
		public extern static int g_tree_nnodes( GTree* tree );
		public extern static Boolean32 g_tree_remove( GTree* tree, void* key );
		public extern static void g_tree_replace( GTree* tree, void* key, void* value );
		public extern static void* g_tree_search( GTree* tree, Functors.Func<void*, void*, int> searchFunc, void* userData );
		public extern static Boolean32 g_tree_steal( GTree* tree, void* key );
		public extern static void g_tree_traverse( GTree* tree, Functors.Func<void*, void*, void*, Boolean32> traverseFunc, GTraverseType traverseType, void* userData );
	}
	[ExternLibrary( Image = "/usr/lib/libgobject-2.0.so" )]
	public static partial struct GObjectApi {
		public extern static void g_type_add_class_cache_func( void* cacheData, Functors.Func<void*, GTypeClass*, Boolean32> cacheFunc );
		public extern static void g_type_add_interface_check( void* checkData, Functors.Action<void*, void*> checkFunc );
		public extern static void g_type_add_interface_dynamic( uintptr instanceType, uintptr interfaceType, GTypePlugin* plugin );
		public extern static void g_type_add_interface_static( uintptr instanceType, uintptr interfaceType, GInterfaceInfo* info );
		public extern static GTypeClass* g_type_check_class_cast( GTypeClass* gClass, uintptr isAType );
		[BackendHintReadOnly]
		public extern static Boolean32 g_type_check_class_is_a( GTypeClass* gClass, uintptr isAType );
		[BackendHintReadOnly]
		public extern static Boolean32 g_type_check_instance( GTypeInstance* instance );
		public extern static GTypeInstance* g_type_check_instance_cast( GTypeInstance* instance, uintptr ifaceType );
		[BackendHintReadOnly]
		public extern static Boolean32 g_type_check_instance_is_a( GTypeInstance* instance, uintptr ifaceType );
		[BackendHintReadNone]
		public extern static Boolean32 g_type_check_is_value_type( uintptr type );
		[BackendHintReadOnly]
		public extern static Boolean32 g_type_check_value( GValue* value );
		[BackendHintReadOnly]
		public extern static Boolean32 g_type_check_value_holds( GValue* value, uintptr type );
		public extern static uintptr* g_type_children( GType type, uint* nChildren );
		public extern static void g_type_class_add_private( void* gClass, uint privateSize );
		public extern static void* g_type_class_peek( uintptr type );
		public extern static void* g_type_class_peek_parent( void* gClass );
		public extern static void* g_type_class_peek_static( uintptr type );
		public extern static void* g_type_class_ref( uintptr type );
		public extern static void g_type_class_unref( void* gClass );
		public extern static void g_type_class_unref_uncached( void* gClass );
		public extern static GTypeInstance* g_type_create_instance( uintptr type );
		public extern static void* g_type_default_interface_peek( uintptr gType );
		public extern static void* g_type_default_interface_ref( uintptr gType );
		public extern static void g_type_default_interface_unref( void* gIface );
		public extern static uint g_type_depth( uintptr type );
		public extern static void g_type_free_instance( GTypeInstance* instance );
		public extern static uintptr g_type_from_name( CUtf8String name );
		public extern static uintptr g_type_fundamental( uintptr typeId );
		public extern static uintptr g_type_fundamental_next();
		public extern static GTypePlugin* g_type_get_plugin( uintptr type );
		public extern static void* g_type_get_qdata( GType type, uint quark );
		public extern static void g_type_init();
		public extern static void g_type_init_with_debug_flags( GTypeDebugFlags debugFlags );
		public extern static void* g_type_instance_get_private( GTypeInstance* instance, uintptr privateType );
		public extern static void g_type_interface_add_prerequisite( uintptr interfaceType, uintptr prerequisiteType );
		public extern static GTypePlugin* g_type_interface_get_plugin( uintptr instanceType, uintptr interfaceType );
		public extern static void* g_type_interface_peek( void* instanceClass, uintptr ifaceType );
		public extern static void* g_type_interface_peek_parent( void* gIface );
		public extern static uintptr* g_type_interface_prerequisites( uintptr interfaceType, uint* nPrerequisites );
		public extern static uintptr* g_type_interfaces( GType type, uint* nInterfaces );
		public extern static Boolean32 g_type_is_a( uintptr type, uintptr isAType );
		public extern static CUtf8String g_type_name( uintptr type );
		public extern static sbyte* g_type_name_from_class( GTypeClass* gClass );
		public extern static sbyte* g_type_name_from_instance( GTypeInstance* instance );
		public extern static uintptr g_type_next_base( uintptr leafType, uintptr rootType );
		public extern static uintptr g_type_parent( uintptr type );
		public extern static uint g_type_qname( uintptr type );
		public extern static void g_type_query( GType type, GTypeQuery* query );
		public extern static GType g_type_register_dynamic( GType parentType, CUtf8String typeName, GTypePlugin* plugin, GTypeFlags flags );
		public extern static GType g_type_register_fundamental( GType typeId, CUtf8String typeName, GTypeInfo* info, GTypeFundamentalInfo* finfo, GTypeFlags flags );
		public extern static GType g_type_register_static( GType parentType, CUtf8String typeName, GTypeInfo* info, GTypeFlags flags );
		public extern static GType g_type_register_static_simple( GType parentType, CUtf8String typeName, uint classSize, Functors.Action<void*, void*> classInit, uint instanceSize, Functors.Action<GTypeInstance*, void*> instanceInit, GTypeFlags flags );
		public extern static void g_type_remove_class_cache_func( void* cacheData, Functors.Func<void*, GTypeClass*, Boolean32> cacheFunc );
		public extern static void g_type_remove_interface_check( void* checkData, Functors.Action<void*, void*> checkFunc );
		public extern static void g_type_set_qdata( GType type, uint quark, void* data );
		[BackendHintReadNone]
		public extern static Boolean32 g_type_test_flags( uintptr type, uint flags );
		public extern static GTypeValueTable* g_type_value_table_peek( uintptr type );

		public extern static void* g_boxed_copy( uintptr boxedType, void* srcBoxed );
		public extern static void g_boxed_free( uintptr boxedType, void* boxed );
		public extern static uintptr g_boxed_type_register_static( CUtf8String name, Functors.Func<void*, void*> boxedCopy, Functors.Action<void*> boxedFree );
		[BackendHintReadNone]
		public extern static GType g_closure_get_type();
		[BackendHintReadNone]
		public extern static GType g_date_get_type();
		[BackendHintReadNone]
		public extern static GType g_gstring_get_type();
		[BackendHintReadNone]
		public extern static GType g_hash_table_get_type();
		[BackendHintReadNone]
		public extern static GType g_regex_get_type();
		[BackendHintReadNone]
		public extern static GType g_strv_get_type();
		[BackendHintReadNone]
		public extern static GType g_value_array_get_type();
		public extern static void* g_value_dup_boxed( GValue* value );
		public extern static void* g_value_get_boxed( GValue* value );
		[BackendHintReadNone]
		public extern static GType g_value_get_type();
		public extern static void g_value_set_boxed( GValue* value, void* vBoxed );
		public extern static void g_value_set_boxed_take_ownership( GValue* value, void* vBoxed );
		public extern static void g_value_set_static_boxed( GValue* value, void* vBoxed );
		public extern static void g_value_take_boxed( GValue* value, void* vBoxed );

		public extern static void g_enum_complete_type_info( uintptr gEnumType, GTypeInfo* info, GEnumValue* constValues );
		public extern static GEnumValue* g_enum_get_value( GEnumClass* enumClass, int value );
		public extern static GEnumValue* g_enum_get_value_by_name( GEnumClass* enumClass, CUtf8String name );
		public extern static GEnumValue* g_enum_get_value_by_nick( GEnumClass* enumClass, sbyte* nick );
		public extern static uintptr g_enum_register_static( CUtf8String name, GEnumValue* constStaticValues );
		public extern static void g_flags_complete_type_info( uintptr gFlagsType, GTypeInfo* info, GFlagsValue* constValues );
		public extern static GFlagsValue* g_flags_get_first_value( GFlagsClass* flagsClass, uint value );
		public extern static GFlagsValue* g_flags_get_value_by_name( GFlagsClass* flagsClass, CUtf8String name );
		public extern static GFlagsValue* g_flags_get_value_by_nick( GFlagsClass* flagsClass, sbyte* nick );
		public extern static uintptr g_flags_register_static( CUtf8String name, GFlagsValue* constStaticValues );
		public extern static int g_value_get_enum( GValue* value );
		public extern static uint g_value_get_flags( GValue* value );
		public extern static void g_value_set_enum( GValue* value, int vEnum );
		public extern static void g_value_set_flags( GValue* value, uint vFlags );

		public extern static void g_value_copy( GValue* srcValue, GValue* destValue );
		public extern static Boolean32 g_value_fits_pointer( GValue* value );
		public extern static GValue* g_value_init( GValue* value, uintptr gType );
		public extern static void* g_value_peek_pointer( GValue* value );
		public extern static void g_value_register_transform_func( uintptr srcType, uintptr destType, Functors.Action<GValue*, GValue*> transformFunc );
		public extern static GValue* g_value_reset( GValue* value );
		public extern static void g_value_set_instance( GValue* value, void* instance );
		public extern static Boolean32 g_value_transform( GValue* srcValue, GValue* destValue );
		public extern static Boolean32 g_value_type_compatible( uintptr srcType, uintptr destType );
		public extern static Boolean32 g_value_type_transformable( uintptr srcType, uintptr destType );
		public extern static void g_value_unset( GValue* value );

		public extern static sbyte* g_param_spec_get_blurb( GParamSpec* pspec );
		public extern static sbyte* g_param_spec_get_name( GParamSpec* pspec );
		public extern static sbyte* g_param_spec_get_nick( GParamSpec* pspec );
		public extern static void* g_param_spec_get_qdata( GParamSpec* pspec, uint quark );
		public extern static GParamSpec* g_param_spec_get_redirect_target( GParamSpec* pspec );
		public extern static void* g_param_spec_internal( uintptr paramType, CUtf8String name, sbyte* nick, sbyte* blurb, GParamFlags flags );
		public extern static void g_param_spec_pool_insert( GParamSpecPool* pool, GParamSpec* pspec, uintptr ownerType );
		public extern static GParamSpec** g_param_spec_pool_list( GParamSpecPool* pool, uintptr ownerType, uint* nPspecsP );
		public extern static GList* g_param_spec_pool_list_owned( GParamSpecPool* pool, uintptr ownerType );
		public extern static GParamSpec* g_param_spec_pool_lookup( GParamSpecPool* pool, CUtf8String paramName, uintptr ownerType, Boolean32 walkAncestors );
		public extern static GParamSpecPool* g_param_spec_pool_new( Boolean32 typePrefixing );
		public extern static void g_param_spec_pool_remove( GParamSpecPool* pool, GParamSpec* pspec );
		public extern static GParamSpec* g_param_spec_ref( GParamSpec* pspec );
		public extern static GParamSpec* g_param_spec_ref_sink( GParamSpec* pspec );
		public extern static void g_param_spec_set_qdata( GParamSpec* pspec, uint quark, void* data );
		public extern static void g_param_spec_set_qdata_full( GParamSpec* pspec, uint quark, void* data, Functors.Action<void*> destroy );
		public extern static void g_param_spec_sink( GParamSpec* pspec );
		public extern static void* g_param_spec_steal_qdata( GParamSpec* pspec, uint quark );
		public extern static void g_param_spec_unref( GParamSpec* pspec );
		public extern static uintptr g_param_type_register_static( CUtf8String name, GParamSpecTypeInfo* pspecInfo );
		public extern static Boolean32 g_param_value_convert( GParamSpec* pspec, GValue* srcValue, GValue* destValue, Boolean32 strictValidation );
		public extern static Boolean32 g_param_value_defaults( GParamSpec* pspec, GValue* value );
		public extern static void g_param_value_set_default( GParamSpec* pspec, GValue* value );
		public extern static Boolean32 g_param_value_validate( GParamSpec* pspec, GValue* value );
		public extern static int g_param_values_cmp( GParamSpec* pspec, GValue* value1, GValue* value2 );
		public extern static GParamSpec* g_value_dup_param( GValue* value );
		public extern static GParamSpec* g_value_get_param( GValue* value );
		public extern static void g_value_set_param( GValue* value, GParamSpec* param );
		public extern static void g_value_set_param_take_ownership( GValue* value, GParamSpec* param );
		public extern static void g_value_take_param( GValue* value, GParamSpec* param );

		public extern static GClosure* g_cclosure_new( Functors.Action callbackFunc, void* userData, Functors.Action<void*, GClosure*> destroyData );
		public extern static GClosure* g_cclosure_new_swap( Functors.Action callbackFunc, void* userData, Functors.Action<void*, GClosure*> destroyData );
		public extern static void g_closure_add_finalize_notifier( GClosure* closure, void* notifyData, Functors.Action<void*, GClosure*> notifyFunc );
		public extern static void g_closure_add_invalidate_notifier( GClosure* closure, void* notifyData, Functors.Action<void*, GClosure*> notifyFunc );
		public extern static void g_closure_add_marshal_guards( GClosure* closure, void* preMarshalData, Functors.Action<void*, GClosure*> preMarshalNotify, void* postMarshalData, Functors.Action<void*, GClosure*> postMarshalNotify );
		public extern static void g_closure_invalidate( GClosure* closure );
		public extern static void g_closure_invoke( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint );
		public extern static GClosure* g_closure_new_simple( uint sizeofClosure, void* data );
		public extern static GClosure* g_closure_ref( GClosure* closure );
		public extern static void g_closure_remove_finalize_notifier( GClosure* closure, void* notifyData, Functors.Action<void*, GClosure*> notifyFunc );
		public extern static void g_closure_remove_invalidate_notifier( GClosure* closure, void* notifyData, Functors.Action<void*, GClosure*> notifyFunc );
		public extern static void g_closure_set_marshal( GClosure* closure, Functors.Action<GClosure*, GValue*, uint, GValue*, void*, void*> marshal );
		public extern static void g_closure_set_meta_marshal( GClosure* closure, void* marshalData, Functors.Action<GClosure*, GValue*, uint, GValue*, void*, void*> metaMarshal );
		public extern static void g_closure_sink( GClosure* closure );
		public extern static void g_closure_unref( GClosure* closure );
		public extern static GClosure* g_signal_type_cclosure_new( uintptr itype, uint structOffset );

		public extern static void g_cclosure_marshal_BOOLEAN__FLAGS( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_STRING__OBJECT_POINTER( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__BOOLEAN( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__BOXED( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__CHAR( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__DOUBLE( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__ENUM( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__FLAGS( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__FLOAT( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__INT( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__LONG( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__OBJECT( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__PARAM( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__POINTER( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__STRING( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__UCHAR( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__UINT( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__UINT_POINTER( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__ULONG( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );
		public extern static void g_cclosure_marshal_VOID__VOID( GClosure* closure, GValue* returnValue, uint nParamValues, GValue* paramValues, void* invocationHint, void* marshalData );

		public extern static Boolean32 g_signal_accumulator_true_handled( GSignalInvocationHint* ihint, GValue* returnAccu, GValue* handlerReturn, void* dummy );
		public extern static uintptr g_signal_add_emission_hook( uint signalId, uint detail, Functors.Func<GSignalInvocationHint*, uint, GValue*, void*, Boolean32> hookFunc, void* hookData, Functors.Action<void*> dataDestroy );
		public extern static void g_signal_chain_from_overridden( GValue* instanceAndParams, GValue* returnValue );
		public extern static uintptr g_signal_connect_closure( void* instance, CUtf8String detailedSignal, GClosure* closure, Boolean32 after );
		public extern static uintptr g_signal_connect_closure_by_id( void* instance, uint signalId, uint detail, GClosure* closure, Boolean32 after );
		public extern static uintptr g_signal_connect_data( void* instance, CUtf8String detailedSignal, Functors.Action<void*, void*> cHandler, void* data, Functors.Action<void*, GClosure*> destroyData, GConnectFlags connectFlags );
		public extern static void g_signal_emit_valist( void* instance, uint signalId, uint detail, sbyte* varArgs );
		public extern static void g_signal_emitv( GValue* instanceAndParams, uint signalId, uint detail, GValue* returnValue );
		public extern static GSignalInvocationHint* g_signal_get_invocation_hint( void* instance );
		public extern static void g_signal_handler_block( void* instance, uintptr handlerId );
		public extern static void g_signal_handler_disconnect( void* instance, uintptr handlerId );
		public extern static uintptr g_signal_handler_find( void* instance, GSignalMatchType mask, uint signalId, uint detail, GClosure* closure, void* func, void* data );
		public extern static Boolean32 g_signal_handler_is_connected( void* instance, uintptr handlerId );
		public extern static void g_signal_handler_unblock( void* instance, uintptr handlerId );
		public extern static uint g_signal_handlers_block_matched( void* instance, GSignalMatchType mask, uint signalId, uint detail, GClosure* closure, void* func, void* data );
		public extern static void g_signal_handlers_destroy( void* instance );
		public extern static uint g_signal_handlers_disconnect_matched( void* instance, GSignalMatchType mask, uint signalId, uint detail, GClosure* closure, void* func, void* data );
		public extern static uint g_signal_handlers_unblock_matched( void* instance, GSignalMatchType mask, uint signalId, uint detail, GClosure* closure, void* func, void* data );
		public extern static Boolean32 g_signal_has_handler_pending( void* instance, uint signalId, uint detail, Boolean32 mayBeBlocked );
		public extern static uint* g_signal_list_ids( uintptr itype, uint* nIds );
		public extern static uint g_signal_lookup( CUtf8String name, uintptr itype );
		public extern static sbyte* g_signal_name( uint signalId );
		public extern static uint g_signal_new_valist( CUtf8String signalName, uintptr itype, GSignalFlags signalFlags, GClosure* classClosure, Functors.Func<GSignalInvocationHint*, GValue*, GValue*, void*, Boolean32> accumulator, void* accuData, Functors.Action<GClosure*, GValue*, uint, GValue*, void*, void*> cMarshaller, uintptr returnType, uint nParams, sbyte* args );
		public extern static uint g_signal_newv( CUtf8String signalName, uintptr itype, GSignalFlags signalFlags, GClosure* classClosure, Functors.Func<GSignalInvocationHint*, GValue*, GValue*, void*, Boolean32> accumulator, void* accuData, Functors.Action<GClosure*, GValue*, uint, GValue*, void*, void*> cMarshaller, uintptr returnType, uint nParams, uintptr* paramTypes );
		public extern static void g_signal_override_class_closure( uint signalId, uintptr instanceType, GClosure* classClosure );
		public extern static Boolean32 g_signal_parse_name( CUtf8String detailedSignal, uintptr itype, uint& signalIdP, uint& detailP, Boolean32 forceDetailQuark );
		public extern static void g_signal_query( uint signalId, GSignalQuery* query );
		public extern static void g_signal_remove_emission_hook( uint signalId, uintptr hookId );
		public extern static void g_signal_stop_emission( void* instance, uint signalId, uint detail );
		public extern static void g_signal_stop_emission_by_name( void* instance, sbyte* detailedSignal );

		public extern static GClosure* g_cclosure_new_object( Functors.Action callbackFunc, GObject* object );
		public extern static GClosure* g_cclosure_new_object_swap( Functors.Action callbackFunc, GObject* object );
		public extern static GClosure* g_closure_new_object( uint sizeofClosure, GObject* object );
		public extern static GType g_initially_unowned_get_type();
		public extern static void g_object_add_toggle_ref( GObject* object, Functors.Action<void*, GObject*, Boolean32> notify, void* data );
		public extern static void g_object_add_weak_pointer( GObject* object, void** weakPointerLocation );
		public extern static GParamSpec* g_object_class_find_property( GObject.Class* oclass, CUtf8String propertyName );
		public extern static void g_object_class_install_property( GObject.Class* oclass, uint propertyId, GParamSpec* pspec );
		public extern static GParamSpec** g_object_class_list_properties( GObject.Class* oclass, uint* nProperties );
		public extern static void g_object_class_override_property( GObject.Class* oclass, uint propertyId, CUtf8String name );
		public extern static uint g_object_compat_control( uint what, void* data );
		public extern static void g_object_force_floating( GObject* object );
		public extern static void g_object_freeze_notify( GObject* object );
		public extern static void* g_object_get_data( GObject* object, sbyte* key );
		public extern static void g_object_get_property( GObject* object, CUtf8String propertyName, GValue& value );
		public extern static void* g_object_get_qdata( GObject* object, uint quark );
		public extern static void g_object_get_valist( GObject* object, CUtf8String firstPropertyName, sbyte* varArgs );
		public extern static GParamSpec* g_object_interface_find_property( void* gIface, CUtf8String propertyName );
		public extern static void g_object_interface_install_property( void* gIface, GParamSpec* pspec );
		public extern static GParamSpec** g_object_interface_list_properties( void* gIface, uint* nPropertiesP );
		public extern static Boolean32 g_object_is_floating( void* object );
		public extern static GObject* g_object_new_valist( uintptr objectType, CUtf8String firstPropertyName, sbyte* varArgs );
		public extern static void* g_object_newv( uintptr objectType, uint nParameters, GParameter* parameters );
		public extern static void g_object_notify( GObject* object, CUtf8String propertyName );
		public extern static void* g_object_ref( void* object );
		public extern static void* g_object_ref_sink( void* object );
		public extern static void g_object_remove_toggle_ref( GObject* object, Functors.Action<void*, GObject*, Boolean32> notify, void* data );
		public extern static void g_object_remove_weak_pointer( GObject* object, void** weakPointerLocation );
		public extern static void g_object_run_dispose( GObject* object );
		public extern static void g_object_set_data( GObject* object, sbyte* key, void* data );
		public extern static void g_object_set_data_full( GObject* object, sbyte* key, void* data, Functors.Action<void*> destroy );
		public extern static void g_object_set_property( GObject* object, CUtf8String propertyName, GValue& value );
		public extern static void g_object_set_qdata( GObject* object, uint quark, void* data );
		public extern static void g_object_set_qdata_full( GObject* object, uint quark, void* data, Functors.Action<void*> destroy );
		public extern static void g_object_set_valist( GObject* object, CUtf8String firstPropertyName, sbyte* varArgs );
		public extern static void* g_object_steal_data( GObject* object, sbyte* key );
		public extern static void* g_object_steal_qdata( GObject* object, uint quark );
		public extern static void g_object_thaw_notify( GObject* object );
		public extern static void g_object_unref( void* object );
		public extern static void g_object_watch_closure( GObject* object, GClosure* closure );
		public extern static void g_object_weak_ref( GObject* object, Functors.Action<void*, GObject*> notify, void* data );
		public extern static void g_object_weak_unref( GObject* object, Functors.Action<void*, GObject*> notify, void* data );
		public extern static uintptr g_signal_connect_object( void* instance, sbyte* detailedSignal, Functors.Action cHandler, void* gobject, GConnectFlags connectFlags );
		public extern static void* g_value_dup_object( GValue* value );
		public extern static void* g_value_get_object( GValue* value );
		public extern static void g_value_set_object( GValue* value, void* vObject );
		public extern static void g_value_set_object_take_ownership( GValue* value, void* vObject );
		public extern static void g_value_take_object( GValue* value, void* vObject );

		public extern static GParamSpec* g_param_spec_boolean( CUtf8String name, sbyte* nick, sbyte* blurb, Boolean32 defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_boxed( CUtf8String name, sbyte* nick, sbyte* blurb, uintptr boxedType, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_char( CUtf8String name, sbyte* nick, sbyte* blurb, sbyte minimum, sbyte maximum, sbyte defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_double( CUtf8String name, sbyte* nick, sbyte* blurb, double minimum, double maximum, double defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_enum( CUtf8String name, sbyte* nick, sbyte* blurb, uintptr enumType, int defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_flags( CUtf8String name, sbyte* nick, sbyte* blurb, uintptr flagsType, uint defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_float( CUtf8String name, sbyte* nick, sbyte* blurb, float minimum, float maximum, float defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_gtype( CUtf8String name, sbyte* nick, sbyte* blurb, uintptr isAType, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_int( CUtf8String name, sbyte* nick, sbyte* blurb, int minimum, int maximum, int defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_int64( CUtf8String name, sbyte* nick, sbyte* blurb, long minimum, long maximum, long defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_long( CUtf8String name, sbyte* nick, sbyte* blurb, intptr minimum, intptr maximum, intptr defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_object( CUtf8String name, sbyte* nick, sbyte* blurb, uintptr objectType, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_override( CUtf8String name, GParamSpec* overridden );
		public extern static GParamSpec* g_param_spec_param( CUtf8String name, sbyte* nick, sbyte* blurb, uintptr paramType, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_pointer( CUtf8String name, sbyte* nick, sbyte* blurb, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_string( CUtf8String name, sbyte* nick, sbyte* blurb, sbyte* defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_uchar( CUtf8String name, sbyte* nick, sbyte* blurb, byte minimum, byte maximum, byte defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_uint( CUtf8String name, sbyte* nick, sbyte* blurb, uint minimum, uint maximum, uint defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_uint64( CUtf8String name, sbyte* nick, sbyte* blurb, ulong minimum, ulong maximum, ulong defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_ulong( CUtf8String name, sbyte* nick, sbyte* blurb, uintptr minimum, uintptr maximum, uintptr defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_unichar( CUtf8String name, sbyte* nick, sbyte* blurb, uint defaultValue, GParamFlags flags );
		public extern static GParamSpec* g_param_spec_value_array( CUtf8String name, sbyte* nick, sbyte* blurb, GParamSpec* elementSpec, GParamFlags flags );

		public extern static GType g_io_channel_get_type();
		public extern static GType g_io_condition_get_type();
		public extern static void g_source_set_closure( GSource* source, GClosure* closure );

		public extern static void g_type_module_add_interface( GTypeModule* module, uintptr instanceType, uintptr interfaceType, GInterfaceInfo* interfaceInfo );
		[BackendHintReadNone]
		public extern static GType g_type_module_get_type();
		public extern static uintptr g_type_module_register_enum( GTypeModule* module, CUtf8String name, GEnumValue* constStaticValues );
		public extern static uintptr g_type_module_register_flags( GTypeModule* module, CUtf8String name, GFlagsValue* constStaticValues );
		public extern static uintptr g_type_module_register_type( GTypeModule* module, uintptr parentType, CUtf8String typeName, GTypeInfo* typeInfo, GTypeFlags flags );
		public extern static void g_type_module_set_name( GTypeModule* module, CUtf8String name );
		public extern static void g_type_module_unuse( GTypeModule* module );
		public extern static Boolean32 g_type_module_use( GTypeModule* module );

		public extern static void g_type_plugin_complete_interface_info( GTypePlugin* plugin, uintptr instanceType, uintptr interfaceType, GInterfaceInfo* info );
		public extern static void g_type_plugin_complete_type_info( GTypePlugin* plugin, uintptr gType, GTypeInfo* info, GTypeValueTable* valueTable );
		[BackendHintReadNone]
		public extern static GType g_type_plugin_get_type();
		public extern static void g_type_plugin_unuse( GTypePlugin* plugin );
		public extern static void g_type_plugin_use( GTypePlugin* plugin );

		public extern static GValueArray* g_value_array_append( GValueArray* valueArray, GValue* value );
		public extern static GValueArray* g_value_array_copy( GValueArray* valueArray );
		public extern static void g_value_array_free( GValueArray* valueArray );
		public extern static GValue* g_value_array_get_nth( GValueArray* valueArray, uint index_ );
		public extern static GValueArray* g_value_array_insert( GValueArray* valueArray, uint index_, GValue* value );
		public extern static GValueArray* g_value_array_new( uint nPrealloced );
		public extern static GValueArray* g_value_array_prepend( GValueArray* valueArray, GValue* value );
		public extern static GValueArray* g_value_array_remove( GValueArray* valueArray, uint index_ );
		public extern static GValueArray* g_value_array_sort( GValueArray* valueArray, Functors.Func<void*, void*, int> compareFunc );
		public extern static GValueArray* g_value_array_sort_with_data( GValueArray* valueArray, Functors.Func<void*, void*, void*, int> compareFunc, void* userData );

		public extern static GType g_gtype_get_type();
		public extern static uintptr g_pointer_type_register_static( CUtf8String name );
		public extern static sbyte* g_strdup_value_contents( GValue* value );
		public extern static sbyte* g_value_dup_string( GValue* value );
		public extern static Boolean32 g_value_get_boolean( GValue* value );
		public extern static sbyte g_value_get_char( GValue* value );
		public extern static double g_value_get_double( GValue* value );
		public extern static float g_value_get_float( GValue* value );
		public extern static GType g_value_get_gtype( GValue* value );
		public extern static int g_value_get_int( GValue* value );
		public extern static long g_value_get_int64( GValue* value );
		public extern static intptr g_value_get_long( GValue* value );
		public extern static void* g_value_get_pointer( GValue* value );
		public extern static CUtf8String g_value_get_string( GValue* value );
		public extern static byte g_value_get_uchar( GValue* value );
		public extern static uint g_value_get_uint( GValue* value );
		public extern static ulong g_value_get_uint64( GValue* value );
		public extern static uintptr g_value_get_ulong( GValue* value );
		public extern static void g_value_set_boolean( GValue* value, Boolean32 vBoolean );
		public extern static void g_value_set_char( GValue* value, sbyte vChar );
		public extern static void g_value_set_double( GValue* value, double vDouble );
		public extern static void g_value_set_float( GValue* value, float vFloat );
		public extern static void g_value_set_gtype( GValue* value, uintptr vGtype );
		public extern static void g_value_set_int( GValue* value, int vInt );
		public extern static void g_value_set_int64( GValue* value, long vInt64 );
		public extern static void g_value_set_long( GValue* value, intptr vLong );
		public extern static void g_value_set_pointer( GValue* value, void* vPointer );
		public extern static void g_value_set_static_string( GValue* value, CUtf8String vString );
		public extern static void g_value_set_string( GValue* value, CUtf8String vString );
		public extern static void g_value_set_string_take_ownership( GValue* value, CUtf8String vString );
		public extern static void g_value_set_uchar( GValue* value, byte vUchar );
		public extern static void g_value_set_uint( GValue* value, uint vUint );
		public extern static void g_value_set_uint64( GValue* value, ulong vUint64 );
		public extern static void g_value_set_ulong( GValue* value, uintptr vUlong );
		public extern static void g_value_take_string( GValue* value, CUtf8String vString );
	}
	[ExternLibrary( Image = "/usr/lib/libgmodule-2.0.so" )]
	public static partial struct GModuleApi {
		public extern static sbyte* g_module_build_path( sbyte* directory, CUtf8String moduleName );
		public extern static Boolean32 g_module_close( GModule* module );
		public extern static sbyte* g_module_error();
		public extern static void g_module_make_resident( GModule* module );
		public extern static sbyte* g_module_name( GModule* module );
		public extern static GModule* g_module_open( CUtf8String fileName, GModuleFlags flags );
		[BackendHintReadNone]
		public extern static Boolean32 g_module_supported();
		public extern static Boolean32 g_module_symbol( GModule* module, CUtf8String symbolName, void** symbol );
	}
	[ExternLibrary( Image = "/usr/lib/libgthread-2.0.so" )]
	public static partial struct GThreadApi {
		public extern static void g_thread_init( GThreadFunctions* vtable );
		public extern static void g_thread_init_with_errorcheck_mutexes( GThreadFunctions* vtable );
	}
	[Flags]
	public enum GAsciiType : uint {
		None =              0,
		G_ASCII_ALNUM =     1,
		G_ASCII_ALPHA =     2,
		G_ASCII_CNTRL =     4,
		G_ASCII_DIGIT =     8,
		G_ASCII_GRAPH =    16,
		G_ASCII_LOWER =    32,
		G_ASCII_PRINT =    64,
		G_ASCII_PUNCT =   128,
		G_ASCII_SPACE =   256,
		G_ASCII_UPPER =   512,
		G_ASCII_XDIGIT = 1024,
	}
	public enum GBookmarkFileError : uint {
		G_BOOKMARK_FILE_ERROR_INVALID_URI =        0,
		G_BOOKMARK_FILE_ERROR_INVALID_VALUE =      1,
		G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2,
		G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND =      3,
		G_BOOKMARK_FILE_ERROR_READ =               4,
		G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING =   5,
		G_BOOKMARK_FILE_ERROR_WRITE =              6,
		G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND =     7,
	}
	[Flags]
	public enum GConnectFlags : uint {
		None =              0,
		G_CONNECT_AFTER =   1,
		G_CONNECT_SWAPPED = 2,
	}
	public enum GConvertError : uint {
		G_CONVERT_ERROR_NO_CONVERSION =     0,
		G_CONVERT_ERROR_ILLEGAL_SEQUENCE =  1,
		G_CONVERT_ERROR_FAILED =            2,
		G_CONVERT_ERROR_PARTIAL_INPUT =     3,
		G_CONVERT_ERROR_BAD_URI =           4,
		G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5,
	}
	public enum GDateDMY : uint {
		G_DATE_DAY =   0,
		G_DATE_MONTH = 1,
		G_DATE_YEAR =  2,
	}
	public enum GDateMonth : uint {
		G_DATE_BAD_MONTH = 0,
		G_DATE_JANUARY =   1,
		G_DATE_FEBRUARY =  2,
		G_DATE_MARCH =     3,
		G_DATE_APRIL =     4,
		G_DATE_MAY =       5,
		G_DATE_JUNE =      6,
		G_DATE_JULY =      7,
		G_DATE_AUGUST =    8,
		G_DATE_SEPTEMBER = 9,
		G_DATE_OCTOBER =  10,
		G_DATE_NOVEMBER = 11,
		G_DATE_DECEMBER = 12,
	}
	public enum GDateWeekday : uint {
		G_DATE_BAD_WEEKDAY = 0,
		G_DATE_MONDAY =      1,
		G_DATE_TUESDAY =     2,
		G_DATE_WEDNESDAY =   3,
		G_DATE_THURSDAY =    4,
		G_DATE_FRIDAY =      5,
		G_DATE_SATURDAY =    6,
		G_DATE_SUNDAY =      7,
	}
	public enum GErrorType : uint {
		G_ERR_UNKNOWN =              0,
		G_ERR_UNEXP_EOF =            1,
		G_ERR_UNEXP_EOF_IN_STRING =  2,
		G_ERR_UNEXP_EOF_IN_COMMENT = 3,
		G_ERR_NON_DIGIT_IN_CONST =   4,
		G_ERR_DIGIT_RADIX =          5,
		G_ERR_FLOAT_RADIX =          6,
		G_ERR_FLOAT_MALFORMED =      7,
	}
	public enum GFileError : uint {
		G_FILE_ERROR_EXIST =       0,
		G_FILE_ERROR_ISDIR =       1,
		G_FILE_ERROR_ACCES =       2,
		G_FILE_ERROR_NAMETOOLONG = 3,
		G_FILE_ERROR_NOENT =       4,
		G_FILE_ERROR_NOTDIR =      5,
		G_FILE_ERROR_NXIO =        6,
		G_FILE_ERROR_NODEV =       7,
		G_FILE_ERROR_ROFS =        8,
		G_FILE_ERROR_TXTBSY =      9,
		G_FILE_ERROR_FAULT =      10,
		G_FILE_ERROR_LOOP =       11,
		G_FILE_ERROR_NOSPC =      12,
		G_FILE_ERROR_NOMEM =      13,
		G_FILE_ERROR_MFILE =      14,
		G_FILE_ERROR_NFILE =      15,
		G_FILE_ERROR_BADF =       16,
		G_FILE_ERROR_INVAL =      17,
		G_FILE_ERROR_PIPE =       18,
		G_FILE_ERROR_AGAIN =      19,
		G_FILE_ERROR_INTR =       20,
		G_FILE_ERROR_IO =         21,
		G_FILE_ERROR_PERM =       22,
		G_FILE_ERROR_NOSYS =      23,
		G_FILE_ERROR_FAILED =     24,
	}
	[Flags]
	public enum GFileTest : uint {
		None =                      0,
		G_FILE_TEST_IS_REGULAR =    1,
		G_FILE_TEST_IS_SYMLINK =    2,
		G_FILE_TEST_IS_DIR =        4,
		G_FILE_TEST_IS_EXECUTABLE = 8,
		G_FILE_TEST_EXISTS =       16,
	}
	public enum GHookFlagMask : uint {
		G_HOOK_FLAG_ACTIVE =  1,
		G_HOOK_FLAG_IN_CALL = 2,
		G_HOOK_FLAG_MASK =   15,
	}
	public enum GIOChannelError : uint {
		G_IO_CHANNEL_ERROR_FBIG =     0,
		G_IO_CHANNEL_ERROR_INVAL =    1,
		G_IO_CHANNEL_ERROR_IO =       2,
		G_IO_CHANNEL_ERROR_ISDIR =    3,
		G_IO_CHANNEL_ERROR_NOSPC =    4,
		G_IO_CHANNEL_ERROR_NXIO =     5,
		G_IO_CHANNEL_ERROR_OVERFLOW = 6,
		G_IO_CHANNEL_ERROR_PIPE =     7,
		G_IO_CHANNEL_ERROR_FAILED =   8,
	}
	[Flags]
	public enum GIOCondition : uint {
		None =       0,
		G_IO_IN =    1,
		G_IO_OUT =   4,
		G_IO_PRI =   2,
		G_IO_ERR =   8,
		G_IO_HUP =  16,
		G_IO_NVAL = 32,
	}
	public enum GIOError : uint {
		G_IO_ERROR_NONE =    0,
		G_IO_ERROR_AGAIN =   1,
		G_IO_ERROR_INVAL =   2,
		G_IO_ERROR_UNKNOWN = 3,
	}
	[Flags]
	public enum GIOFlags : uint {
		None =                   0,
		G_IO_FLAG_APPEND =       1,
		G_IO_FLAG_NONBLOCK =     2,
		G_IO_FLAG_IS_READABLE =  4,
		G_IO_FLAG_IS_WRITEABLE = 8,
		G_IO_FLAG_IS_SEEKABLE = 16,
		G_IO_FLAG_MASK =        31,
		G_IO_FLAG_GET_MASK =    31,
		G_IO_FLAG_SET_MASK =     3,
	}
	public enum GIOStatus : uint {
		G_IO_STATUS_ERROR =  0,
		G_IO_STATUS_NORMAL = 1,
		G_IO_STATUS_EOF =    2,
		G_IO_STATUS_AGAIN =  3,
	}
	public enum GKeyFileError : uint {
		G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0,
		G_KEY_FILE_ERROR_PARSE =            1,
		G_KEY_FILE_ERROR_NOT_FOUND =        2,
		G_KEY_FILE_ERROR_KEY_NOT_FOUND =    3,
		G_KEY_FILE_ERROR_GROUP_NOT_FOUND =  4,
		G_KEY_FILE_ERROR_INVALID_VALUE =    5,
	}
	[Flags]
	public enum GKeyFileFlags : uint {
		G_KEY_FILE_NONE =              0,
		G_KEY_FILE_KEEP_COMMENTS =     1,
		G_KEY_FILE_KEEP_TRANSLATIONS = 2,
	}
	public enum GlibTaskPriority : int {
		G_PRIORITY_HIGH =        -100,
		G_PRIORITY_DEFAULT =        0,
		G_PRIORITY_HIGH_IDLE =    100,
		G_PRIORITY_DEFAULT_IDLE = 200,
		G_PRIORITY_LOW =          300,
	}
	[Flags]
	public enum GLogLevelFlags : int {
		None =                 0,
		G_LOG_FLAG_RECURSION = 1,
		G_LOG_FLAG_FATAL =     2,
		G_LOG_LEVEL_ERROR =    4,
		G_LOG_LEVEL_CRITICAL = 8,
		G_LOG_LEVEL_WARNING = 16,
		G_LOG_LEVEL_MESSAGE = 32,
		G_LOG_LEVEL_INFO =    64,
		G_LOG_LEVEL_DEBUG =  128,
		G_LOG_LEVEL_MASK =    -4,
	}
	public enum GMarkupError : uint {
		G_MARKUP_ERROR_BAD_UTF8 =          0,
		G_MARKUP_ERROR_EMPTY =             1,
		G_MARKUP_ERROR_PARSE =             2,
		G_MARKUP_ERROR_UNKNOWN_ELEMENT =   3,
		G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4,
		G_MARKUP_ERROR_INVALID_CONTENT =   5,
	}
	[Flags]
	public enum GMarkupParseFlags : uint {
		None =                                      0,
		G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1,
		G_MARKUP_TREAT_CDATA_AS_TEXT =              2,
	}
	[Flags]
	public enum GModuleFlags : uint {
		None =                0,
		G_MODULE_BIND_LAZY =  1,
		G_MODULE_BIND_LOCAL = 2,
		G_MODULE_BIND_MASK =  3,
	}
	public enum GNormalizeMode : uint {
		G_NORMALIZE_DEFAULT =         0,
		G_NORMALIZE_NFD =             0,
		G_NORMALIZE_DEFAULT_COMPOSE = 1,
		G_NORMALIZE_NFC =             1,
		G_NORMALIZE_ALL =             2,
		G_NORMALIZE_NFKD =            2,
		G_NORMALIZE_ALL_COMPOSE =     3,
		G_NORMALIZE_NFKC =            3,
	}
	public enum GOnceStatus : uint {
		G_ONCE_STATUS_NOTCALLED = 0,
		G_ONCE_STATUS_PROGRESS =  1,
		G_ONCE_STATUS_READY =     2,
	}
	public enum GOptionArg : uint {
		G_OPTION_ARG_NONE =           0,
		G_OPTION_ARG_STRING =         1,
		G_OPTION_ARG_INT =            2,
		G_OPTION_ARG_CALLBACK =       3,
		G_OPTION_ARG_FILENAME =       4,
		G_OPTION_ARG_STRING_ARRAY =   5,
		G_OPTION_ARG_FILENAME_ARRAY = 6,
		G_OPTION_ARG_DOUBLE =         7,
		G_OPTION_ARG_INT64 =          8,
	}
	public enum GOptionError : uint {
		G_OPTION_ERROR_UNKNOWN_OPTION = 0,
		G_OPTION_ERROR_BAD_VALUE =      1,
		G_OPTION_ERROR_FAILED =         2,
	}
	[Flags]
	public enum GOptionFlags : uint {
		None =                        0,
		G_OPTION_FLAG_HIDDEN =        1,
		G_OPTION_FLAG_IN_MAIN =       2,
		G_OPTION_FLAG_REVERSE =       4,
		G_OPTION_FLAG_NO_ARG =        8,
		G_OPTION_FLAG_FILENAME =     16,
		G_OPTION_FLAG_OPTIONAL_ARG = 32,
		G_OPTION_FLAG_NOALIAS =      64,
	}
	[Flags]
	public enum GParamFlags : uint {
		None =                    0,
		G_PARAM_READABLE =        1,
		G_PARAM_WRITABLE =        2,
		G_PARAM_CONSTRUCT =       4,
		G_PARAM_CONSTRUCT_ONLY =  8,
		G_PARAM_LAX_VALIDATION = 16,
		G_PARAM_STATIC_NAME =    32,
		G_PARAM_PRIVATE =        32,
		G_PARAM_STATIC_NICK =    64,
		G_PARAM_STATIC_BLURB =  128,
	}
	[Flags]
	public enum GRegexCompileFlags : uint {
		None =                       0,
		G_REGEX_CASELESS =           1,
		G_REGEX_MULTILINE =          2,
		G_REGEX_DOTALL =             4,
		G_REGEX_EXTENDED =           8,
		G_REGEX_ANCHORED =          16,
		G_REGEX_DOLLAR_ENDONLY =    32,
		G_REGEX_UNGREEDY =         512,
		G_REGEX_RAW =             2048,
		G_REGEX_NO_AUTO_CAPTURE = 4096,
		G_REGEX_OPTIMIZE =        8192,
		G_REGEX_DUPNAMES =      524288,
		G_REGEX_NEWLINE_CR =   1048576,
		G_REGEX_NEWLINE_LF =   2097152,
		G_REGEX_NEWLINE_CRLF = 3145728,
	}
	public enum GRegexError : uint {
		G_REGEX_ERROR_COMPILE =  0,
		G_REGEX_ERROR_OPTIMIZE = 1,
		G_REGEX_ERROR_REPLACE =  2,
		G_REGEX_ERROR_MATCH =    3,
	}
	[Flags]
	public enum GRegexMatchFlags : uint {
		None =                             0,
		G_REGEX_MATCH_ANCHORED =          16,
		G_REGEX_MATCH_NOTBOL =           128,
		G_REGEX_MATCH_NOTEOL =           256,
		G_REGEX_MATCH_NOTEMPTY =        1024,
		G_REGEX_MATCH_PARTIAL =        32768,
		G_REGEX_MATCH_NEWLINE_CR =   1048576,
		G_REGEX_MATCH_NEWLINE_LF =   2097152,
		G_REGEX_MATCH_NEWLINE_CRLF = 3145728,
		G_REGEX_MATCH_NEWLINE_ANY =  4194304,
	}
	public enum GSeekType : uint {
		G_SEEK_CUR = 0,
		G_SEEK_SET = 1,
		G_SEEK_END = 2,
	}
	public enum GShellError : uint {
		G_SHELL_ERROR_BAD_QUOTING =  0,
		G_SHELL_ERROR_EMPTY_STRING = 1,
		G_SHELL_ERROR_FAILED =       2,
	}
	[Flags]
	public enum GSignalFlags : uint {
		None =                 0,
		G_SIGNAL_RUN_FIRST =   1,
		G_SIGNAL_RUN_LAST =    2,
		G_SIGNAL_RUN_CLEANUP = 4,
		G_SIGNAL_NO_RECURSE =  8,
		G_SIGNAL_DETAILED =   16,
		G_SIGNAL_ACTION =     32,
		G_SIGNAL_NO_HOOKS =   64,
	}
	[Flags]
	public enum GSignalMatchType : uint {
		None =                      0,
		G_SIGNAL_MATCH_ID =         1,
		G_SIGNAL_MATCH_DETAIL =     2,
		G_SIGNAL_MATCH_CLOSURE =    4,
		G_SIGNAL_MATCH_FUNC =       8,
		G_SIGNAL_MATCH_DATA =      16,
		G_SIGNAL_MATCH_UNBLOCKED = 32,
	}
	public enum GSliceConfig : uint {
		G_SLICE_CONFIG_ALWAYS_MALLOC =      1,
		G_SLICE_CONFIG_BYPASS_MAGAZINES =   2,
		G_SLICE_CONFIG_WORKING_SET_MSECS =  3,
		G_SLICE_CONFIG_COLOR_INCREMENT =    4,
		G_SLICE_CONFIG_CHUNK_SIZES =        5,
		G_SLICE_CONFIG_CONTENTION_COUNTER = 6,
	}
	public enum GSpawnError : uint {
		G_SPAWN_ERROR_FORK =        0,
		G_SPAWN_ERROR_READ =        1,
		G_SPAWN_ERROR_CHDIR =       2,
		G_SPAWN_ERROR_ACCES =       3,
		G_SPAWN_ERROR_PERM =        4,
		G_SPAWN_ERROR_2BIG =        5,
		G_SPAWN_ERROR_NOEXEC =      6,
		G_SPAWN_ERROR_NAMETOOLONG = 7,
		G_SPAWN_ERROR_NOENT =       8,
		G_SPAWN_ERROR_NOMEM =       9,
		G_SPAWN_ERROR_NOTDIR =     10,
		G_SPAWN_ERROR_LOOP =       11,
		G_SPAWN_ERROR_TXTBUSY =    12,
		G_SPAWN_ERROR_IO =         13,
		G_SPAWN_ERROR_NFILE =      14,
		G_SPAWN_ERROR_MFILE =      15,
		G_SPAWN_ERROR_INVAL =      16,
		G_SPAWN_ERROR_ISDIR =      17,
		G_SPAWN_ERROR_LIBBAD =     18,
		G_SPAWN_ERROR_FAILED =     19,
	}
	[Flags]
	public enum GSpawnFlags : uint {
		None =                           0,
		G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1,
		G_SPAWN_DO_NOT_REAP_CHILD =      2,
		G_SPAWN_SEARCH_PATH =            4,
		G_SPAWN_STDOUT_TO_DEV_NULL =     8,
		G_SPAWN_STDERR_TO_DEV_NULL =    16,
		G_SPAWN_CHILD_INHERITS_STDIN =  32,
		G_SPAWN_FILE_AND_ARGV_ZERO =    64,
	}
	public enum GTaskPriority : uint {
		G_PRIORITY_DEFAULT =        0,
		G_PRIORITY_HIGH_IDLE =    100,
		G_PRIORITY_DEFAULT_IDLE = 200,
		G_PRIORITY_LOW =          300,
		G_PRIORITY_HIGH =  4294967196,
	}
	public enum GThreadError : uint {
		G_THREAD_ERROR_AGAIN = 0,
	}
	public enum GThreadPriority : uint {
		G_THREAD_PRIORITY_LOW =    0,
		G_THREAD_PRIORITY_NORMAL = 1,
		G_THREAD_PRIORITY_HIGH =   2,
		G_THREAD_PRIORITY_URGENT = 3,
	}
	public enum GTokenType : uint {
		G_TOKEN_EOF =               0,
		G_TOKEN_LEFT_PAREN =       40,
		G_TOKEN_RIGHT_PAREN =      41,
		G_TOKEN_LEFT_CURLY =      123,
		G_TOKEN_RIGHT_CURLY =     125,
		G_TOKEN_LEFT_BRACE =       91,
		G_TOKEN_RIGHT_BRACE =      93,
		G_TOKEN_EQUAL_SIGN =       61,
		G_TOKEN_COMMA =            44,
		G_TOKEN_NONE =            256,
		G_TOKEN_ERROR =           257,
		G_TOKEN_CHAR =            258,
		G_TOKEN_BINARY =          259,
		G_TOKEN_OCTAL =           260,
		G_TOKEN_INT =             261,
		G_TOKEN_HEX =             262,
		G_TOKEN_FLOAT =           263,
		G_TOKEN_STRING =          264,
		G_TOKEN_SYMBOL =          265,
		G_TOKEN_IDENTIFIER =      266,
		G_TOKEN_IDENTIFIER_NULL = 267,
		G_TOKEN_COMMENT_SINGLE =  268,
		G_TOKEN_COMMENT_MULTI =   269,
		G_TOKEN_LAST =            270,
	}
	[Flags]
	public enum GTraverseFlags : uint {
		None =                  0,
		G_TRAVERSE_LEAVES =     1,
		G_TRAVERSE_NON_LEAVES = 2,
		G_TRAVERSE_ALL =        3,
		G_TRAVERSE_MASK =       3,
		G_TRAVERSE_LEAFS =      1,
		G_TRAVERSE_NON_LEAFS =  2,
	}
	public enum GTraverseType : uint {
		G_IN_ORDER =    0,
		G_PRE_ORDER =   1,
		G_POST_ORDER =  2,
		G_LEVEL_ORDER = 3,
	}
	public enum GType : uint {
		G_TYPE_INVALID =   0,
		G_TYPE_NONE =      4,
		G_TYPE_INTERFACE = 8,
		G_TYPE_CHAR =     12,
		G_TYPE_UCHAR =    16,
		G_TYPE_BOOLEAN =  20,
		G_TYPE_INT =      24,
		G_TYPE_UINT =     28,
		G_TYPE_LONG =     32,
		G_TYPE_ULONG =    36,
		G_TYPE_INT64 =    40,
		G_TYPE_UINT64 =   44,
		G_TYPE_ENUM =     48,
		G_TYPE_FLAGS =    52,
		G_TYPE_FLOAT =    56,
		G_TYPE_DOUBLE =   60,
		G_TYPE_STRING =   64,
		G_TYPE_POINTER =  68,
		G_TYPE_BOXED =    72,
		G_TYPE_PARAM =    76,
		G_TYPE_OBJECT =   80,
	}
	[Flags]
	public enum GTypeDebugFlags : uint {
		G_TYPE_DEBUG_NONE =    0,
		G_TYPE_DEBUG_OBJECTS = 1,
		G_TYPE_DEBUG_SIGNALS = 2,
		G_TYPE_DEBUG_MASK =    3,
	}
	[Flags]
	public enum GTypeFlags : uint {
		None =                        0,
		G_TYPE_FLAG_ABSTRACT =       16,
		G_TYPE_FLAG_VALUE_ABSTRACT = 32,
	}
	[Flags]
	public enum GTypeFundamentalFlags : uint {
		None =                       0,
		G_TYPE_FLAG_CLASSED =        1,
		G_TYPE_FLAG_INSTANTIATABLE = 2,
		G_TYPE_FLAG_DERIVABLE =      4,
		G_TYPE_FLAG_DEEP_DERIVABLE = 8,
	}
	public enum GUnicodeBreakType : uint {
		G_UNICODE_BREAK_MANDATORY =            0,
		G_UNICODE_BREAK_CARRIAGE_RETURN =      1,
		G_UNICODE_BREAK_LINE_FEED =            2,
		G_UNICODE_BREAK_COMBINING_MARK =       3,
		G_UNICODE_BREAK_SURROGATE =            4,
		G_UNICODE_BREAK_ZERO_WIDTH_SPACE =     5,
		G_UNICODE_BREAK_INSEPARABLE =          6,
		G_UNICODE_BREAK_NON_BREAKING_GLUE =    7,
		G_UNICODE_BREAK_CONTINGENT =           8,
		G_UNICODE_BREAK_SPACE =                9,
		G_UNICODE_BREAK_AFTER =               10,
		G_UNICODE_BREAK_BEFORE =              11,
		G_UNICODE_BREAK_BEFORE_AND_AFTER =    12,
		G_UNICODE_BREAK_HYPHEN =              13,
		G_UNICODE_BREAK_NON_STARTER =         14,
		G_UNICODE_BREAK_OPEN_PUNCTUATION =    15,
		G_UNICODE_BREAK_CLOSE_PUNCTUATION =   16,
		G_UNICODE_BREAK_QUOTATION =           17,
		G_UNICODE_BREAK_EXCLAMATION =         18,
		G_UNICODE_BREAK_IDEOGRAPHIC =         19,
		G_UNICODE_BREAK_NUMERIC =             20,
		G_UNICODE_BREAK_INFIX_SEPARATOR =     21,
		G_UNICODE_BREAK_SYMBOL =              22,
		G_UNICODE_BREAK_ALPHABETIC =          23,
		G_UNICODE_BREAK_PREFIX =              24,
		G_UNICODE_BREAK_POSTFIX =             25,
		G_UNICODE_BREAK_COMPLEX_CONTEXT =     26,
		G_UNICODE_BREAK_AMBIGUOUS =           27,
		G_UNICODE_BREAK_UNKNOWN =             28,
		G_UNICODE_BREAK_NEXT_LINE =           29,
		G_UNICODE_BREAK_WORD_JOINER =         30,
		G_UNICODE_BREAK_HANGUL_L_JAMO =       31,
		G_UNICODE_BREAK_HANGUL_V_JAMO =       32,
		G_UNICODE_BREAK_HANGUL_T_JAMO =       33,
		G_UNICODE_BREAK_HANGUL_LV_SYLLABLE =  34,
		G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35,
	}
	public enum GUnicodeScript : int {
		G_UNICODE_SCRIPT_INVALID_CODE =        -1,
		G_UNICODE_SCRIPT_COMMON =               0,
		G_UNICODE_SCRIPT_INHERITED =            1,
		G_UNICODE_SCRIPT_ARABIC =               2,
		G_UNICODE_SCRIPT_ARMENIAN =             3,
		G_UNICODE_SCRIPT_BENGALI =              4,
		G_UNICODE_SCRIPT_BOPOMOFO =             5,
		G_UNICODE_SCRIPT_CHEROKEE =             6,
		G_UNICODE_SCRIPT_COPTIC =               7,
		G_UNICODE_SCRIPT_CYRILLIC =             8,
		G_UNICODE_SCRIPT_DESERET =              9,
		G_UNICODE_SCRIPT_DEVANAGARI =          10,
		G_UNICODE_SCRIPT_ETHIOPIC =            11,
		G_UNICODE_SCRIPT_GEORGIAN =            12,
		G_UNICODE_SCRIPT_GOTHIC =              13,
		G_UNICODE_SCRIPT_GREEK =               14,
		G_UNICODE_SCRIPT_GUJARATI =            15,
		G_UNICODE_SCRIPT_GURMUKHI =            16,
		G_UNICODE_SCRIPT_HAN =                 17,
		G_UNICODE_SCRIPT_HANGUL =              18,
		G_UNICODE_SCRIPT_HEBREW =              19,
		G_UNICODE_SCRIPT_HIRAGANA =            20,
		G_UNICODE_SCRIPT_KANNADA =             21,
		G_UNICODE_SCRIPT_KATAKANA =            22,
		G_UNICODE_SCRIPT_KHMER =               23,
		G_UNICODE_SCRIPT_LAO =                 24,
		G_UNICODE_SCRIPT_LATIN =               25,
		G_UNICODE_SCRIPT_MALAYALAM =           26,
		G_UNICODE_SCRIPT_MONGOLIAN =           27,
		G_UNICODE_SCRIPT_MYANMAR =             28,
		G_UNICODE_SCRIPT_OGHAM =               29,
		G_UNICODE_SCRIPT_OLD_ITALIC =          30,
		G_UNICODE_SCRIPT_ORIYA =               31,
		G_UNICODE_SCRIPT_RUNIC =               32,
		G_UNICODE_SCRIPT_SINHALA =             33,
		G_UNICODE_SCRIPT_SYRIAC =              34,
		G_UNICODE_SCRIPT_TAMIL =               35,
		G_UNICODE_SCRIPT_TELUGU =              36,
		G_UNICODE_SCRIPT_THAANA =              37,
		G_UNICODE_SCRIPT_THAI =                38,
		G_UNICODE_SCRIPT_TIBETAN =             39,
		G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40,
		G_UNICODE_SCRIPT_YI =                  41,
		G_UNICODE_SCRIPT_TAGALOG =             42,
		G_UNICODE_SCRIPT_HANUNOO =             43,
		G_UNICODE_SCRIPT_BUHID =               44,
		G_UNICODE_SCRIPT_TAGBANWA =            45,
		G_UNICODE_SCRIPT_BRAILLE =             46,
		G_UNICODE_SCRIPT_CYPRIOT =             47,
		G_UNICODE_SCRIPT_LIMBU =               48,
		G_UNICODE_SCRIPT_OSMANYA =             49,
		G_UNICODE_SCRIPT_SHAVIAN =             50,
		G_UNICODE_SCRIPT_LINEAR_B =            51,
		G_UNICODE_SCRIPT_TAI_LE =              52,
		G_UNICODE_SCRIPT_UGARITIC =            53,
		G_UNICODE_SCRIPT_NEW_TAI_LUE =         54,
		G_UNICODE_SCRIPT_BUGINESE =            55,
		G_UNICODE_SCRIPT_GLAGOLITIC =          56,
		G_UNICODE_SCRIPT_TIFINAGH =            57,
		G_UNICODE_SCRIPT_SYLOTI_NAGRI =        58,
		G_UNICODE_SCRIPT_OLD_PERSIAN =         59,
		G_UNICODE_SCRIPT_KHAROSHTHI =          60,
		G_UNICODE_SCRIPT_UNKNOWN =             61,
		G_UNICODE_SCRIPT_BALINESE =            62,
		G_UNICODE_SCRIPT_CUNEIFORM =           63,
		G_UNICODE_SCRIPT_PHOENICIAN =          64,
		G_UNICODE_SCRIPT_PHAGS_PA =            65,
		G_UNICODE_SCRIPT_NKO =                 66,
	}
	public enum GUnicodeType : uint {
		G_UNICODE_CONTROL =              0,
		G_UNICODE_FORMAT =               1,
		G_UNICODE_UNASSIGNED =           2,
		G_UNICODE_PRIVATE_USE =          3,
		G_UNICODE_SURROGATE =            4,
		G_UNICODE_LOWERCASE_LETTER =     5,
		G_UNICODE_MODIFIER_LETTER =      6,
		G_UNICODE_OTHER_LETTER =         7,
		G_UNICODE_TITLECASE_LETTER =     8,
		G_UNICODE_UPPERCASE_LETTER =     9,
		G_UNICODE_COMBINING_MARK =      10,
		G_UNICODE_ENCLOSING_MARK =      11,
		G_UNICODE_NON_SPACING_MARK =    12,
		G_UNICODE_DECIMAL_NUMBER =      13,
		G_UNICODE_LETTER_NUMBER =       14,
		G_UNICODE_OTHER_NUMBER =        15,
		G_UNICODE_CONNECT_PUNCTUATION = 16,
		G_UNICODE_DASH_PUNCTUATION =    17,
		G_UNICODE_CLOSE_PUNCTUATION =   18,
		G_UNICODE_FINAL_PUNCTUATION =   19,
		G_UNICODE_INITIAL_PUNCTUATION = 20,
		G_UNICODE_OTHER_PUNCTUATION =   21,
		G_UNICODE_OPEN_PUNCTUATION =    22,
		G_UNICODE_CURRENCY_SYMBOL =     23,
		G_UNICODE_MODIFIER_SYMBOL =     24,
		G_UNICODE_MATH_SYMBOL =         25,
		G_UNICODE_OTHER_SYMBOL =        26,
		G_UNICODE_LINE_SEPARATOR =      27,
		G_UNICODE_PARAGRAPH_SEPARATOR = 28,
		G_UNICODE_SPACE_SEPARATOR =     29,
	}
	public enum GUserDirectory : uint {
		G_USER_DIRECTORY_DESKTOP =      0,
		G_USER_DIRECTORY_DOCUMENTS =    1,
		G_USER_DIRECTORY_DOWNLOAD =     2,
		G_USER_DIRECTORY_MUSIC =        3,
		G_USER_DIRECTORY_PICTURES =     4,
		G_USER_DIRECTORY_PUBLIC_SHARE = 5,
		G_USER_DIRECTORY_TEMPLATES =    6,
		G_USER_DIRECTORY_VIDEOS =       7,
		G_USER_N_DIRECTORIES =          8,
	}
	public partial struct GAllocator {
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GArray {
		[ExplicitOffset( Offset = 0 )]
		public sbyte* data;
		[ExplicitOffset( Offset = 4 )]
		public uint len;
	}
	public partial struct GAsyncQueue {
	}
	public partial struct GBookmarkFile {
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GByteArray {
		[ExplicitOffset( Offset = 0 )]
		public byte* data;
		[ExplicitOffset( Offset = 4 )]
		public uint len;
	}
	public partial struct GCache {
	}
	[ExplicitSize( Size = 20 )]
	[Alignment( Boundary = 4 )]
	public partial struct GCClosure {
		[ExplicitOffset( Offset = 0 )]
		public GClosure closure;
		[ExplicitOffset( Offset = 16 )]
		public void* callback;
	}
	[ExplicitSize( Size = 16 )]
	[Alignment( Boundary = 4 )]
	public partial struct GClosure {
		public uint ref_count { get { return cast<byte*>( &this )[0] | cast<ushort>( cast<byte*>( &this )[1] & 127 ) << 8; } set { cast<byte*>( &this )[0] = cast<byte>( value ); cast<byte*>( &this )[1] &= 128; cast<byte*>( &this )[1] |= cast<byte>( value >> 8 ) & 127; } }
		public bool meta_marshal { get { return ( cast<byte*>( &this )[1] & 128 ) != 0; } set { cast<byte*>( &this )[1] &= 127; cast<byte*>( &this )[1] |= cast<byte>( value ) << 7; } }
		public bool n_guards { get { return ( cast<byte*>( &this )[2] & 1 ) != 0; } set { cast<byte*>( &this )[2] &= 254; cast<byte*>( &this )[2] |= cast<byte>( value ) << 0; } }
		public uint n_fnotifiers { get { return cast<byte*>( &this )[2] >> 1 & 3; } set { cast<byte*>( &this )[2] &= 249; cast<byte*>( &this )[2] |= ( cast<byte>( value ) & 6 ) << 1; } }
		public uint n_inotifiers { get { return cast<byte*>( &this )[2] >> 3 | cast<ushort>( cast<byte*>( &this )[3] & 7 ) << 5; } set { cast<byte*>( &this )[2] &= 7; cast<byte*>( &this )[2] |= ( cast<byte>( value ) & 248 ) << 3; cast<byte*>( &this )[3] &= 248; cast<byte*>( &this )[3] |= cast<byte>( value >> 24 ) & 7; } }
		public bool in_inotify { get { return ( cast<byte*>( &this )[3] & 8 ) != 0; } set { cast<byte*>( &this )[3] &= 247; cast<byte*>( &this )[3] |= cast<byte>( value ) << 3; } }
		public bool floating { get { return ( cast<byte*>( &this )[3] & 16 ) != 0; } set { cast<byte*>( &this )[3] &= 239; cast<byte*>( &this )[3] |= cast<byte>( value ) << 4; } }
		public bool derivative_flag { get { return ( cast<byte*>( &this )[3] & 32 ) != 0; } set { cast<byte*>( &this )[3] &= 223; cast<byte*>( &this )[3] |= cast<byte>( value ) << 5; } }
		public bool in_marshal { get { return ( cast<byte*>( &this )[3] & 64 ) != 0; } set { cast<byte*>( &this )[3] &= 191; cast<byte*>( &this )[3] |= cast<byte>( value ) << 6; } }
		public bool is_invalid { get { return ( cast<byte*>( &this )[3] & 128 ) != 0; } set { cast<byte*>( &this )[3] &= 127; cast<byte*>( &this )[3] |= cast<byte>( value ) << 7; } }
		[ExplicitOffset( Offset = 4 )]
		public Functors.Action<GClosure*, GValue*, uint, GValue*, void*, void*> marshal;
		[ExplicitOffset( Offset = 8 )]
		public void* data;
		[ExplicitOffset( Offset = 12 )]
		public GClosureNotifyData* notifiers;
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GClosureNotifyData {
		[ExplicitOffset( Offset = 0 )]
		public void* data;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Action<void*, GClosure*> notify;
	}
	[ExplicitSize( Size = 20 )]
	[Alignment( Boundary = 4 )]
	public partial struct GCompletion {
		[ExplicitOffset( Offset = 0 )]
		public GList* items;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Func<void*, sbyte*> func;
		[ExplicitOffset( Offset = 8 )]
		public sbyte* prefix;
		[ExplicitOffset( Offset = 12 )]
		public GList* cache;
		[ExplicitOffset( Offset = 16 )]
		public Functors.Func<sbyte*, sbyte*, uint, int> strncmp_func;
	}
	public partial struct GCond {
	}
	public partial struct GData {
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GDate {
		public uint julian_days { get { return cast<byte*>( &this )[0] | cast<ushort>( cast<byte*>( &this )[1] ) << 8 | cast<uint>( cast<byte*>( &this )[2] ) << 16 | cast<uint>( cast<byte*>( &this )[3] ) << 24; } set { cast<byte*>( &this )[0] = cast<byte>( value ); cast<byte*>( &this )[1] = cast<byte>( value >> 8 ); cast<byte*>( &this )[2] = cast<byte>( value >> 16 ); cast<byte*>( &this )[3] = cast<byte>( value >> 24 ); } }
		public bool julian { get { return ( cast<byte*>( &this )[4] & 1 ) != 0; } set { cast<byte*>( &this )[4] &= 254; cast<byte*>( &this )[4] |= cast<byte>( value ) << 0; } }
		public bool dmy { get { return ( cast<byte*>( &this )[4] & 2 ) != 0; } set { cast<byte*>( &this )[4] &= 253; cast<byte*>( &this )[4] |= cast<byte>( value ) << 1; } }
		public uint day { get { return cast<byte*>( &this )[4] >> 2; } set { cast<byte*>( &this )[4] &= 3; cast<byte*>( &this )[4] |= ( cast<byte>( value ) & 252 ) << 2; } }
		public uint month { get { return cast<byte*>( &this )[5] & 15; } set { cast<byte*>( &this )[5] &= 240; cast<byte*>( &this )[5] |= ( cast<byte>( value ) & 15 ); } }
		public uint year { get { return cast<byte*>( &this )[5] >> 4 | cast<ushort>( cast<byte*>( &this )[6] ) << 4 | cast<uint>( cast<byte*>( &this )[7] & 15 ) << 12; } set { cast<byte*>( &this )[5] &= 15; cast<byte*>( &this )[5] |= ( cast<byte>( value ) & 240 ) << 4; cast<byte*>( &this )[6] = cast<byte>( value >> 4 ); cast<byte*>( &this )[7] &= 240; cast<byte*>( &this )[7] |= cast<byte>( value >> 56 ) & 15; } }
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GDebugKey {
		[ExplicitOffset( Offset = 0 )]
		public sbyte* key;
		[ExplicitOffset( Offset = 4 )]
		public uint value;
	}
	public partial struct GDir {
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GDoubleIEEE754 {
		[Overlapped( Offset = 0 )]
		public double v_double;
		[Overlapped( Offset = 0 )]
		public UnnamedStruct_F9006AC1 mpn;
	}
	[ExplicitSize( Size = 20 )]
	[Alignment( Boundary = 4 )]
	public partial struct GEnumClass {
		[ExplicitOffset( Offset = 0 )]
		public GTypeClass g_type_class;
		[ExplicitOffset( Offset = 4 )]
		public int minimum;
		[ExplicitOffset( Offset = 8 )]
		public int maximum;
		[ExplicitOffset( Offset = 12 )]
		public uint n_values;
		[ExplicitOffset( Offset = 16 )]
		public GEnumValue* values;
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GEnumValue {
		[ExplicitOffset( Offset = 0 )]
		public int value;
		[ExplicitOffset( Offset = 4 )]
		public CUtf8String value_name;
		[ExplicitOffset( Offset = 8 )]
		public sbyte* value_nick;
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GError {
		[ExplicitOffset( Offset = 0 )]
		public uint domain;
		[ExplicitOffset( Offset = 4 )]
		public int code;
		[ExplicitOffset( Offset = 8 )]
		public sbyte* message;
	}
	[ExplicitSize( Size = 16 )]
	[Alignment( Boundary = 4 )]
	public partial struct GFlagsClass {
		[ExplicitOffset( Offset = 0 )]
		public GTypeClass g_type_class;
		[ExplicitOffset( Offset = 4 )]
		public uint mask;
		[ExplicitOffset( Offset = 8 )]
		public uint n_values;
		[ExplicitOffset( Offset = 12 )]
		public GFlagsValue* values;
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GFlagsValue {
		[ExplicitOffset( Offset = 0 )]
		public uint value;
		[ExplicitOffset( Offset = 4 )]
		public CUtf8String value_name;
		[ExplicitOffset( Offset = 8 )]
		public sbyte* value_nick;
	}
	[ExplicitSize( Size = 4 )]
	[Alignment( Boundary = 4 )]
	public partial struct GFloatIEEE754 {
		[Overlapped( Offset = 0 )]
		public float v_float;
		[Overlapped( Offset = 0 )]
		public UnnamedStruct_F9006B26 mpn;
	}
	public partial struct GHashTable {
	}
	[ExplicitSize( Size = 32 )]
	[Alignment( Boundary = 4 )]
	public partial struct GHook {
		[ExplicitOffset( Offset = 0 )]
		public void* data;
		[ExplicitOffset( Offset = 4 )]
		public GHook* next;
		[ExplicitOffset( Offset = 8 )]
		public GHook* prev;
		[ExplicitOffset( Offset = 12 )]
		public uint ref_count;
		[ExplicitOffset( Offset = 16 )]
		public uintptr hook_id;
		[ExplicitOffset( Offset = 20 )]
		public uint flags;
		[ExplicitOffset( Offset = 24 )]
		public void* func;
		[ExplicitOffset( Offset = 28 )]
		public Functors.Action<void*> destroy;
	}
	[ExplicitSize( Size = 28 )]
	[Alignment( Boundary = 4 )]
	public partial struct GHookList {
		[ExplicitOffset( Offset = 0 )]
		public uintptr seq_id;
		public uint hook_size { get { return cast<byte*>( &this )[4] | cast<ushort>( cast<byte*>( &this )[5] ) << 8; } set { cast<byte*>( &this )[4] = cast<byte>( value ); cast<byte*>( &this )[5] = cast<byte>( value >> 8 ); } }
		public bool is_setup { get { return ( cast<byte*>( &this )[6] & 1 ) != 0; } set { cast<byte*>( &this )[6] &= 254; cast<byte*>( &this )[6] |= cast<byte>( value ) << 0; } }
		[ExplicitOffset( Offset = 8 )]
		public GHook* hooks;
		[ExplicitOffset( Offset = 12 )]
		public void* dummy3;
		[ExplicitOffset( Offset = 16 )]
		public Functors.Action<GHookList*, GHook*> finalize_hook;
		[ExplicitOffset( Offset = 20 )]
		public void*[2] dummy;
	}
	public partial struct GIConv {
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GInterfaceInfo {
		[ExplicitOffset( Offset = 0 )]
		public Functors.Action<void*, void*> interface_init;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Action<void*, void*> interface_finalize;
		[ExplicitOffset( Offset = 8 )]
		public void* interface_data;
	}
	[ExplicitSize( Size = 60 )]
	[Alignment( Boundary = 4 )]
	public partial struct GIOChannel {
		[ExplicitOffset( Offset = 0 )]
		public int ref_count;
		[ExplicitOffset( Offset = 4 )]
		public GIOFuncs* funcs;
		[ExplicitOffset( Offset = 8 )]
		public sbyte* encoding;
		[ExplicitOffset( Offset = 12 )]
		public GIConv* read_cd;
		[ExplicitOffset( Offset = 16 )]
		public GIConv* write_cd;
		[ExplicitOffset( Offset = 20 )]
		public sbyte* line_term;
		[ExplicitOffset( Offset = 24 )]
		public uint line_term_len;
		[ExplicitOffset( Offset = 28 )]
		public uint buf_size;
		[ExplicitOffset( Offset = 32 )]
		public GString* read_buf;
		[ExplicitOffset( Offset = 36 )]
		public GString* encoded_read_buf;
		[ExplicitOffset( Offset = 40 )]
		public GString* write_buf;
		[ExplicitOffset( Offset = 44 )]
		public sbyte[6] partial_write_buf;
		public bool use_buffer { get { return ( cast<byte*>( &this )[50] & 1 ) != 0; } set { cast<byte*>( &this )[50] &= 254; cast<byte*>( &this )[50] |= cast<byte>( value ) << 0; } }
		public bool do_encode { get { return ( cast<byte*>( &this )[50] & 2 ) != 0; } set { cast<byte*>( &this )[50] &= 253; cast<byte*>( &this )[50] |= cast<byte>( value ) << 1; } }
		public bool close_on_unref { get { return ( cast<byte*>( &this )[50] & 4 ) != 0; } set { cast<byte*>( &this )[50] &= 251; cast<byte*>( &this )[50] |= cast<byte>( value ) << 2; } }
		public bool is_readable { get { return ( cast<byte*>( &this )[50] & 8 ) != 0; } set { cast<byte*>( &this )[50] &= 247; cast<byte*>( &this )[50] |= cast<byte>( value ) << 3; } }
		public bool is_writeable { get { return ( cast<byte*>( &this )[50] & 16 ) != 0; } set { cast<byte*>( &this )[50] &= 239; cast<byte*>( &this )[50] |= cast<byte>( value ) << 4; } }
		public bool is_seekable { get { return ( cast<byte*>( &this )[50] & 32 ) != 0; } set { cast<byte*>( &this )[50] &= 223; cast<byte*>( &this )[50] |= cast<byte>( value ) << 5; } }
		[ExplicitOffset( Offset = 52 )]
		public void* reserved1;
		[ExplicitOffset( Offset = 56 )]
		public void* reserved2;
	}
	[ExplicitSize( Size = 32 )]
	[Alignment( Boundary = 4 )]
	public partial struct GIOFuncs {
		[ExplicitOffset( Offset = 0 )]
		public Functors.Func<GIOChannel*, sbyte*, uint, uint*, GError**, GIOStatus> io_read;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Func<GIOChannel*, sbyte*, uint, uint*, GError**, GIOStatus> io_write;
		[ExplicitOffset( Offset = 8 )]
		public Functors.Func<GIOChannel*, long, GSeekType, GError**, GIOStatus> io_seek;
		[ExplicitOffset( Offset = 12 )]
		public Functors.Func<GIOChannel*, GError**, GIOStatus> io_close;
		[ExplicitOffset( Offset = 16 )]
		public Functors.Func<GIOChannel*, GIOCondition, GSource*> io_create_watch;
		[ExplicitOffset( Offset = 20 )]
		public Functors.Action<GIOChannel*> io_free;
		[ExplicitOffset( Offset = 24 )]
		public Functors.Func<GIOChannel*, GIOFlags, GError**, GIOStatus> io_set_flags;
		[ExplicitOffset( Offset = 28 )]
		public Functors.Func<GIOChannel*, GIOFlags> io_get_flags;
	}
	public partial struct GKeyFile {
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GList {
		[ExplicitOffset( Offset = 0 )]
		public void* data;
		[ExplicitOffset( Offset = 4 )]
		public GList* next;
		[ExplicitOffset( Offset = 8 )]
		public GList* prev;
	}
	public partial struct GMainContext {
	}
	public partial struct GMainLoop {
	}
	public partial struct GMappedFile {
	}
	public partial struct GMarkupParseContext {
	}
	[ExplicitSize( Size = 20 )]
	[Alignment( Boundary = 4 )]
	public partial struct GMarkupParser {
		[ExplicitOffset( Offset = 0 )]
		public Functors.Action<GMarkupParseContext*, sbyte*, sbyte**, sbyte**, void*, GError**> start_element;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Action<GMarkupParseContext*, sbyte*, void*, GError**> end_element;
		[ExplicitOffset( Offset = 8 )]
		public Functors.Action<GMarkupParseContext*, sbyte*, uint, void*, GError**> text;
		[ExplicitOffset( Offset = 12 )]
		public Functors.Action<GMarkupParseContext*, sbyte*, uint, void*, GError**> passthrough;
		[ExplicitOffset( Offset = 16 )]
		public Functors.Action<GMarkupParseContext*, GError*, void*> error;
	}
	public partial struct GMatchInfo {
	}
	public partial struct GMemChunk {
	}
	[ExplicitSize( Size = 24 )]
	[Alignment( Boundary = 4 )]
	public partial struct GMemVTable {
		[ExplicitOffset( Offset = 0 )]
		public Functors.Func<uint, void*> malloc;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Func<void*, uint, void*> realloc;
		[ExplicitOffset( Offset = 8 )]
		public Functors.Action<void*> free;
		[ExplicitOffset( Offset = 12 )]
		public Functors.Func<uint, uint, void*> calloc;
		[ExplicitOffset( Offset = 16 )]
		public Functors.Func<uint, void*> try_malloc;
		[ExplicitOffset( Offset = 20 )]
		public Functors.Func<void*, uint, void*> try_realloc;
	}
	public partial struct GModule {
	}
	public partial struct GMutex {
	}
	[ExplicitSize( Size = 20 )]
	[Alignment( Boundary = 4 )]
	public partial struct GNode {
		[ExplicitOffset( Offset = 0 )]
		public void* data;
		[ExplicitOffset( Offset = 4 )]
		public GNode* next;
		[ExplicitOffset( Offset = 8 )]
		public GNode* prev;
		[ExplicitOffset( Offset = 12 )]
		public GNode* parent;
		[ExplicitOffset( Offset = 16 )]
		public GNode* children;
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GObject : GTypeInstance {
		[ExplicitSize( Size = 68 )]
		[Alignment( Boundary = 4 )]
		public new partial struct Class : GTypeClass {
			[ExplicitOffset( Offset = 4 )]
			public GSList* _construct_properties;
			[ExplicitOffset( Offset = 8 )]
			public Functors.Func<uintptr, uint, GObjectConstructParam*, GObject*> _constructor;
			[ExplicitOffset( Offset = 12 )]
			public Functors.Action<GObject*, uint, GValue*, GParamSpec*> _set_property;
			[ExplicitOffset( Offset = 16 )]
			public Functors.Action<GObject*, uint, GValue*, GParamSpec*> _get_property;
			[ExplicitOffset( Offset = 20 )]
			public Functors.Action<GObject*> _dispose;
			[ExplicitOffset( Offset = 24 )]
			public Functors.Action<GObject*> _finalize;
			[ExplicitOffset( Offset = 28 )]
			public Functors.Action<GObject*, uint, GParamSpec**> _dispatch_properties_changed;
			[ExplicitOffset( Offset = 32 )]
			public Functors.Action<GObject*, GParamSpec*> _notify;
			[ExplicitOffset( Offset = 36 )]
			public Functors.Action<GObject*> _constructed;
			[ExplicitOffset( Offset = 40 )]
			public void*[7] _pdummy;
		}
		[ExplicitOffset( Offset = 4 )]
		public uint _ref_count;
		[ExplicitOffset( Offset = 8 )]
		public GData* _qdata;
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GObjectConstructParam {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec* pspec;
		[ExplicitOffset( Offset = 4 )]
		public GValue* value;
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GOnce {
		[ExplicitOffset( Offset = 0 )]
		public GOnceStatus status;
		[ExplicitOffset( Offset = 4 )]
		public void* retval;
	}
	public partial struct GOptionContext {
	}
	[ExplicitSize( Size = 28 )]
	[Alignment( Boundary = 4 )]
	public partial struct GOptionEntry {
		[ExplicitOffset( Offset = 0 )]
		public CUtf8String long_name;
		[ExplicitOffset( Offset = 4 )]
		public sbyte short_name;
		[ExplicitOffset( Offset = 8 )]
		public int flags;
		[ExplicitOffset( Offset = 12 )]
		public GOptionArg arg;
		[ExplicitOffset( Offset = 16 )]
		public void* arg_data;
		[ExplicitOffset( Offset = 20 )]
		public CUtf8String description;
		[ExplicitOffset( Offset = 24 )]
		public CUtf8String arg_description;
	}
	public partial struct GOptionGroup {
	}
	[ExplicitSize( Size = 24 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParameter {
		[ExplicitOffset( Offset = 0 )]
		public CUtf8String name;
		[ExplicitOffset( Offset = 4 )]
		public GValue value;
	}
	[ExplicitSize( Size = 40 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpec {
		[ExplicitOffset( Offset = 0 )]
		public GTypeInstance g_type_instance;
		[ExplicitOffset( Offset = 4 )]
		public CUtf8String name;
		[ExplicitOffset( Offset = 8 )]
		public GParamFlags flags;
		[ExplicitOffset( Offset = 12 )]
		public uintptr value_type;
		[ExplicitOffset( Offset = 16 )]
		public uintptr owner_type;
		[ExplicitOffset( Offset = 20 )]
		public sbyte* _nick;
		[ExplicitOffset( Offset = 24 )]
		public sbyte* _blurb;
		[ExplicitOffset( Offset = 28 )]
		public GData* qdata;
		[ExplicitOffset( Offset = 32 )]
		public uint ref_count;
		[ExplicitOffset( Offset = 36 )]
		public uint param_id;
	}
	[ExplicitSize( Size = 44 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecBoolean {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public Boolean32 default_value;
	}
	[ExplicitSize( Size = 40 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecBoxed {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
	}
	[ExplicitSize( Size = 44 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecChar {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public sbyte minimum;
		[ExplicitOffset( Offset = 41 )]
		public sbyte maximum;
		[ExplicitOffset( Offset = 42 )]
		public sbyte default_value;
	}
	[ExplicitSize( Size = 40 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecClass {
		[ExplicitOffset( Offset = 0 )]
		public GTypeClass g_type_class;
		[ExplicitOffset( Offset = 4 )]
		public uintptr value_type;
		[ExplicitOffset( Offset = 8 )]
		public Functors.Action<GParamSpec*> finalize;
		[ExplicitOffset( Offset = 12 )]
		public Functors.Action<GParamSpec*, GValue*> value_set_default;
		[ExplicitOffset( Offset = 16 )]
		public Functors.Func<GParamSpec*, GValue*, Boolean32> value_validate;
		[ExplicitOffset( Offset = 20 )]
		public Functors.Func<GParamSpec*, GValue*, GValue*, int> values_cmp;
		[ExplicitOffset( Offset = 24 )]
		public void*[4] dummy;
	}
	[ExplicitSize( Size = 72 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecDouble {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public double minimum;
		[ExplicitOffset( Offset = 48 )]
		public double maximum;
		[ExplicitOffset( Offset = 56 )]
		public double default_value;
		[ExplicitOffset( Offset = 64 )]
		public double epsilon;
	}
	[ExplicitSize( Size = 48 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecEnum {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public GEnumClass* enum_class;
		[ExplicitOffset( Offset = 44 )]
		public int default_value;
	}
	[ExplicitSize( Size = 48 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecFlags {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public GFlagsClass* flags_class;
		[ExplicitOffset( Offset = 44 )]
		public uint default_value;
	}
	[ExplicitSize( Size = 56 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecFloat {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public float minimum;
		[ExplicitOffset( Offset = 44 )]
		public float maximum;
		[ExplicitOffset( Offset = 48 )]
		public float default_value;
		[ExplicitOffset( Offset = 52 )]
		public float epsilon;
	}
	[ExplicitSize( Size = 44 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecGType {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public uintptr is_a_type;
	}
	[ExplicitSize( Size = 52 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecInt {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public int minimum;
		[ExplicitOffset( Offset = 44 )]
		public int maximum;
		[ExplicitOffset( Offset = 48 )]
		public int default_value;
	}
	[ExplicitSize( Size = 64 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecInt64 {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public long minimum;
		[ExplicitOffset( Offset = 48 )]
		public long maximum;
		[ExplicitOffset( Offset = 56 )]
		public long default_value;
	}
	[ExplicitSize( Size = 52 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecLong {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public intptr minimum;
		[ExplicitOffset( Offset = 44 )]
		public intptr maximum;
		[ExplicitOffset( Offset = 48 )]
		public intptr default_value;
	}
	[ExplicitSize( Size = 40 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecObject {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
	}
	[ExplicitSize( Size = 44 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecOverride {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public GParamSpec* overridden;
	}
	[ExplicitSize( Size = 40 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecParam {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
	}
	[ExplicitSize( Size = 40 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecPointer {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
	}
	public partial struct GParamSpecPool {
	}
	[ExplicitSize( Size = 56 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecString {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public sbyte* default_value;
		[ExplicitOffset( Offset = 44 )]
		public sbyte* cset_first;
		[ExplicitOffset( Offset = 48 )]
		public sbyte* cset_nth;
		[ExplicitOffset( Offset = 52 )]
		public sbyte substitutor;
		public bool null_fold_if_empty { get { return ( cast<byte*>( &this )[53] & 1 ) != 0; } set { cast<byte*>( &this )[53] &= 254; cast<byte*>( &this )[53] |= cast<byte>( value ) << 0; } }
		public bool ensure_non_null { get { return ( cast<byte*>( &this )[53] & 2 ) != 0; } set { cast<byte*>( &this )[53] &= 253; cast<byte*>( &this )[53] |= cast<byte>( value ) << 1; } }
	}
	[ExplicitSize( Size = 28 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecTypeInfo {
		[ExplicitOffset( Offset = 0 )]
		public ushort instance_size;
		[ExplicitOffset( Offset = 2 )]
		public ushort n_preallocs;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Action<GParamSpec*> instance_init;
		[ExplicitOffset( Offset = 8 )]
		public uintptr value_type;
		[ExplicitOffset( Offset = 12 )]
		public Functors.Action<GParamSpec*> finalize;
		[ExplicitOffset( Offset = 16 )]
		public Functors.Action<GParamSpec*, GValue*> value_set_default;
		[ExplicitOffset( Offset = 20 )]
		public Functors.Func<GParamSpec*, GValue*, Boolean32> value_validate;
		[ExplicitOffset( Offset = 24 )]
		public Functors.Func<GParamSpec*, GValue*, GValue*, int> values_cmp;
	}
	[ExplicitSize( Size = 44 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecUChar {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public byte minimum;
		[ExplicitOffset( Offset = 41 )]
		public byte maximum;
		[ExplicitOffset( Offset = 42 )]
		public byte default_value;
	}
	[ExplicitSize( Size = 52 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecUInt {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public uint minimum;
		[ExplicitOffset( Offset = 44 )]
		public uint maximum;
		[ExplicitOffset( Offset = 48 )]
		public uint default_value;
	}
	[ExplicitSize( Size = 64 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecUInt64 {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public ulong minimum;
		[ExplicitOffset( Offset = 48 )]
		public ulong maximum;
		[ExplicitOffset( Offset = 56 )]
		public ulong default_value;
	}
	[ExplicitSize( Size = 52 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecULong {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public uintptr minimum;
		[ExplicitOffset( Offset = 44 )]
		public uintptr maximum;
		[ExplicitOffset( Offset = 48 )]
		public uintptr default_value;
	}
	[ExplicitSize( Size = 44 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecUnichar {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public uint default_value;
	}
	[ExplicitSize( Size = 48 )]
	[Alignment( Boundary = 4 )]
	public partial struct GParamSpecValueArray {
		[ExplicitOffset( Offset = 0 )]
		public GParamSpec parent_instance;
		[ExplicitOffset( Offset = 40 )]
		public GParamSpec* element_spec;
		[ExplicitOffset( Offset = 44 )]
		public uint fixed_n_elements;
	}
	public partial struct GPatternSpec {
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GPollFD {
		[ExplicitOffset( Offset = 0 )]
		public int fd;
		[ExplicitOffset( Offset = 4 )]
		public ushort events;
		[ExplicitOffset( Offset = 6 )]
		public ushort revents;
	}
	public partial struct GPrivate {
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GPtrArray {
		[ExplicitOffset( Offset = 0 )]
		public void** pdata;
		[ExplicitOffset( Offset = 4 )]
		public uint len;
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GQueue {
		[ExplicitOffset( Offset = 0 )]
		public GList* head;
		[ExplicitOffset( Offset = 4 )]
		public GList* tail;
		[ExplicitOffset( Offset = 8 )]
		public uint length;
	}
	public partial struct GRand {
	}
	public partial struct GRegex {
	}
	public partial struct GRelation {
	}
	[ExplicitSize( Size = 92 )]
	[Alignment( Boundary = 4 )]
	public partial struct GScanner {
		[ExplicitOffset( Offset = 0 )]
		public void* user_data;
		[ExplicitOffset( Offset = 4 )]
		public uint max_parse_errors;
		[ExplicitOffset( Offset = 8 )]
		public uint parse_errors;
		[ExplicitOffset( Offset = 12 )]
		public CUtf8String input_name;
		[ExplicitOffset( Offset = 16 )]
		public GData* qdata;
		[ExplicitOffset( Offset = 20 )]
		public GScannerConfig* config;
		[ExplicitOffset( Offset = 24 )]
		public GTokenType token;
		[ExplicitOffset( Offset = 28 )]
		public GTokenValue value;
		[ExplicitOffset( Offset = 36 )]
		public uint line;
		[ExplicitOffset( Offset = 40 )]
		public uint position;
		[ExplicitOffset( Offset = 44 )]
		public GTokenType next_token;
		[ExplicitOffset( Offset = 48 )]
		public GTokenValue next_value;
		[ExplicitOffset( Offset = 56 )]
		public uint next_line;
		[ExplicitOffset( Offset = 60 )]
		public uint next_position;
		[ExplicitOffset( Offset = 64 )]
		public GHashTable* symbol_table;
		[ExplicitOffset( Offset = 68 )]
		public int input_fd;
		[ExplicitOffset( Offset = 72 )]
		public CUtf8String text;
		[ExplicitOffset( Offset = 76 )]
		public CUtf8String text_end;
		[ExplicitOffset( Offset = 80 )]
		public sbyte* buffer;
		[ExplicitOffset( Offset = 84 )]
		public uint scope_id;
		[ExplicitOffset( Offset = 88 )]
		public Functors.Action<GScanner*, sbyte*, Boolean32> msg_handler;
	}
	[ExplicitSize( Size = 24 )]
	[Alignment( Boundary = 4 )]
	public partial struct GScannerConfig {
		[ExplicitOffset( Offset = 0 )]
		public sbyte* cset_skip_characters;
		[ExplicitOffset( Offset = 4 )]
		public sbyte* cset_identifier_first;
		[ExplicitOffset( Offset = 8 )]
		public sbyte* cset_identifier_nth;
		[ExplicitOffset( Offset = 12 )]
		public CUtf8String cpair_comment_single;
		public bool case_sensitive { get { return ( cast<byte*>( &this )[16] & 1 ) != 0; } set { cast<byte*>( &this )[16] &= 254; cast<byte*>( &this )[16] |= cast<byte>( value ) << 0; } }
		public bool skip_comment_multi { get { return ( cast<byte*>( &this )[16] & 2 ) != 0; } set { cast<byte*>( &this )[16] &= 253; cast<byte*>( &this )[16] |= cast<byte>( value ) << 1; } }
		public bool skip_comment_single { get { return ( cast<byte*>( &this )[16] & 4 ) != 0; } set { cast<byte*>( &this )[16] &= 251; cast<byte*>( &this )[16] |= cast<byte>( value ) << 2; } }
		public bool scan_comment_multi { get { return ( cast<byte*>( &this )[16] & 8 ) != 0; } set { cast<byte*>( &this )[16] &= 247; cast<byte*>( &this )[16] |= cast<byte>( value ) << 3; } }
		public bool scan_identifier { get { return ( cast<byte*>( &this )[16] & 16 ) != 0; } set { cast<byte*>( &this )[16] &= 239; cast<byte*>( &this )[16] |= cast<byte>( value ) << 4; } }
		public bool scan_identifier_1char { get { return ( cast<byte*>( &this )[16] & 32 ) != 0; } set { cast<byte*>( &this )[16] &= 223; cast<byte*>( &this )[16] |= cast<byte>( value ) << 5; } }
		public bool scan_identifier_NULL { get { return ( cast<byte*>( &this )[16] & 64 ) != 0; } set { cast<byte*>( &this )[16] &= 191; cast<byte*>( &this )[16] |= cast<byte>( value ) << 6; } }
		public bool scan_symbols { get { return ( cast<byte*>( &this )[16] & 128 ) != 0; } set { cast<byte*>( &this )[16] &= 127; cast<byte*>( &this )[16] |= cast<byte>( value ) << 7; } }
		public bool scan_binary { get { return ( cast<byte*>( &this )[17] & 1 ) != 0; } set { cast<byte*>( &this )[17] &= 254; cast<byte*>( &this )[17] |= cast<byte>( value ) << 0; } }
		public bool scan_octal { get { return ( cast<byte*>( &this )[17] & 2 ) != 0; } set { cast<byte*>( &this )[17] &= 253; cast<byte*>( &this )[17] |= cast<byte>( value ) << 1; } }
		public bool scan_float { get { return ( cast<byte*>( &this )[17] & 4 ) != 0; } set { cast<byte*>( &this )[17] &= 251; cast<byte*>( &this )[17] |= cast<byte>( value ) << 2; } }
		public bool scan_hex { get { return ( cast<byte*>( &this )[17] & 8 ) != 0; } set { cast<byte*>( &this )[17] &= 247; cast<byte*>( &this )[17] |= cast<byte>( value ) << 3; } }
		public bool scan_hex_dollar { get { return ( cast<byte*>( &this )[17] & 16 ) != 0; } set { cast<byte*>( &this )[17] &= 239; cast<byte*>( &this )[17] |= cast<byte>( value ) << 4; } }
		public bool scan_string_sq { get { return ( cast<byte*>( &this )[17] & 32 ) != 0; } set { cast<byte*>( &this )[17] &= 223; cast<byte*>( &this )[17] |= cast<byte>( value ) << 5; } }
		public bool scan_string_dq { get { return ( cast<byte*>( &this )[17] & 64 ) != 0; } set { cast<byte*>( &this )[17] &= 191; cast<byte*>( &this )[17] |= cast<byte>( value ) << 6; } }
		public bool numbers_2_int { get { return ( cast<byte*>( &this )[17] & 128 ) != 0; } set { cast<byte*>( &this )[17] &= 127; cast<byte*>( &this )[17] |= cast<byte>( value ) << 7; } }
		public bool int_2_float { get { return ( cast<byte*>( &this )[18] & 1 ) != 0; } set { cast<byte*>( &this )[18] &= 254; cast<byte*>( &this )[18] |= cast<byte>( value ) << 0; } }
		public bool identifier_2_string { get { return ( cast<byte*>( &this )[18] & 2 ) != 0; } set { cast<byte*>( &this )[18] &= 253; cast<byte*>( &this )[18] |= cast<byte>( value ) << 1; } }
		public bool char_2_token { get { return ( cast<byte*>( &this )[18] & 4 ) != 0; } set { cast<byte*>( &this )[18] &= 251; cast<byte*>( &this )[18] |= cast<byte>( value ) << 2; } }
		public bool symbol_2_token { get { return ( cast<byte*>( &this )[18] & 8 ) != 0; } set { cast<byte*>( &this )[18] &= 247; cast<byte*>( &this )[18] |= cast<byte>( value ) << 3; } }
		public bool scope_0_fallback { get { return ( cast<byte*>( &this )[18] & 16 ) != 0; } set { cast<byte*>( &this )[18] &= 239; cast<byte*>( &this )[18] |= cast<byte>( value ) << 4; } }
		public bool store_int64 { get { return ( cast<byte*>( &this )[18] & 32 ) != 0; } set { cast<byte*>( &this )[18] &= 223; cast<byte*>( &this )[18] |= cast<byte>( value ) << 5; } }
		[ExplicitOffset( Offset = 20 )]
		public uint padding_dummy;
	}
	public partial struct GSequence {
	}
	public partial struct GSequenceIter {
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GSignalInvocationHint {
		[ExplicitOffset( Offset = 0 )]
		public uint signal_id;
		[ExplicitOffset( Offset = 4 )]
		public uint detail;
		[ExplicitOffset( Offset = 8 )]
		public GSignalFlags run_type;
	}
	[ExplicitSize( Size = 28 )]
	[Alignment( Boundary = 4 )]
	public partial struct GSignalQuery {
		[ExplicitOffset( Offset = 0 )]
		public uint signal_id;
		[ExplicitOffset( Offset = 4 )]
		public CUtf8String signal_name;
		[ExplicitOffset( Offset = 8 )]
		public uintptr itype;
		[ExplicitOffset( Offset = 12 )]
		public GSignalFlags signal_flags;
		[ExplicitOffset( Offset = 16 )]
		public uintptr return_type;
		[ExplicitOffset( Offset = 20 )]
		public uint n_params;
		[ExplicitOffset( Offset = 24 )]
		public uintptr* param_types;
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GSList {
		[ExplicitOffset( Offset = 0 )]
		public void* data;
		[ExplicitOffset( Offset = 4 )]
		public GSList* next;
	}
	[ExplicitSize( Size = 52 )]
	[Alignment( Boundary = 4 )]
	public partial struct GSource {
		[ExplicitOffset( Offset = 0 )]
		public void* callback_data;
		[ExplicitOffset( Offset = 4 )]
		public GSourceCallbackFuncs* callback_funcs;
		[ExplicitOffset( Offset = 8 )]
		public GSourceFuncs* source_funcs;
		[ExplicitOffset( Offset = 12 )]
		public uint ref_count;
		[ExplicitOffset( Offset = 16 )]
		public GMainContext* context;
		[ExplicitOffset( Offset = 20 )]
		public int priority;
		[ExplicitOffset( Offset = 24 )]
		public uint flags;
		[ExplicitOffset( Offset = 28 )]
		public uint source_id;
		[ExplicitOffset( Offset = 32 )]
		public GSList* poll_fds;
		[ExplicitOffset( Offset = 36 )]
		public GSource* prev;
		[ExplicitOffset( Offset = 40 )]
		public GSource* next;
		[ExplicitOffset( Offset = 44 )]
		public void* reserved1;
		[ExplicitOffset( Offset = 48 )]
		public void* reserved2;
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GSourceCallbackFuncs {
		[ExplicitOffset( Offset = 0 )]
		public Functors.Action<void*> ref;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Action<void*> unref;
		[ExplicitOffset( Offset = 8 )]
		public Functors.Action<void*, GSource*, Functors.Func<void*, Boolean32>*, void**> get;
	}
	[ExplicitSize( Size = 24 )]
	[Alignment( Boundary = 4 )]
	public partial struct GSourceFuncs {
		[ExplicitOffset( Offset = 0 )]
		public Functors.Func<GSource*, int*, Boolean32> prepare;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Func<GSource*, Boolean32> check;
		[ExplicitOffset( Offset = 8 )]
		public Functors.Func<GSource*, Functors.Func<void*, Boolean32>, void*, Boolean32> dispatch;
		[ExplicitOffset( Offset = 12 )]
		public Functors.Action<GSource*> finalize;
		[ExplicitOffset( Offset = 16 )]
		public Functors.Func<void*, Boolean32> closure_callback;
		[ExplicitOffset( Offset = 20 )]
		public Functors.Action closure_marshal;
	}
	[ExplicitSize( Size = 28 )]
	[Alignment( Boundary = 4 )]
	public partial struct GStaticMutex {
		[ExplicitOffset( Offset = 0 )]
		public GMutex* runtime_mutex;
		[ExplicitOffset( Offset = 4 )]
		public UnnamedUnion_3D8E5D70 static_mutex;
	}
	[ExplicitSize( Size = 4 )]
	[Alignment( Boundary = 4 )]
	public partial struct GStaticPrivate {
		[ExplicitOffset( Offset = 0 )]
		public uint index;
	}
	[ExplicitSize( Size = 40 )]
	[Alignment( Boundary = 4 )]
	public partial struct GStaticRecMutex {
		[ExplicitOffset( Offset = 0 )]
		public GStaticMutex mutex;
		[ExplicitOffset( Offset = 28 )]
		public uint depth;
		[ExplicitOffset( Offset = 32 )]
		public GSystemThread owner;
	}
	[ExplicitSize( Size = 52 )]
	[Alignment( Boundary = 4 )]
	public partial struct GStaticRWLock {
		[ExplicitOffset( Offset = 0 )]
		public GStaticMutex mutex;
		[ExplicitOffset( Offset = 28 )]
		public GCond* read_cond;
		[ExplicitOffset( Offset = 32 )]
		public GCond* write_cond;
		[ExplicitOffset( Offset = 36 )]
		public uint read_counter;
		[ExplicitOffset( Offset = 40 )]
		public Boolean32 have_writer;
		[ExplicitOffset( Offset = 44 )]
		public uint want_to_read;
		[ExplicitOffset( Offset = 48 )]
		public uint want_to_write;
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GString {
		[ExplicitOffset( Offset = 0 )]
		public sbyte* str;
		[ExplicitOffset( Offset = 4 )]
		public uint len;
		[ExplicitOffset( Offset = 8 )]
		public uint allocated_len;
	}
	public partial struct GStringChunk {
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GSystemThread {
		[Overlapped( Offset = 0 )]
		public sbyte[4] data;
		[Overlapped( Offset = 0 )]
		public double dummy_double;
		[Overlapped( Offset = 0 )]
		public void* dummy_pointer;
		[Overlapped( Offset = 0 )]
		public intptr dummy_long;
	}
	[ExplicitSize( Size = 16 )]
	[Alignment( Boundary = 4 )]
	public partial struct GThread {
		[ExplicitOffset( Offset = 0 )]
		public Functors.Func<void*, void*> func;
		[ExplicitOffset( Offset = 4 )]
		public void* data;
		[ExplicitOffset( Offset = 8 )]
		public Boolean32 joinable;
		[ExplicitOffset( Offset = 12 )]
		public GThreadPriority priority;
	}
	[ExplicitSize( Size = 84 )]
	[Alignment( Boundary = 4 )]
	public partial struct GThreadFunctions {
		[ExplicitOffset( Offset = 0 )]
		public Functors.Func<GMutex*> mutex_new;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Action<GMutex*> mutex_lock;
		[ExplicitOffset( Offset = 8 )]
		public Functors.Func<GMutex*, Boolean32> mutex_trylock;
		[ExplicitOffset( Offset = 12 )]
		public Functors.Action<GMutex*> mutex_unlock;
		[ExplicitOffset( Offset = 16 )]
		public Functors.Action<GMutex*> mutex_free;
		[ExplicitOffset( Offset = 20 )]
		public Functors.Func<GCond*> cond_new;
		[ExplicitOffset( Offset = 24 )]
		public Functors.Action<GCond*> cond_signal;
		[ExplicitOffset( Offset = 28 )]
		public Functors.Action<GCond*> cond_broadcast;
		[ExplicitOffset( Offset = 32 )]
		public Functors.Action<GCond*, GMutex*> cond_wait;
		[ExplicitOffset( Offset = 36 )]
		public Functors.Func<GCond*, GMutex*, GTimeVal*, Boolean32> cond_timed_wait;
		[ExplicitOffset( Offset = 40 )]
		public Functors.Action<GCond*> cond_free;
		[ExplicitOffset( Offset = 44 )]
		public Functors.Func<Functors.Action<void*>, GPrivate*> private_new;
		[ExplicitOffset( Offset = 48 )]
		public Functors.Func<GPrivate*, void*> private_get;
		[ExplicitOffset( Offset = 52 )]
		public Functors.Action<GPrivate*, void*> private_set;
		[ExplicitOffset( Offset = 56 )]
		public Functors.Action<Functors.Func<void*, void*>, void*, uintptr, Boolean32, Boolean32, GThreadPriority, void*, GError**> thread_create;
		[ExplicitOffset( Offset = 60 )]
		public Functors.Action thread_yield;
		[ExplicitOffset( Offset = 64 )]
		public Functors.Action<void*> thread_join;
		[ExplicitOffset( Offset = 68 )]
		public Functors.Action thread_exit;
		[ExplicitOffset( Offset = 72 )]
		public Functors.Action<void*, GThreadPriority> thread_set_priority;
		[ExplicitOffset( Offset = 76 )]
		public Functors.Action<void*> thread_self;
		[ExplicitOffset( Offset = 80 )]
		public Functors.Func<void*, void*, Boolean32> thread_equal;
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GThreadPool {
		[ExplicitOffset( Offset = 0 )]
		public Functors.Action<void*, void*> func;
		[ExplicitOffset( Offset = 4 )]
		public void* user_data;
		[ExplicitOffset( Offset = 8 )]
		public Boolean32 exclusive;
	}
	public partial struct GTimer {
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTimeVal {
		[ExplicitOffset( Offset = 0 )]
		public intptr tv_sec;
		[ExplicitOffset( Offset = 4 )]
		public intptr tv_usec;
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTokenValue {
		[Overlapped( Offset = 0 )]
		public void* v_symbol;
		[Overlapped( Offset = 0 )]
		public sbyte* v_identifier;
		[Overlapped( Offset = 0 )]
		public uintptr v_binary;
		[Overlapped( Offset = 0 )]
		public uintptr v_octal;
		[Overlapped( Offset = 0 )]
		public uintptr v_int;
		[Overlapped( Offset = 0 )]
		public ulong v_int64;
		[Overlapped( Offset = 0 )]
		public double v_float;
		[Overlapped( Offset = 0 )]
		public uintptr v_hex;
		[Overlapped( Offset = 0 )]
		public sbyte* v_string;
		[Overlapped( Offset = 0 )]
		public sbyte* v_comment;
		[Overlapped( Offset = 0 )]
		public byte v_char;
		[Overlapped( Offset = 0 )]
		public uint v_error;
	}
	[ExplicitSize( Size = 4 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTrashStack {
		[ExplicitOffset( Offset = 0 )]
		public GTrashStack* next;
	}
	public partial struct GTree {
	}
	[ExplicitSize( Size = 4 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTuples {
		[ExplicitOffset( Offset = 0 )]
		public uint len;
	}
	[ExplicitSize( Size = 4 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTypeClass {
		[ExplicitOffset( Offset = 0 )]
		public uintptr g_type;
	}
	public partial struct GTypeCValue {
	}
	[ExplicitSize( Size = 4 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTypeFundamentalInfo {
		[ExplicitOffset( Offset = 0 )]
		public GTypeFundamentalFlags type_flags;
	}
	[ExplicitSize( Size = 36 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTypeInfo {
		[ExplicitOffset( Offset = 0 )]
		public ushort class_size;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Action<void*> base_init;
		[ExplicitOffset( Offset = 8 )]
		public Functors.Action<void*> base_finalize;
		[ExplicitOffset( Offset = 12 )]
		public Functors.Action<void*, void*> class_init;
		[ExplicitOffset( Offset = 16 )]
		public Functors.Action<void*, void*> class_finalize;
		[ExplicitOffset( Offset = 20 )]
		public void* class_data;
		[ExplicitOffset( Offset = 24 )]
		public ushort instance_size;
		[ExplicitOffset( Offset = 26 )]
		public ushort n_preallocs;
		[ExplicitOffset( Offset = 28 )]
		public Functors.Action<GTypeInstance*, void*> instance_init;
		[ExplicitOffset( Offset = 32 )]
		public GTypeValueTable* value_table;
	}
	[ExplicitSize( Size = 4 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTypeInstance {
		[ExplicitOffset( Offset = 0 )]
		public GTypeClass* g_class;
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTypeInterface {
		[ExplicitOffset( Offset = 0 )]
		public uintptr g_type;
		[ExplicitOffset( Offset = 4 )]
		public uintptr g_instance_type;
	}
	[ExplicitSize( Size = 28 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTypeModule : GObject {
		[ExplicitSize( Size = 92 )]
		[Alignment( Boundary = 4 )]
		public new partial struct Class : basetype.Class {
			[ExplicitOffset( Offset = 68 )]
			public Functors.Func<GTypeModule*, Boolean32> _load;
			[ExplicitOffset( Offset = 72 )]
			public Functors.Action<GTypeModule*> _unload;
			[ExplicitOffset( Offset = 76 )]
			public Functors.Action _reserved1;
			[ExplicitOffset( Offset = 80 )]
			public Functors.Action _reserved2;
			[ExplicitOffset( Offset = 84 )]
			public Functors.Action _reserved3;
			[ExplicitOffset( Offset = 88 )]
			public Functors.Action _reserved4;
		}
		[ExplicitOffset( Offset = 12 )]
		public uint _use_count;
		[ExplicitOffset( Offset = 16 )]
		public GSList* _type_infos;
		[ExplicitOffset( Offset = 20 )]
		public GSList* _interface_infos;
		[ExplicitOffset( Offset = 24 )]
		public CUtf8String _name;
	}
	public partial struct GTypePlugin {
	}
	[ExplicitSize( Size = 24 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTypePluginClass : GTypeInterface {
		[ExplicitOffset( Offset = 8 )]
		public Functors.Action<GTypePlugin*> use_plugin;
		[ExplicitOffset( Offset = 12 )]
		public Functors.Action<GTypePlugin*> unuse_plugin;
		[ExplicitOffset( Offset = 16 )]
		public Functors.Action<GTypePlugin*, uintptr, GTypeInfo*, GTypeValueTable*> complete_type_info;
		[ExplicitOffset( Offset = 20 )]
		public Functors.Action<GTypePlugin*, uintptr, uintptr, GInterfaceInfo*> complete_interface_info;
	}
	[ExplicitSize( Size = 16 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTypeQuery {
		[ExplicitOffset( Offset = 0 )]
		public uintptr type;
		[ExplicitOffset( Offset = 4 )]
		public CUtf8String type_name;
		[ExplicitOffset( Offset = 8 )]
		public uint class_size;
		[ExplicitOffset( Offset = 12 )]
		public uint instance_size;
	}
	[ExplicitSize( Size = 32 )]
	[Alignment( Boundary = 4 )]
	public partial struct GTypeValueTable {
		[ExplicitOffset( Offset = 0 )]
		public Functors.Action<GValue*> value_init;
		[ExplicitOffset( Offset = 4 )]
		public Functors.Action<GValue*> value_free;
		[ExplicitOffset( Offset = 8 )]
		public Functors.Action<GValue*, GValue*> value_copy;
		[ExplicitOffset( Offset = 12 )]
		public Functors.Func<GValue*, void*> value_peek_pointer;
		[ExplicitOffset( Offset = 16 )]
		public sbyte* collect_format;
		[ExplicitOffset( Offset = 20 )]
		public Functors.Func<GValue*, uint, GTypeCValue*, uint, sbyte*> collect_value;
		[ExplicitOffset( Offset = 24 )]
		public sbyte* lcopy_format;
		[ExplicitOffset( Offset = 28 )]
		public Functors.Func<GValue*, uint, GTypeCValue*, uint, sbyte*> lcopy_value;
	}
	[ExplicitSize( Size = 20 )]
	[Alignment( Boundary = 4 )]
	public partial struct GValue {
		[ExplicitOffset( Offset = 0 )]
		public uintptr g_type;
		[ExplicitOffset( Offset = 4 )]
		public UnnamedUnion_DE4624A9[2] data;
	}
	[ExplicitSize( Size = 12 )]
	[Alignment( Boundary = 4 )]
	public partial struct GValueArray {
		[ExplicitOffset( Offset = 0 )]
		public uint n_values;
		[ExplicitOffset( Offset = 4 )]
		public GValue* values;
		[ExplicitOffset( Offset = 8 )]
		public uint n_prealloced;
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct UnnamedStruct_F9006AC1 {
		public uint mantissa_low { get { return cast<byte*>( &this )[0] | cast<ushort>( cast<byte*>( &this )[1] ) << 8 | cast<uint>( cast<byte*>( &this )[2] ) << 16 | cast<uint>( cast<byte*>( &this )[3] ) << 24; } set { cast<byte*>( &this )[0] = cast<byte>( value ); cast<byte*>( &this )[1] = cast<byte>( value >> 8 ); cast<byte*>( &this )[2] = cast<byte>( value >> 16 ); cast<byte*>( &this )[3] = cast<byte>( value >> 24 ); } }
		public uint mantissa_high { get { return cast<byte*>( &this )[4] | cast<ushort>( cast<byte*>( &this )[5] ) << 8 | cast<uint>( cast<byte*>( &this )[6] & 15 ) << 16; } set { cast<byte*>( &this )[4] = cast<byte>( value ); cast<byte*>( &this )[5] = cast<byte>( value >> 8 ); cast<byte*>( &this )[6] &= 240; cast<byte*>( &this )[6] |= cast<byte>( value >> 48 ) & 15; } }
		public uint biased_exponent { get { return cast<byte*>( &this )[6] >> 4 | cast<ushort>( cast<byte*>( &this )[7] & 127 ) << 4; } set { cast<byte*>( &this )[6] &= 15; cast<byte*>( &this )[6] |= ( cast<byte>( value ) & 240 ) << 4; cast<byte*>( &this )[7] &= 128; cast<byte*>( &this )[7] |= cast<byte>( value >> 56 ) & 127; } }
		public bool sign { get { return ( cast<byte*>( &this )[7] & 128 ) != 0; } set { cast<byte*>( &this )[7] &= 127; cast<byte*>( &this )[7] |= cast<byte>( value ) << 7; } }
	}
	[ExplicitSize( Size = 4 )]
	[Alignment( Boundary = 4 )]
	public partial struct UnnamedStruct_F9006B26 {
		public uint mantissa { get { return cast<byte*>( &this )[0] | cast<ushort>( cast<byte*>( &this )[1] ) << 8 | cast<uint>( cast<byte*>( &this )[2] & 127 ) << 16; } set { cast<byte*>( &this )[0] = cast<byte>( value ); cast<byte*>( &this )[1] = cast<byte>( value >> 8 ); cast<byte*>( &this )[2] &= 128; cast<byte*>( &this )[2] |= cast<byte>( value >> 16 ) & 127; } }
		public uint biased_exponent { get { return cast<byte*>( &this )[2] >> 7 | cast<ushort>( cast<byte*>( &this )[3] & 127 ) << 1; } set { cast<byte*>( &this )[2] &= 127; cast<byte*>( &this )[2] |= ( cast<byte>( value ) & 128 ) << 7; cast<byte*>( &this )[3] &= 128; cast<byte*>( &this )[3] |= cast<byte>( value >> 24 ) & 127; } }
		public bool sign { get { return ( cast<byte*>( &this )[3] & 128 ) != 0; } set { cast<byte*>( &this )[3] &= 127; cast<byte*>( &this )[3] |= cast<byte>( value ) << 7; } }
	}
	[ExplicitSize( Size = 24 )]
	[Alignment( Boundary = 4 )]
	public partial struct UnnamedUnion_3D8E5D70 {
		[Overlapped( Offset = 0 )]
		public sbyte[24] pad;
		[Overlapped( Offset = 0 )]
		public double dummy_double;
		[Overlapped( Offset = 0 )]
		public void* dummy_pointer;
		[Overlapped( Offset = 0 )]
		public intptr dummy_long;
	}
	[ExplicitSize( Size = 8 )]
	[Alignment( Boundary = 4 )]
	public partial struct UnnamedUnion_DE4624A9 {
		[Overlapped( Offset = 0 )]
		public int v_int;
		[Overlapped( Offset = 0 )]
		public uint v_uint;
		[Overlapped( Offset = 0 )]
		public intptr v_long;
		[Overlapped( Offset = 0 )]
		public uintptr v_ulong;
		[Overlapped( Offset = 0 )]
		public long v_int64;
		[Overlapped( Offset = 0 )]
		public ulong v_uint64;
		[Overlapped( Offset = 0 )]
		public float v_float;
		[Overlapped( Offset = 0 )]
		public double v_double;
		[Overlapped( Offset = 0 )]
		public void* v_pointer;
	}
}