//
// Created by Eugeny Grishul
//

using System;
using System.IO;
using System.Net;
using System.Runtime;
using System.Runtime.InteropServices;

using Platform;
using Platform.IO;

namespace BamelgForwarder {
	public partial class App {
		[ReflectionMetadata( Mask = ReflectionMetadata.PublicFields )]
		internal struct AppSettings : IFormattable {
			public bool Trace, TraceTransfer;

			public void ToString( StringBuilder builder, string format ) { // use 'sbf' snippet
				builder.Concat( "Trace='", Trace, "' TraceTransfer='", TraceTransfer, '\'' );
			}
		}

		internal static AppSettings Options;

		public static SERVICE_TABLE_ENTRYW[2] ServiceTable = new SERVICE_TABLE_ENTRYW[2] {
			new SERVICE_TABLE_ENTRYW { lpServiceName = "BamelgForwarder", lpServiceProc = ServiceMain },
			default( SERVICE_TABLE_ENTRYW )
		};

		private static SERVICE_STATUS_HANDLE* _statusHandle;
		private static EventLoop _eventLoop;

		[CallingConvention( Value = NtApi.DefaultCallingConvention )]
		public static void ServiceMain( uint argc, CUtf16String* argv ) {
			_statusHandle = Advapi32Api.RegisterServiceCtrlHandlerW( "BamelgForwarder", ServiceControlHandler );
			if( _statusHandle == null ) return;

			// @{ start pending
			var status = new SERVICE_STATUS {
				dwServiceType = ServiceType.SERVICE_WIN32_OWN_PROCESS,
				dwControlsAccepted = 0,
				dwCurrentState = ServiceStatus.SERVICE_START_PENDING,
				dwWin32ExitCode = 0,
				dwServiceSpecificExitCode = 0,
				dwCheckPoint = 0
			};

			Advapi32Api.SetServiceStatus( _statusHandle, &status );
			// @}

			_eventLoop = new EventLoop();

			ApplySettings();

			// @{ running
			status.dwControlsAccepted = ServiceAcceptedControl.SERVICE_ACCEPT_STOP;
			status.dwCurrentState = ServiceStatus.SERVICE_RUNNING;
			status.dwWin32ExitCode = 0;
			status.dwCheckPoint = 1;

			Advapi32Api.SetServiceStatus( _statusHandle, &status );
			// @}

			_eventLoop.DispatchSync();

			// @{ stopped
			status.dwControlsAccepted = 0;
			status.dwCurrentState = ServiceStatus.SERVICE_STOPPED;
			status.dwWin32ExitCode = 0;
			status.dwCheckPoint = 3;

			Advapi32Api.SetServiceStatus( _statusHandle, &status );
			// @}
		}

		[CallingConvention( Value = NtApi.DefaultCallingConvention )]
		public static void ServiceControlHandler( uint dwControl ) {
			switch( dwControl ) {
				case ServiceControl.SERVICE_CONTROL_STOP: {
						var status = new SERVICE_STATUS {
							dwServiceType = ServiceType.SERVICE_WIN32_OWN_PROCESS,
							dwControlsAccepted = 0,
							dwCurrentState = ServiceStatus.SERVICE_STOP_PENDING,
							dwWin32ExitCode = 0,
							dwServiceSpecificExitCode = 0,
							dwCheckPoint = 2
						};

						Advapi32Api.SetServiceStatus( _statusHandle, &status );

						_eventLoop.RequestExit();
					} break;
			}
		}

		private static WinsockInitializer _winsockInitializer = new WinsockInitializer();

		[EntryPoint]
		private static void Main() {
			var runService = false;
			for( var i = 0; i < Environment.CommandLine.Length; ++i ) {
				switch( Environment.CommandLine[i] ) {
					case "/service": runService = true; break;
				}
			}

			if( runService ) {
				Advapi32Api.StartServiceCtrlDispatcher( ServiceTable );
			}
			else {
				var eventLoop = new EventLoop();
				eventLoop.CatchConsoleQuit();

				ApplySettings();

				eventLoop.DispatchSync();
			}
		}

		private static void ApplySettings() {
			var appMapper = new Binder.MapperUtf16( typeof( AppSettings ) );

			var endpointMapper = new Binder.MapperUtf16( 10 );

			endpointMapper.Add( "", memberinfo( Endpoint.Type ) );
			endpointMapper.Add( memberinfo( Endpoint.Enabled ) );
			endpointMapper.Add( memberinfo( Endpoint.KeepAlive ) );
			endpointMapper.Add( memberinfo( Endpoint.IsReadable ) );
			endpointMapper.Add( memberinfo( Endpoint.IsWritable ) );

			endpointMapper.Add( memberinfo( Endpoint.SerialPortReadIntervalTimeout ) );
			endpointMapper.Add( memberinfo( Endpoint.SerialPortPath ) );
			endpointMapper.Add( memberinfo( Endpoint.SerialPortParity ) );
			endpointMapper.Add( memberinfo( Endpoint.SerialPortBaudRate ) );
			endpointMapper.Add( memberinfo( Endpoint.SerialPortStopBits ) );

			endpointMapper.Add( memberinfo( Endpoint.TCPv4Endpoint ) );
			endpointMapper.Add( memberinfo( Endpoint.TCPv4ServerEndpoint ) );

			endpointMapper.Add( memberinfo( Endpoint.TCPv6Endpoint ) );
			endpointMapper.Add( memberinfo( Endpoint.TCPv6ServerEndpoint ) );

			endpointMapper.Add( memberinfo( Endpoint.UDPv4Endpoint ) );
			endpointMapper.Add( memberinfo( Endpoint.UDPv4RemoteEndpoint ) );

			endpointMapper.Add( memberinfo( Endpoint.NamedPipePath ) );
			endpointMapper.Add( memberinfo( Endpoint.NamedPipeServerPath ) );

			endpointMapper.Apply();

			using( var root = HKEY.HKEY_LOCAL_MACHINE.OpenRead( RegistrySettingsPath ) ) {
				if( !root.IsValid ) { Console.WriteLine( "Unable to read settings from '{0}'", RegistrySettingsPath ); return; }

				root.GetValues( appMapper.Binder.CreateContext( &Options ), appMapper );

				if( Options.Trace ) Console.WriteConcatLine( "Options: ", Options );

				if( Options.Trace ) {
					using( var commKey = HKEY.HKEY_LOCAL_MACHINE.OpenRead( @"HARDWARE\DEVICEMAP\SERIALCOMM" ) )
						foreach( var serialName in commKey.GetValues() )
							Console.WriteLine( @"Found serial port: \\.\{0} <- {1}", commKey.ValueString[serialName.Name], serialName.Name );
				}

				foreach( var connectorName in root.GetKeys() ) {
					using( var connectorKey = root.OpenRead( connectorName ) ) {
						var connector = new Connector() {
							Name = connectorName
						};

						foreach( var endpointName in connectorKey.GetKeys() ) {
							var currentEndpoint = &connector.Endpoint1;
							if( *currentEndpoint != null ) currentEndpoint = &connector.Endpoint2;
							if( *currentEndpoint != null ) {
								if( Options.Trace ) Console.WriteLine( "{0}: Unused endpoint '{1}'", connector, endpointName );
								continue;
							}

							using( var endpointKey = connectorKey.OpenRead( endpointName ) ) {
								var ep = new Endpoint() { Name = endpointName };
								endpointKey.GetValues( endpointMapper.Binder.CreateContext( &ep ), endpointMapper );

								if( !ep.Enabled ) {
									if( Options.Trace ) Console.WriteLine( "{0}: Endpoint '{1}' is disabled", connector, endpointName );
									continue;
								}

								if( !( ep.IsReadable | ep.IsWritable ) ) {
									Console.WriteLine( "{0}: Endpoint '{1}' must be readable or writable, or both", connector, endpointName );
									continue;
								}

								*currentEndpoint = ep;
							}
						}

						if( connector.Endpoint1 != null && connector.Endpoint2 != null ) {
							if( connector.Endpoint1.IsReadable | connector.Endpoint2.IsReadable ) {
								if( Options.Trace ) Console.WriteLine( "{0}: Begin dispatch", connector );
								connector.Run();
							}
							else {
								Console.WriteLine( "{0}: At least one endpoint must be readable", connector );
							}
						}
						else
							Console.WriteLine( "Not sufficient valid endpoints specified for '{0}'", connectorName );
					}
				}
			}
		}

		public const string RegistrySettingsPath = @"SOFTWARE\Eugeny Grishul\BamelgForwarder";
	}

	public class Connector : IFormattable {
		public string Name;
		public Endpoint Endpoint1, Endpoint2;

		public Connector() {
		}

		public void ToString( StringBuilder builder, string format ) {
			builder.AppendFormat( "'{0}': {1} <-> {2}", Name, Endpoint1, Endpoint2 );
		}

		public void Run() {
			Endpoint1.Connector = this;
			Endpoint2.Connector = this;

			AddReference();
			AddReference();

			var pages = 4;
			Fiber.Start( pages, () => Transfer( Endpoint1, Endpoint2 ), App.Options.Trace ? Endpoint1.Name + " connector" : null );
			Fiber.Start( pages, () => Transfer( Endpoint2, Endpoint1 ), App.Options.Trace ? Endpoint2.Name + " connector" : null );
		}

		private void Transfer( Endpoint source, Endpoint destination ) {
			while( !Fiber.IsCancelled ) {
				using( new Fiber.CancellationRegion() ) {
					var isConnected = source.Connect();

					if( !isConnected ) {
						if( App.Options.Trace ) Console.WriteLine( "{0}: Connect failed", source );

						Fiber.Sleep( 1000 );
						destination.ResetNonKeepAlive();
						continue;
					}

					if( App.Options.Trace ) Console.WriteLine( "{0}: Connected", source );
					source.WriteTo( destination );
				}

				destination.ResetNonKeepAlive();
			}

			source.Close();
			source.Connector = null;
			ReleaseReference();
		}
	}

	public enum EndpointType {
		SerialPort,      // Serial port, SerialPortPath = \\.\COM1
		TCPv4,           // TCP v4 client, TCPv4Endpoint = 127.0.0.1:4010
		TCPv4Server,     // TCP v4 server, TCPv4ServerEndpoint = 0.0.0.0:4010
		TCPv6,           // TCP v6 client, TCPv6Endpoint = [::1]:2346
		TCPv6Server,     // TCP v6 server, TCPv6ServerEndpoint = [::1]:2346
		UDPv4,           // UDP v4 client, UDPv4Endpoint = 127.0.0.1:4010
		NamedPipe,       // Named pipe client, NamedPipePath = \\.\pipe\PipeName
		NamedPipeServer, // Named pipe, NamedPipeServerPath = \\.\pipe\PipeName
	}

	public class Endpoint : NetworkClient, IPlatformErrorHandler, IFormattable {
		public string Name;
		public Connector Connector;

		public EndpointType Type;

		public bool Enabled { get; set; } = true;

		/// Don't drop active connection when other end down
		public bool KeepAlive { get; set; } = true;

		/// Is endpoint readable
		public bool IsReadable { get; set; } = true;

		/// Is endpoint writable
		public bool IsWritable { get; set; } = true;

		// @{ serial port settings

		/// Path to serial port device '\\.\COM6'
		public string SerialPortPath;

		/// See http://msdn.microsoft.com/ru-ru/library/windows/desktop/aa363190(v=vs.85).aspx
		public uint SerialPortReadIntervalTimeout = 10;

		private uint _serialPortBaudRate;
		public bool IsSerialPortBaudRateOverriden;
		public uint SerialPortBaudRate { get { return _serialPortBaudRate; } set { _serialPortBaudRate = value; IsSerialPortBaudRateOverriden = true; } }

		private DCB.ParityScheme _serialPortParity;
		public bool IsSerialPortParityOverriden;
		public DCB.ParityScheme SerialPortParity { get { return _serialPortParity; } set { _serialPortParity = value; IsSerialPortParityOverriden = true; } }

		private DCB.StopBitsValue _serialPortStopBits;
		public bool IsSerialPortStopBitsOverriden;
		public DCB.StopBitsValue SerialPortStopBits { get { return _serialPortStopBits; } set { _serialPortStopBits = value; IsSerialPortStopBitsOverriden = true; } }
		// @}

		// @{ TCPv4 settings
		public IPv4Endpoint TCPv4Endpoint;
		// @}

		// @{ TCPv4Server settings
		public IPv4Endpoint TCPv4ServerEndpoint;
		// @}

		// @{ TCPv6 settings
		public IPv6Endpoint TCPv6Endpoint;
		// @}

		// @{ TCPv6Server settings
		public IPv6Endpoint TCPv6ServerEndpoint;
		// @}

		// @{ UDPv4 settings
		public IPv4Endpoint UDPv4Endpoint;
		public IPv4Endpoint UDPv4RemoteEndpoint;
		// @}

		// @{ NamedPipe settings
		public string NamedPipePath;
		// @}

		// @{ NamedPipeServer settings
		public string NamedPipeServerPath;
		// @}

		public bool IsAlive { get; private set; }

		public Fiber Transmitter = Fiber.Null;

		public Endpoint() {
		}

		public void ToString( StringBuilder builder, string format ) {
			builder.AppendFormat( "{0}( {1}:", Name, Type );

			switch( Type ) {
				case EndpointType.SerialPort:
					builder.Append( SerialPortPath );
					if( IsSerialPortBaudRateOverriden ) builder.Concat( " ", memberinfo( SerialPortBaudRate ).Name, "=", SerialPortBaudRate );
					if( IsSerialPortParityOverriden ) builder.Concat( " ", memberinfo( SerialPortParity ).Name, "=", SerialPortParity );
					if( IsSerialPortStopBitsOverriden ) builder.Concat( " ", memberinfo( SerialPortStopBits ).Name, "=", SerialPortStopBits );
					break;

				case EndpointType.TCPv4: builder.Append( TCPv4Endpoint ); break;
				case EndpointType.TCPv4Server: builder.Append( TCPv4ServerEndpoint ); break;
				case EndpointType.TCPv6: builder.Append( TCPv6Endpoint ); break;
				case EndpointType.TCPv6Server: builder.Append( TCPv6ServerEndpoint ); break;
				case EndpointType.UDPv4: builder.Concat( UDPv4Endpoint, "<->", UDPv4RemoteEndpoint ); break;
				case EndpointType.NamedPipe: builder.Append( NamedPipePath ); break;
				case EndpointType.NamedPipeServer: builder.Append( NamedPipeServerPath ); break;
			}

			// if( !IsAlive ) builder.Concat( "", memberinfo( IsAlive ).Name, "=", IsAlive );

			builder.Append( " )" );
		}

		public PlatformErrorAction OnError( string operation, IFormattable context, SystemErrorCode errorCode ) {
			IsAlive = false;

			if( App.Options.Trace )
				using( Console.AttributedRegion( RgbColor.Red ) )
					Console.WriteLine( "{0}: {1} {2} {3}", this, context, operation, errorCode );

			return PlatformErrorAction.Default;
		}

		public void ResetNonKeepAlive() {
			// if( destination.IsReadable & destination.IsAlive & !destination.KeepAlive ) destination.Transmitter.Cancel();
		}

		public void WriteTo( Endpoint destination ) {
			while( !Fiber.IsCancelled & IsAlive ) {
				StreamingBufferInfo* bufferInfo;
				var bufferedStream = _stream.GetBufferedReadStream( bufferInfo );

				for( ; !Fiber.IsCancelled & IsAlive; ) {
					if( bufferInfo->AvailableToRead < bufferInfo->Capacity / 2 ) bufferedStream.Flush( FlushKind.Read );
					if( bufferInfo->AvailableToRead == 0 ) {
						if( App.Options.TraceTransfer ) Console.WriteLine( "{0}: read stream end", this );
						if( Type == EndpointType.SerialPort ) continue;
						IsAlive = Fiber.IsCancelled;
						return;
					}

					if( App.Options.TraceTransfer ) Console.WriteLine( "{0}: Transfer {1} bytes to {2}", this, bufferInfo->AvailableToRead, destination );

					if( destination.IsAlive ) {
						if( destination.IsWritable ) destination._stream.Write( bufferInfo->ReadBufferStart, bufferInfo->AvailableToRead );
					}
					else {
						if( !KeepAlive ) break;
					}

					bufferInfo->OnReadPerformed( bufferInfo->AvailableToRead );
				}
			}
		}

		public void Close() {
			_stream = null;
			IsAlive = false;
		}

		public bool Connect() {
			Close();

			switch( Type ) {
				case EndpointType.SerialPort: {
						var fs = new Platform.IO.FileStream() {
							ErrorHandler = ErrorHandler
						};

						if( fs.Open( SerialPortPath, FileAccessRights.GENERIC_WRITE | FileAccessRights.GENERIC_READ, FileCreationDisposition.OPEN_EXISTING ) ) {
							var name2 = SerialPortPath;
							if( name2.StartsWith( @"\\.\" ) ) name2 = name2.Substring( 4 );

							var defaultConfig = default( COMMCONFIG );
							uint defaultConfigSize = sizeof( defaultConfig );
							bool gotDefaults = Kernel32Api.GetDefaultCommConfig( name2, defaultConfig, defaultConfigSize );
							if( gotDefaults ) {
								if( App.Options.Trace )
									using( Console.AttributedRegion( RgbColor.Yellow ) )
										Console.WriteLine( "Serial port defaults for '{0}': '{1}'", name2, defaultConfig.dcb );
							}
							else {
								if( App.Options.Trace ) Console.WriteLine( "Unable to retrieve serial port defaults for '{0}'", name2 );
							}

							var dcb = new DCB();

							if( gotDefaults ) {
								defaultConfig.dcb.fDtrControl = DCB.DtrControl.DTR_CONTROL_ENABLE;
								defaultConfig.dcb.fRtsControl = DCB.RtsControl.RTS_CONTROL_TOGGLE;
								if( IsSerialPortBaudRateOverriden ) defaultConfig.dcb.BaudRate = SerialPortBaudRate;
								if( IsSerialPortStopBitsOverriden ) defaultConfig.dcb.StopBits = SerialPortStopBits;
								if( IsSerialPortParityOverriden ) {
									defaultConfig.dcb.fParity = SerialPortParity != DCB.ParityScheme.NOPARITY;
									defaultConfig.dcb.Parity = SerialPortParity;
								}

								if( Kernel32Api.SetCommState( fs.Handle, &defaultConfig.dcb ) ) {
									if( App.Options.Trace ) Console.WriteLine( "Set DCB '{0}': '{1}'", name2, defaultConfig.dcb );
								}
								else {
									if( App.Options.Trace ) Console.WriteLine( "Unable to set DCB for '{0}': '{1}'", name2, defaultConfig.dcb );
								}
							}

							if( !Kernel32Api.GetCommState( fs.Handle, &dcb ) )
								if( App.Options.Trace ) Console.WriteLine( "Unable to get DCB for '{0}'", name2 );

							if( App.Options.Trace ) {
								using( Console.AttributedRegion( RgbColor.Yellow ) )
									Console.WriteLine( "Active DCB for '{0}': '{1}'", name2, dcb );
							}

							var timeouts = new COMMTIMEOUTS {
								ReadIntervalTimeout = SerialPortReadIntervalTimeout,
								ReadTotalTimeoutMultiplier = 0,
								ReadTotalTimeoutConstant = 0,

								WriteTotalTimeoutMultiplier = 0,
								WriteTotalTimeoutConstant = 0
							};

							if( !Kernel32Api.SetCommTimeouts( fs.Handle, &timeouts ) )
								if( App.Options.Trace ) Console.WriteLine( "Unable to set timeouts for '{0}'", name2 );

							_stream = fs;
							return IsAlive = true;
						}

						break;
					}

				case EndpointType.UDPv4: {
						var socket = new SocketHandleUDP();

						var ns = new Platform.IO.UdpStream( socket ) {
							ErrorHandler = ErrorHandler,
							WriteEndpoint = new WsaAddress( UDPv4RemoteEndpoint )
						};

						if( !ns.Bind( UDPv4Endpoint ) ) break;

						_stream = ns;
						return IsAlive = true;
					} break;

				case EndpointType.TCPv4: return IsAlive = Connect( TCPv4Endpoint );
				case EndpointType.TCPv4Server: return IsAlive = Accept( TCPv4ServerEndpoint );
				case EndpointType.TCPv6: return IsAlive = Connect( TCPv6Endpoint );
				case EndpointType.TCPv6Server: KeepAlive = false; return IsAlive = Accept( TCPv6ServerEndpoint );

				case EndpointType.NamedPipe: return IsAlive = ConnectLocal( NamedPipePath );
				case EndpointType.NamedPipeServer: return IsAlive = AcceptLocal( NamedPipeServerPath );
			}

			return false;
		}

		protected override IPlatformErrorHandler ErrorHandler { get { return this; } }
	}
}