//
// Autogenerated by Thrift Compiler ( 0.9.0-dev ). Do not edit
//

using System;
using System.Collections;
using System.Serialization.Thrift;

namespace Example {
	public static partial class Svc1 {
		public interface IApi {
			int add( int left, int right );
			List<Utf8String> get_strings();
			Dictionary<Utf8String, Utf8String> echo( Dictionary<Utf8String, Utf8String> value );
			void some_event( Utf8String text );
			void log( DateTime date, Guid id, Utf8String text );
			void ts( List<TimeSpan> span );
		}

		public interface IExceptionHandler : System.Serialization.Thrift.IExceptionHandler {
			void OnException( ExceptionWithMessage exception );
		}

		public struct ExceptionHandlerConsole : System.Serialization.Thrift.ExceptionHandlerConsole, IExceptionHandler {
			public static new readonly thistype Instance;

			public void OnException( ExceptionWithMessage exception ) { Console.WriteLine( exception ); }
		}

		public class Client : IApi {
			protected ProtocolCodec _reader, _writer;
			protected int _seqid;
			private IExceptionHandler _exceptionHandler = ExceptionHandlerConsole.Instance;
			public IExceptionHandler ExceptionHandler {
				get { return _exceptionHandler; }
				set { _exceptionHandler = value; }
			}


			public Client( ProtocolCodec prot )
				: this( prot, prot ) { }

			public Client( ProtocolCodec reader, ProtocolCodec writer ) {
				_reader = reader;
				_writer = writer;
			}

			public int add( int left, int right ) {
				_writer.WriteMessageBegin( "add", MessageInfo.Kind.Call, _seqid );
				var args = new add_args();
				args.Left = left;
				args.Right = right;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( int );
				}

				var result = new add_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.excpt ) { _exceptionHandler.OnException( result.Excpt ); return default( int ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( int );
			}

			public List<Utf8String> get_strings() {
				_writer.WriteMessageBegin( "get_strings", MessageInfo.Kind.Call, _seqid );
				var args = new get_strings_args();
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( List<Utf8String> );
				}

				var result = new get_strings_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( List<Utf8String> );
			}

			public Dictionary<Utf8String, Utf8String> echo( Dictionary<Utf8String, Utf8String> value ) {
				_writer.WriteMessageBegin( "echo", MessageInfo.Kind.Call, _seqid );
				var args = new echo_args();
				args.Value = value;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Dictionary<Utf8String, Utf8String> );
				}

				var result = new echo_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Dictionary<Utf8String, Utf8String> );
			}

			public void some_event( Utf8String text ) {
				_writer.WriteMessageBegin( "some_event", MessageInfo.Kind.Call, _seqid );
				var args = new some_event_args();
				args.Text = text;
				args.Write( _writer );
				_writer.WriteMessageEnd();
			}

			public void log( DateTime date, Guid id, Utf8String text ) {
				_writer.WriteMessageBegin( "log", MessageInfo.Kind.Call, _seqid );
				var args = new log_args();
				args.Date = date;
				args.Id = id;
				args.Text = text;
				args.Write( _writer );
				_writer.WriteMessageEnd();
			}

			public void ts( List<TimeSpan> span ) {
				_writer.WriteMessageBegin( "ts", MessageInfo.Kind.Call, _seqid );
				var args = new ts_args();
				args.Span = span;
				args.Write( _writer );
				_writer.WriteMessageEnd();
			}
		}

		public class RequestHandler : IRequestHandler {
			protected uint _pendingException = 0;
			public void OnException( ServerException exception ) { }
			public void OnException( ProtocolError exception ) { }

			public RequestHandler( IApi @delegate ) {
				_delegate = @delegate;
			}

			private IApi _delegate;

			public bool Process( ProtocolCodec reader, ProtocolCodec writer ) {
				var msg = reader.ReadMessageBegin();
				if( msg.Name == null ) return false;
				switch( msg.Name ) {
					case "add": add_Process( msg.SeqID, reader, writer ); return true;
					case "echo": echo_Process( msg.SeqID, reader, writer ); return true;
					case "get_strings": get_strings_Process( msg.SeqID, reader, writer ); return true;
					case "log": log_Process( msg.SeqID, reader, writer ); return true;
					case "some_event": some_event_Process( msg.SeqID, reader, writer ); return true;
					case "ts": ts_Process( msg.SeqID, reader, writer ); return true;

					default: {
							reader.Skip( TypeKind.Struct );
							reader.ReadMessageEnd();
							var x = new ServerException( ServerException.Kind.UnknownMethod, msg.Name );
							writer.WriteMessageBegin( msg.Name, MessageInfo.Kind.Exception, msg.SeqID );
							x.Write( writer );
							writer.WriteMessageEnd();
							return true;
						}
				}
			}

			protected ExceptionWithMessage _pendingExceptionWithMessage;
			public void SendException( ExceptionWithMessage exception ) {
				_pendingException = 1;
				_pendingExceptionWithMessage = exception;
			}

			protected void add_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new add_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new add_result();
				var success = _delegate.add( args.Left, args.Right );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 1: result.Excpt = _pendingExceptionWithMessage; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "add", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void get_strings_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new get_strings_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new get_strings_result();
				result.Success = _delegate.get_strings();
				writer.WriteMessageBegin( "get_strings", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void echo_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new echo_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new echo_result();
				result.Success = _delegate.echo( args.Value );
				writer.WriteMessageBegin( "echo", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void some_event_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new some_event_args();
				args.Read( reader );
				reader.ReadMessageEnd();
				_delegate.some_event( args.Text );
				return;
			}

			protected void log_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new log_args();
				args.Read( reader );
				reader.ReadMessageEnd();
				_delegate.log( args.Date, args.Id, args.Text );
				return;
			}

			protected void ts_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new ts_args();
				args.Read( reader );
				reader.ReadMessageEnd();
				_delegate.ts( args.Span );
				return;
			}
		}
		public partial struct add_args : IFormattable {
			private int _left;
			private int _right;

			public int Left { get { return _left; } set { __isset.left = true; _left = value; } }
			public int Right { get { return _right; } set { __isset.right = true; _right = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool left { get; set; }
				public bool right { get; set; }
			}

			public add_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Int32 ) {
								Left = reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Int32 ) {
								Right = reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "add_args" );
				if( __isset.left ) {
					writer.WriteFieldBegin( "left", TypeKind.Int32, 1 );
					writer.WriteInt32( _left );
					writer.WriteFieldEnd();
				}
				if( __isset.right ) {
					writer.WriteFieldBegin( "right", TypeKind.Int32, 2 );
					writer.WriteInt32( _right );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Left: ", Left, " Right: ", Right );
			}
		}
		public partial struct add_result : IFormattable {
			private int _success;
			private ExceptionWithMessage _excpt;

			public int Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public ExceptionWithMessage Excpt { get { return _excpt; } set { __isset.excpt = true; _excpt = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool excpt { get; set; }
			}

			public add_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Int32 ) {
								Success = reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Excpt = new ExceptionWithMessage();
								Excpt.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "add_result" );

				if( __isset.success ) {
					writer.WriteFieldBegin( "Success", TypeKind.Int32, 0 );
					writer.WriteInt32( _success );
					writer.WriteFieldEnd();
				} else if( __isset.excpt ) {
					writer.WriteFieldBegin( "Excpt", TypeKind.Struct, 1 );
					_excpt.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Excpt: ", Excpt );
			}
		}
		public partial struct get_strings_args : IFormattable {
			public get_strings_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_strings_args" );
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
			}
		}
		public partial struct get_strings_result : IFormattable {
			private List<Utf8String> _success;

			public List<Utf8String> Success { get { return _success; } set { __isset.success = true; _success = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
			}

			public get_strings_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Success = new List<Utf8String>( ( uint ) localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = reader.ReadString();
									_success.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_strings_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.List, 0 );
						{
							writer.WriteListBegin( TypeKind.String, ( int ) _success.Count );
							foreach( var item in _success ) {
								writer.WriteString( item );
							}
							writer.WriteListEnd();
						}
						writer.WriteFieldEnd();
					}
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success );
			}
		}
		public partial struct echo_args : IFormattable {
			private Dictionary<Utf8String, Utf8String> _value;

			public Dictionary<Utf8String, Utf8String> Value { get { return _value; } set { __isset.value = true; _value = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool value { get; set; }
			}

			public echo_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Map ) {
								var localMap = reader.ReadMapBegin();
								Value = new Dictionary<Utf8String, Utf8String>( ( uint ) localMap.Count );
								for( var localCounter = 0; localCounter < localMap.Count; ++localCounter ) {
									var localKey = reader.ReadString();
									var localValue = reader.ReadString();
									_value[localKey] = localValue;
								}
								reader.ReadMapEnd();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "echo_args" );
				if( Value != null && __isset.value ) {
					writer.WriteFieldBegin( "value", TypeKind.Map, 1 );
					{
						writer.WriteMapBegin( TypeKind.String, TypeKind.String, ( int ) _value.Count );
						foreach( var item in _value ) {
							writer.WriteString( item.Key );
							writer.WriteString( item.Value );
						}
						writer.WriteMapEnd();
					}
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Value: ", Value );
			}
		}
		public partial struct echo_result : IFormattable {
			private Dictionary<Utf8String, Utf8String> _success;

			public Dictionary<Utf8String, Utf8String> Success { get { return _success; } set { __isset.success = true; _success = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
			}

			public echo_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Map ) {
								var localMap = reader.ReadMapBegin();
								Success = new Dictionary<Utf8String, Utf8String>( ( uint ) localMap.Count );
								for( var localCounter = 0; localCounter < localMap.Count; ++localCounter ) {
									var localKey = reader.ReadString();
									var localValue = reader.ReadString();
									_success[localKey] = localValue;
								}
								reader.ReadMapEnd();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "echo_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Map, 0 );
						{
							writer.WriteMapBegin( TypeKind.String, TypeKind.String, ( int ) _success.Count );
							foreach( var item in _success ) {
								writer.WriteString( item.Key );
								writer.WriteString( item.Value );
							}
							writer.WriteMapEnd();
						}
						writer.WriteFieldEnd();
					}
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success );
			}
		}
		public partial struct some_event_args : IFormattable {
			private Utf8String _text;

			public Utf8String Text { get { return _text; } set { __isset.text = true; _text = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool text { get; set; }
			}

			public some_event_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Text = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "some_event_args" );
				if( Text != null && __isset.text ) {
					writer.WriteFieldBegin( "text", TypeKind.String, 1 );
					writer.WriteString( _text );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Text: ", Text );
			}
		}
		public partial struct log_args : IFormattable {
			private DateTime _date;
			private Guid _id;
			private Utf8String _text;

			public DateTime Date { get { return _date; } set { __isset.date = true; _date = value; } }
			public Guid Id { get { return _id; } set { __isset.id = true; _id = value; } }
			public Utf8String Text { get { return _text; } set { __isset.text = true; _text = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool date { get; set; }
				public bool id { get; set; }
				public bool text { get; set; }
			}

			public log_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Int64 ) {
								Date = reader.ReadDateTime();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.String ) {
								Id = reader.ReadGuid();
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.String ) {
								Text = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "log_args" );
				if( __isset.date ) {
					writer.WriteFieldBegin( "date", TypeKind.Int64, 1 );
					writer.WriteDateTime( _date );
					writer.WriteFieldEnd();
				}
				if( __isset.id ) {
					writer.WriteFieldBegin( "id", TypeKind.String, 2 );
					writer.WriteGuid( _id );
					writer.WriteFieldEnd();
				}
				if( Text != null && __isset.text ) {
					writer.WriteFieldBegin( "text", TypeKind.String, 3 );
					writer.WriteString( _text );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Date: ", Date, " Id: ", Id, " Text: ", Text );
			}
		}
		public partial struct ts_args : IFormattable {
			private List<TimeSpan> _span;

			public List<TimeSpan> Span { get { return _span; } set { __isset.span = true; _span = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool span { get; set; }
			}

			public ts_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Span = new List<TimeSpan>( ( uint ) localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = reader.ReadTimeSpan();
									_span.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "ts_args" );
				if( Span != null && __isset.span ) {
					writer.WriteFieldBegin( "span", TypeKind.List, 1 );
					{
						writer.WriteListBegin( TypeKind.Int64, ( int ) _span.Count );
						foreach( var item in _span ) {
							writer.WriteTimeSpan( item );
						}
						writer.WriteListEnd();
					}
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Span: ", Span );
			}
		}
	}
}