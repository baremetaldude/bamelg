//
// Created by Eugeny Grishul
//

using System;
using System.Diagnostics;
using System.Text;
using System.Xml;

using Platform;

namespace BamelgBench {
	public partial class App {
		private static ExitCodes Worker() {
			if( Environment.CommandLine.Length < 2 ) return ExitCodes.NotEnoughMinerals;

			// for( var i = 0; i < Environment.CommandLine.Length; ++i ) Console.WriteLine( "[{0}]='{1}'", i, Environment.CommandLine[i] );
			var commandLineBuilder = new CommandLineBuilder();

			for( var i = 1; i < Environment.CommandLine.Length; ++i )
				commandLineBuilder.Append( Environment.CommandLine[i] );

			// Console.WriteLine( "Running '{0}'", builder );

			var startupInfo = new STARTUPINFOW();
			var processInformation = new PROCESS_INFORMATION { };

			var started = DateTime.UnbiasedNow;
			if( !Kernel32Api.CreateProcess( Environment.CommandLine[1], commandLineBuilder.Value.GetNullTerminatingBuffer(), nullref, nullref, false, 0x20, null, CUtf16String.Null, startupInfo, processInformation ) ) return ExitCodes.UnableToCreateProcess;
			Kernel32Api.SetPriorityClass( processInformation.Process, ProcessPriorityClass.HIGH_PRIORITY_CLASS );
			Kernel32Api.WaitForSingleObject( processInformation.Process, Kernel32Api.INFINITE );

			uint exitCode;
			ulong processCycles, mainThreadCycles;
			var externallyMeasuredElapsedTime = DateTime.UnbiasedNow - started;

			if( !Kernel32Api.QueryProcessCycleTime( processInformation.Process, processCycles ) ) return ExitCodes.UnableToReadProcessInfo;
			if( !Kernel32Api.QueryThreadCycleTime( processInformation.Thread, mainThreadCycles ) ) return ExitCodes.UnableToReadThreadInfo;
			if( !Kernel32Api.GetExitCodeProcess( processInformation.Process, exitCode ) ) return ExitCodes.UnableToReadProcessInfo;

			FILETIME creationTime2, exitTime2;
			TimeSpan kernelTime, userTime;
			if( !Kernel32Api.GetProcessTimes( processInformation.Process, creationTime2, exitTime2, kernelTime, userTime ) ) return ExitCodes.UnableToReadProcessInfo;

			DateTime creationTime = ( DateTime ) creationTime2, exitTime = ( DateTime ) exitTime2;
			var totalTime = kernelTime + userTime;

			PROCESS_MEMORY_COUNTERS_EX memCounters;
			if( !Kernel32Api.K32GetProcessMemoryInfo( processInformation.Process, memCounters, ( uint ) sizeof( PROCESS_MEMORY_COUNTERS_EX ) ) ) return ExitCodes.UnableToReadProcessInfo;

			Kernel32Api.CloseHandle( processInformation.Process );
			Kernel32Api.CloseHandle( processInformation.Thread );

			var builder = new StringBuilder();
			using( var writer = new XmlWriter( builder ) { PreserveNewlines = true } ) {
				writer.Declaration();

				using( writer.Tag( "result" ) ) {
					using( writer.Tag( "CreationTimeReadable" ) ) writer.Write( creationTime );
					using( writer.Tag( "ExitTimeReadable" ) ) writer.Write( exitTime );
					using( writer.Tag( "KernelTimeReadable" ) ) writer.Write( kernelTime );
					using( writer.Tag( "UserTimeReadable" ) ) writer.Write( userTime );
					using( writer.Tag( "TotalTimeReadable" ) ) writer.Write( totalTime );

					using( writer.Tag( "ExitCode" ) ) writer.Write( exitCode );

					using( writer.Tag( "CreationTime" ) ) writer.Write( creationTime.Ticks );
					using( writer.Tag( "ExitTime" ) ) writer.Write( exitTime.Ticks );
					using( writer.Tag( "KernelTime" ) ) writer.Write( kernelTime.Ticks );
					using( writer.Tag( "UserTime" ) ) writer.Write( userTime.Ticks );
					using( writer.Tag( "TotalTime" ) ) writer.Write( totalTime.Ticks );

					using( writer.Tag( "ProcessCycles" ) ) writer.Write( processCycles );
					using( writer.Tag( "MainThreadCycles" ) ) writer.Write( mainThreadCycles );

					using( writer.Tag( "PeakWorkingSetSize" ) ) writer.Write( memCounters.PeakWorkingSetSize );
					using( writer.Tag( "PeakPagefileUsage" ) ) writer.Write( memCounters.PeakPagefileUsage );
					using( writer.Tag( "PageFaultCount" ) ) writer.Write( memCounters.PageFaultCount );
				}
			}

			var outputPath = Environment.GetEnvironmentVariable( "BB_OUTPUT_PATH" );
			if( !outputPath.IsNullOrEmpty )
				System.IO.File.WriteAllText( ( string ) outputPath, builder );
			else
				Console.WriteLine( builder );

			return ExitCodes.OK;
		}

		public enum ExitCodes {
			OK =                      0,

			NotEnoughMinerals =       1,
			UnableToCreateProcess =   2,
			UnableToReadProcessInfo = 3,
			UnableToReadThreadInfo =  4,
		}

		[EntryPoint]
		private static void Main() {
			var code = Worker();
			Environment.ExitCode = code;

			if( code != 0 ) {
				switch( code ) {
					case ExitCodes.NotEnoughMinerals:
						Console.WriteLine( "Created by Eugeny Grishul. More info at http://bamelg.com" );
						Console.WriteLine( "Usage:" );
						Console.WriteLine( @"  bamelgbench.exe TestApp.exe parameter1 ""par ame ter2""" );
						Console.WriteLine( "Environment variables:" );
						Console.WriteLine( "  BB_OUTPUT_PATH=FileName.ext output to file instead of stdout" );
						break;

					case ExitCodes.UnableToCreateProcess: Console.WriteLine( "Unable to create process" ); break;
					case ExitCodes.UnableToReadProcessInfo: Console.WriteLine( "Unable to read process info" ); break;
					case ExitCodes.UnableToReadThreadInfo: Console.WriteLine( "Unable to read thread info" ); break;

					default: Console.WriteLine( "Unknown error" ); break;
				}
			}
		}
	}
}