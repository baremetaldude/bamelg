//
// Created by $USER
//

using System;
using System.IO;
using System.Runtime;

using Platform.IO;
using Platform.Libc;

namespace Example {
	public partial class App {
		const int Pages = 4;

		[FiberStatic]
		static int FiberLocalData = 123;

		private const int FiberStackallocPages = 128;

		// Press CTRL+C to exit
		[EntryPoint]
		private static void Main() {
			var eventLoop = new EventLoop();
			System.Threading.ThreadPool.Initialize();

			if( FiberStackallocPages > 0 ) {
				var fiberStack = new MemorySegment( stackalloc Memory.Page[FiberStackallocPages], ( uintptr ) FiberStackallocPages * sizeof( Memory.Page ) );

				Fiber.FiberManager.PageManager = new MemoryPageManager( fiberStack );
				Console.WriteLine( "Allocated workaround stack for fibers {0}", fiberStack );
			}

			eventLoop.CatchExitSignals();

			Fiber.Start( Pages, () => {
				System.Numerics.Matrix4x4 mat;
				Assert.AreEqual( 0, ( cast<intptr>( &mat ) & 15 ) );
			}, "alignment_checker" );

			// @{ execute all code without context switch
			for( var i = 0; i < 3; ++i ) {
				Fiber.Start( Pages, () => {
					Console.WriteLine( "CONTINUOUS: Fiber [{0}] in thread [{1}] started", Fiber.Current, pthread_t.CurrentThread );

					Console.WriteLine( "CONTINUOUS: FiberLocalData={0} &FiberLocalData={1}", FiberLocalData, &FiberLocalData );
					++FiberLocalData;

					Console.WriteLine( "CONTINUOUS: Fiber [{0}] in thread [{1}] finished", Fiber.Current, pthread_t.CurrentThread );
				}, "cont" + i );
			}
			// @}

			// @{ use barrier to syncronize fibers
			var fb = new Fiber.Barrier( 2 ); // NOTE: 'fb' captured by lambda valid/alive only inside Main()
			Fiber.Start( Pages, () => {
				Console.WriteLine( "BARRIER: Fiber [{0}] in thread [{1}] started", Fiber.Current, pthread_t.CurrentThread );
				fb.Wait();
				Console.WriteLine( "BARRIER: Fiber [{0}] in thread [{1}] finished", Fiber.Current, pthread_t.CurrentThread );
			}, "bar0" );

			Fiber.Start( Pages, () => {
				Console.WriteLine( "BARRIER: Fiber [{0}] in thread [{1}] started", Fiber.Current, pthread_t.CurrentThread );
				fb.Wait();
				Console.WriteLine( "BARRIER: Fiber [{0}] in thread [{1}] finished", Fiber.Current, pthread_t.CurrentThread );
			}, "bar1" );
			// @}

			// @}

			// @{ use of 'Fiber.Sleep'
			Fiber.Start( Pages, () => {
				for( var i = 0; i < 10; ++i ) {
					Console.WriteLine( DateTime.Now );
					Fiber.Sleep( 1000 );
				}

				Console.WriteLine( "SLEEP: Fiber [{0}] in thread [{1}] started at {2}", Fiber.Current, pthread_t.CurrentThread, DateTime.UtcNow );
				Fiber.Sleep( 1000 );
				Console.WriteLine( "SLEEP: Fiber [{0}] in thread [{1}] finished at {2}", Fiber.Current, pthread_t.CurrentThread, DateTime.UtcNow );

				eventLoop.RequestExit();
			}, "slp0" );

			Fiber.Start( Pages, () => {
				Console.WriteLine( "SLEEP: Fiber [{0}] in thread [{1}] started at {2}", Fiber.Current, pthread_t.CurrentThread, DateTime.UtcNow );
				Fiber.Sleep( 1000 );
				Console.WriteLine( "SLEEP: Fiber [{0}] in thread [{1}] finished at {2}", Fiber.Current, pthread_t.CurrentThread, DateTime.UtcNow );
			}, "slp1" );
			// @}

			// @{ move blocking code to thread pool
			Fiber.Start( Pages, () => {
				Console.WriteLine( "TP: Fiber [{0}] in thread [{1}] started", Fiber.Current, pthread_t.CurrentThread );

				using( new Fiber.AsyncCompletionRegion() ) { // following region executed in thread pool
					Console.WriteLine( "\tWorker thread [{0}] started", pthread_t.CurrentThread );
					pthread_t.Sleep( 1000 );

					Console.WriteLine( "\tWorker thread [{0}] finished", pthread_t.CurrentThread );
				}

				Console.WriteLine( "TP: Fiber [{0}] in thread [{1}] finished", Fiber.Current, pthread_t.CurrentThread );
			}, "tp0" );
			// @}

			eventLoop.Dispatch(); // wait until RequestExit
			// @}
		}
	}
}