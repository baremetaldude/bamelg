//
// Autogenerated by Thrift Compiler ( 0.9.0-dev ). Do not edit
//

using System;
using System.Collections;
using System.Serialization.Thrift;

namespace Apache.Cassandra {
	public static partial class Cassandra {
		public interface IApi {
			void login( AuthenticationRequest auth_request );
			void set_keyspace( Utf8String keyspace );
			/// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
			/// the only method that can throw an exception under non-failure conditions.)
			///
			/// \param key
			/// \param column_path
			/// \param consistency_level
			ColumnOrSuperColumn get( byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level );
			/// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
			/// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
			///
			/// \param key
			/// \param column_parent
			/// \param predicate
			/// \param consistency_level
			List<ColumnOrSuperColumn> get_slice( byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level );
			/// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
			/// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
			///
			/// \param key
			/// \param column_parent
			/// \param predicate
			/// \param consistency_level
			int get_count( byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level );
			/// Performs a get_slice for column_parent and predicate for the given keys in parallel.
			///
			/// \param keys
			/// \param column_parent
			/// \param predicate
			/// \param consistency_level
			Dictionary<byte[], List<ColumnOrSuperColumn>> multiget_slice( List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level );
			/// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
			///
			/// \param keys
			/// \param column_parent
			/// \param predicate
			/// \param consistency_level
			Dictionary<byte[], int> multiget_count( List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level );
			/// returns a subset of columns for a contiguous range of keys.
			///
			/// \param column_parent
			/// \param predicate
			/// \param range
			/// \param consistency_level
			List<KeySlice> get_range_slices( ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level );
			/// returns a range of columns, wrapping to the next rows if necessary to collect max_results.
			///
			/// \param column_family
			/// \param range
			/// \param start_column
			/// \param consistency_level
			List<KeySlice> get_paged_slice( Utf8String column_family, KeyRange range, byte[] start_column, ConsistencyLevel consistency_level );
			/// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
			/// @deprecated use get_range_slices instead with range.row_filter specified
			///
			/// \param column_parent
			/// \param index_clause
			/// \param column_predicate
			/// \param consistency_level
			List<KeySlice> get_indexed_slices( ColumnParent column_parent, IndexClause index_clause, SlicePredicate column_predicate, ConsistencyLevel consistency_level );
			/// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
			///
			/// \param key
			/// \param column_parent
			/// \param column
			/// \param consistency_level
			void insert( byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level );
			/// Increment or decrement a counter.
			///
			/// \param key
			/// \param column_parent
			/// \param column
			/// \param consistency_level
			void add( byte[] key, ColumnParent column_parent, CounterColumn column, ConsistencyLevel consistency_level );
			/// Atomic compare and set.
			///
			/// If the cas is successfull, the success boolean in CASResult will be true and there will be no current_values.
			/// Otherwise, success will be false and current_values will contain the current values for the columns in
			/// expected (that, by definition of compare-and-set, will differ from the values in expected).
			///
			/// A cas operation takes 2 consistency level. The first one, serial_consistency_level, simply indicates the
			/// level of serialization required. This can be either ConsistencyLevel.SERIAL or ConsistencyLevel.LOCAL_SERIAL.
			/// The second one, commit_consistency_level, defines the consistency level for the commit phase of the cas. This
			/// is a more traditional consistency level (the same CL than for traditional writes are accepted) that impact
			/// the visibility for reads of the operation. For instance, if commit_consistency_level is QUORUM, then it is
			/// guaranteed that a followup QUORUM read will see the cas write (if that one was successful obviously). If
			/// commit_consistency_level is ANY, you will need to use a SERIAL/LOCAL_SERIAL read to be guaranteed to see
			/// the write.
			///
			/// \param key
			/// \param column_family
			/// \param expected
			/// \param updates
			/// \param serial_consistency_level
			/// \param commit_consistency_level
			CASResult cas( byte[] key, Utf8String column_family, List<Column> expected, List<Column> updates, ConsistencyLevel serial_consistency_level, ConsistencyLevel commit_consistency_level );
			/// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
			/// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
			/// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
			///
			/// \param key
			/// \param column_path
			/// \param timestamp
			/// \param consistency_level
			void remove( byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level );
			/// Remove a counter at the specified location.
			/// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
			/// until the delete has reached all the nodes and all of them have been fully compacted.
			///
			/// \param key
			/// \param path
			/// \param consistency_level
			void remove_counter( byte[] key, ColumnPath path, ConsistencyLevel consistency_level );
			///   Mutate many columns or super columns for many row keys. See also: Mutation.
			///
			///   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
			/// *
			///
			/// \param mutation_map
			/// \param consistency_level
			void batch_mutate( Dictionary<byte[], Dictionary<Utf8String, List<Mutation>>> mutation_map, ConsistencyLevel consistency_level );
			///   Atomically mutate many columns or super columns for many row keys. See also: Mutation.
			///
			///   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
			/// *
			///
			/// \param mutation_map
			/// \param consistency_level
			void atomic_batch_mutate( Dictionary<byte[], Dictionary<Utf8String, List<Mutation>>> mutation_map, ConsistencyLevel consistency_level );
			/// Truncate will mark and entire column family as deleted.
			/// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
			/// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
			/// only marks the data as deleted.
			/// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
			/// some hosts are down.
			///
			/// \param cfname
			void truncate( Utf8String cfname );
			/// for each schema version present in the cluster, returns a list of nodes at that version.
			/// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
			/// the cluster is all on the same version if the size of the map is 1.
			Dictionary<Utf8String, List<Utf8String>> describe_schema_versions();
			/// list the defined keyspaces in this cluster
			List<KsDef> describe_keyspaces();
			/// get the cluster name
			Utf8String describe_cluster_name();
			/// get the thrift api version
			Utf8String describe_version();
			/// get the token ring: a map of ranges to host addresses,
			/// represented as a set of TokenRange instead of a map from range
			/// to list of endpoints, because you can't use Thrift structs as
			/// map keys:
			/// https://issues.apache.org/jira/browse/THRIFT-162
			///
			/// for the same reason, we can't return a set here, even though
			/// order is neither important nor predictable.
			///
			/// \param keyspace
			List<TokenRange> describe_ring( Utf8String keyspace );
			/// same as describe_ring, but considers only nodes in the local DC
			///
			/// \param keyspace
			List<TokenRange> describe_local_ring( Utf8String keyspace );
			/// get the mapping between token->node ip
			/// without taking replication into consideration
			/// https://issues.apache.org/jira/browse/CASSANDRA-4092
			Dictionary<Utf8String, Utf8String> describe_token_map();
			/// returns the partitioner used by this cluster
			Utf8String describe_partitioner();
			/// returns the snitch used by this cluster
			Utf8String describe_snitch();
			/// describe specified keyspace
			///
			/// \param keyspace
			KsDef describe_keyspace( Utf8String keyspace );
			/// experimental API for hadoop/parallel query support.
			/// may change violently and without warning.
			///
			/// returns list of token strings such that first subrange is (list[0], list[1]],
			/// next is (list[1], list[2]], etc.
			///
			/// \param cfName
			/// \param start_token
			/// \param end_token
			/// \param keys_per_split
			List<Utf8String> describe_splits( Utf8String cfName, Utf8String start_token, Utf8String end_token, int keys_per_split );
			/// Enables tracing for the next query in this connection and returns the UUID for that trace session
			/// The next query will be traced idependently of trace probability and the returned UUID can be used to query the trace keyspace
			byte[] trace_next_query();
			List<CfSplit> describe_splits_ex( Utf8String cfName, Utf8String start_token, Utf8String end_token, int keys_per_split );
			/// adds a column family. returns the new schema id.
			///
			/// \param cf_def
			Utf8String system_add_column_family( CfDef cf_def );
			/// drops a column family. returns the new schema id.
			///
			/// \param column_family
			Utf8String system_drop_column_family( Utf8String column_family );
			/// adds a keyspace and any column families that are part of it. returns the new schema id.
			///
			/// \param ks_def
			Utf8String system_add_keyspace( KsDef ks_def );
			/// drops a keyspace and any column families that are part of it. returns the new schema id.
			///
			/// \param keyspace
			Utf8String system_drop_keyspace( Utf8String keyspace );
			/// updates properties of a keyspace. returns the new schema id.
			///
			/// \param ks_def
			Utf8String system_update_keyspace( KsDef ks_def );
			/// updates properties of a column family. returns the new schema id.
			///
			/// \param cf_def
			Utf8String system_update_column_family( CfDef cf_def );
			/// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
			///
			/// \param query
			/// \param compression
			CqlResult execute_cql_query( byte[] query, Compression compression );
			/// Executes a CQL3 (Cassandra Query Language) statement and returns a
			/// CqlResult containing the results.
			///
			/// \param query
			/// \param compression
			/// \param consistency
			CqlResult execute_cql3_query( byte[] query, Compression compression, ConsistencyLevel consistency );
			/// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
			///
			/// \param query
			/// \param compression
			CqlPreparedResult prepare_cql_query( byte[] query, Compression compression );
			/// Prepare a CQL3 (Cassandra Query Language) statement by compiling and returning
			/// - the type of CQL statement
			/// - an id token of the compiled CQL stored on the server side.
			/// - a count of the discovered bound markers in the statement
			///
			/// \param query
			/// \param compression
			CqlPreparedResult prepare_cql3_query( byte[] query, Compression compression );
			/// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
			///
			/// \param itemId
			/// \param values
			CqlResult execute_prepared_cql_query( int itemId, List<byte[]> values );
			/// Executes a prepared CQL3 (Cassandra Query Language) statement by passing an id token, a list of variables
			/// to bind, and the consistency level, and returns a CqlResult containing the results.
			///
			/// \param itemId
			/// \param values
			/// \param consistency
			CqlResult execute_prepared_cql3_query( int itemId, List<byte[]> values, ConsistencyLevel consistency );
			/// @deprecated This is now a no-op. Please use the CQL3 specific methods instead.
			///
			/// \param version
			void set_cql_version( Utf8String version );
		}

		public interface IExceptionHandler : System.Serialization.Thrift.IExceptionHandler {
			void OnException( NotFoundException exception );
			void OnException( InvalidRequestException exception );
			void OnException( UnavailableException exception );
			void OnException( TimedOutException exception );
			void OnException( AuthenticationException exception );
			void OnException( AuthorizationException exception );
			void OnException( SchemaDisagreementException exception );
		}

		public struct ExceptionHandlerConsole : System.Serialization.Thrift.ExceptionHandlerConsole, IExceptionHandler {
			public static new readonly thistype Instance;

			public void OnException( NotFoundException exception ) { Console.WriteLine( exception ); }
			public void OnException( InvalidRequestException exception ) { Console.WriteLine( exception ); }
			public void OnException( UnavailableException exception ) { Console.WriteLine( exception ); }
			public void OnException( TimedOutException exception ) { Console.WriteLine( exception ); }
			public void OnException( AuthenticationException exception ) { Console.WriteLine( exception ); }
			public void OnException( AuthorizationException exception ) { Console.WriteLine( exception ); }
			public void OnException( SchemaDisagreementException exception ) { Console.WriteLine( exception ); }
		}

		public class Client : IApi {
			protected ProtocolCodec _reader, _writer;
			protected int _seqid;
			private IExceptionHandler _exceptionHandler = ExceptionHandlerConsole.Instance;
			public IExceptionHandler ExceptionHandler {
				get { return _exceptionHandler; }
				set { _exceptionHandler = value; }
			}


			public Client( ProtocolCodec prot )
				: this( prot, prot ) { }

			public Client( ProtocolCodec reader, ProtocolCodec writer ) {
				_reader = reader;
				_writer = writer;
			}

			public void login( AuthenticationRequest auth_request ) {
				_writer.WriteMessageBegin( "login", MessageInfo.Kind.Call, _seqid );
				var args = new login_args();
				args.Auth_request = auth_request;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return;
				}

				var result = new login_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.authnx ) { _exceptionHandler.OnException( result.Authnx ); return; }
				if( result.__isset.authzx ) { _exceptionHandler.OnException( result.Authzx ); return; }
				return;
			}

			public void set_keyspace( Utf8String keyspace ) {
				_writer.WriteMessageBegin( "set_keyspace", MessageInfo.Kind.Call, _seqid );
				var args = new set_keyspace_args();
				args.Keyspace = keyspace;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return;
				}

				var result = new set_keyspace_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return; }
				return;
			}

			/// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
			/// the only method that can throw an exception under non-failure conditions.)
			///
			/// \param key
			/// \param column_path
			/// \param consistency_level
			public ColumnOrSuperColumn get( byte[] key, ColumnPath column_path, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "get", MessageInfo.Kind.Call, _seqid );
				var args = new get_args();
				args.Key = key;
				args.Column_path = column_path;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( ColumnOrSuperColumn );
				}

				var result = new get_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( ColumnOrSuperColumn ); }
				if( result.__isset.nfe ) { _exceptionHandler.OnException( result.Nfe ); return default( ColumnOrSuperColumn ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( ColumnOrSuperColumn ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( ColumnOrSuperColumn ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( ColumnOrSuperColumn );
			}

			/// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
			/// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
			///
			/// \param key
			/// \param column_parent
			/// \param predicate
			/// \param consistency_level
			public List<ColumnOrSuperColumn> get_slice( byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "get_slice", MessageInfo.Kind.Call, _seqid );
				var args = new get_slice_args();
				args.Key = key;
				args.Column_parent = column_parent;
				args.Predicate = predicate;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( List<ColumnOrSuperColumn> );
				}

				var result = new get_slice_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( List<ColumnOrSuperColumn> ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( List<ColumnOrSuperColumn> ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( List<ColumnOrSuperColumn> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( List<ColumnOrSuperColumn> );
			}

			/// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
			/// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
			///
			/// \param key
			/// \param column_parent
			/// \param predicate
			/// \param consistency_level
			public int get_count( byte[] key, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "get_count", MessageInfo.Kind.Call, _seqid );
				var args = new get_count_args();
				args.Key = key;
				args.Column_parent = column_parent;
				args.Predicate = predicate;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( int );
				}

				var result = new get_count_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( int ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( int ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( int ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( int );
			}

			/// Performs a get_slice for column_parent and predicate for the given keys in parallel.
			///
			/// \param keys
			/// \param column_parent
			/// \param predicate
			/// \param consistency_level
			public Dictionary<byte[], List<ColumnOrSuperColumn>> multiget_slice( List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "multiget_slice", MessageInfo.Kind.Call, _seqid );
				var args = new multiget_slice_args();
				args.Keys = keys;
				args.Column_parent = column_parent;
				args.Predicate = predicate;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Dictionary<byte[], List<ColumnOrSuperColumn>> );
				}

				var result = new multiget_slice_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( Dictionary<byte[], List<ColumnOrSuperColumn>> ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( Dictionary<byte[], List<ColumnOrSuperColumn>> ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( Dictionary<byte[], List<ColumnOrSuperColumn>> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Dictionary<byte[], List<ColumnOrSuperColumn>> );
			}

			/// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
			///
			/// \param keys
			/// \param column_parent
			/// \param predicate
			/// \param consistency_level
			public Dictionary<byte[], int> multiget_count( List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "multiget_count", MessageInfo.Kind.Call, _seqid );
				var args = new multiget_count_args();
				args.Keys = keys;
				args.Column_parent = column_parent;
				args.Predicate = predicate;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Dictionary<byte[], int> );
				}

				var result = new multiget_count_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( Dictionary<byte[], int> ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( Dictionary<byte[], int> ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( Dictionary<byte[], int> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Dictionary<byte[], int> );
			}

			/// returns a subset of columns for a contiguous range of keys.
			///
			/// \param column_parent
			/// \param predicate
			/// \param range
			/// \param consistency_level
			public List<KeySlice> get_range_slices( ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "get_range_slices", MessageInfo.Kind.Call, _seqid );
				var args = new get_range_slices_args();
				args.Column_parent = column_parent;
				args.Predicate = predicate;
				args.Range = range;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( List<KeySlice> );
				}

				var result = new get_range_slices_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( List<KeySlice> ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( List<KeySlice> ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( List<KeySlice> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( List<KeySlice> );
			}

			/// returns a range of columns, wrapping to the next rows if necessary to collect max_results.
			///
			/// \param column_family
			/// \param range
			/// \param start_column
			/// \param consistency_level
			public List<KeySlice> get_paged_slice( Utf8String column_family, KeyRange range, byte[] start_column, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "get_paged_slice", MessageInfo.Kind.Call, _seqid );
				var args = new get_paged_slice_args();
				args.Column_family = column_family;
				args.Range = range;
				args.Start_column = start_column;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( List<KeySlice> );
				}

				var result = new get_paged_slice_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( List<KeySlice> ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( List<KeySlice> ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( List<KeySlice> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( List<KeySlice> );
			}

			/// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
			/// @deprecated use get_range_slices instead with range.row_filter specified
			///
			/// \param column_parent
			/// \param index_clause
			/// \param column_predicate
			/// \param consistency_level
			public List<KeySlice> get_indexed_slices( ColumnParent column_parent, IndexClause index_clause, SlicePredicate column_predicate, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "get_indexed_slices", MessageInfo.Kind.Call, _seqid );
				var args = new get_indexed_slices_args();
				args.Column_parent = column_parent;
				args.Index_clause = index_clause;
				args.Column_predicate = column_predicate;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( List<KeySlice> );
				}

				var result = new get_indexed_slices_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( List<KeySlice> ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( List<KeySlice> ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( List<KeySlice> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( List<KeySlice> );
			}

			/// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
			///
			/// \param key
			/// \param column_parent
			/// \param column
			/// \param consistency_level
			public void insert( byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "insert", MessageInfo.Kind.Call, _seqid );
				var args = new insert_args();
				args.Key = key;
				args.Column_parent = column_parent;
				args.Column = column;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return;
				}

				var result = new insert_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return; }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return; }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return; }
				return;
			}

			/// Increment or decrement a counter.
			///
			/// \param key
			/// \param column_parent
			/// \param column
			/// \param consistency_level
			public void add( byte[] key, ColumnParent column_parent, CounterColumn column, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "add", MessageInfo.Kind.Call, _seqid );
				var args = new add_args();
				args.Key = key;
				args.Column_parent = column_parent;
				args.Column = column;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return;
				}

				var result = new add_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return; }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return; }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return; }
				return;
			}

			/// Atomic compare and set.
			///
			/// If the cas is successfull, the success boolean in CASResult will be true and there will be no current_values.
			/// Otherwise, success will be false and current_values will contain the current values for the columns in
			/// expected (that, by definition of compare-and-set, will differ from the values in expected).
			///
			/// A cas operation takes 2 consistency level. The first one, serial_consistency_level, simply indicates the
			/// level of serialization required. This can be either ConsistencyLevel.SERIAL or ConsistencyLevel.LOCAL_SERIAL.
			/// The second one, commit_consistency_level, defines the consistency level for the commit phase of the cas. This
			/// is a more traditional consistency level (the same CL than for traditional writes are accepted) that impact
			/// the visibility for reads of the operation. For instance, if commit_consistency_level is QUORUM, then it is
			/// guaranteed that a followup QUORUM read will see the cas write (if that one was successful obviously). If
			/// commit_consistency_level is ANY, you will need to use a SERIAL/LOCAL_SERIAL read to be guaranteed to see
			/// the write.
			///
			/// \param key
			/// \param column_family
			/// \param expected
			/// \param updates
			/// \param serial_consistency_level
			/// \param commit_consistency_level
			public CASResult cas( byte[] key, Utf8String column_family, List<Column> expected, List<Column> updates, ConsistencyLevel serial_consistency_level, ConsistencyLevel commit_consistency_level ) {
				_writer.WriteMessageBegin( "cas", MessageInfo.Kind.Call, _seqid );
				var args = new cas_args();
				args.Key = key;
				args.Column_family = column_family;
				args.Expected = expected;
				args.Updates = updates;
				args.Serial_consistency_level = serial_consistency_level;
				args.Commit_consistency_level = commit_consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( CASResult );
				}

				var result = new cas_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( CASResult ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( CASResult ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( CASResult ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( CASResult );
			}

			/// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
			/// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
			/// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
			///
			/// \param key
			/// \param column_path
			/// \param timestamp
			/// \param consistency_level
			public void remove( byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "remove", MessageInfo.Kind.Call, _seqid );
				var args = new remove_args();
				args.Key = key;
				args.Column_path = column_path;
				args.Timestamp = timestamp;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return;
				}

				var result = new remove_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return; }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return; }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return; }
				return;
			}

			/// Remove a counter at the specified location.
			/// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
			/// until the delete has reached all the nodes and all of them have been fully compacted.
			///
			/// \param key
			/// \param path
			/// \param consistency_level
			public void remove_counter( byte[] key, ColumnPath path, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "remove_counter", MessageInfo.Kind.Call, _seqid );
				var args = new remove_counter_args();
				args.Key = key;
				args.Path = path;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return;
				}

				var result = new remove_counter_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return; }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return; }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return; }
				return;
			}

			///   Mutate many columns or super columns for many row keys. See also: Mutation.
			///
			///   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
			/// *
			///
			/// \param mutation_map
			/// \param consistency_level
			public void batch_mutate( Dictionary<byte[], Dictionary<Utf8String, List<Mutation>>> mutation_map, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "batch_mutate", MessageInfo.Kind.Call, _seqid );
				var args = new batch_mutate_args();
				args.Mutation_map = mutation_map;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return;
				}

				var result = new batch_mutate_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return; }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return; }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return; }
				return;
			}

			///   Atomically mutate many columns or super columns for many row keys. See also: Mutation.
			///
			///   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
			/// *
			///
			/// \param mutation_map
			/// \param consistency_level
			public void atomic_batch_mutate( Dictionary<byte[], Dictionary<Utf8String, List<Mutation>>> mutation_map, ConsistencyLevel consistency_level ) {
				_writer.WriteMessageBegin( "atomic_batch_mutate", MessageInfo.Kind.Call, _seqid );
				var args = new atomic_batch_mutate_args();
				args.Mutation_map = mutation_map;
				args.Consistency_level = consistency_level;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return;
				}

				var result = new atomic_batch_mutate_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return; }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return; }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return; }
				return;
			}

			/// Truncate will mark and entire column family as deleted.
			/// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
			/// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
			/// only marks the data as deleted.
			/// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
			/// some hosts are down.
			///
			/// \param cfname
			public void truncate( Utf8String cfname ) {
				_writer.WriteMessageBegin( "truncate", MessageInfo.Kind.Call, _seqid );
				var args = new truncate_args();
				args.Cfname = cfname;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return;
				}

				var result = new truncate_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return; }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return; }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return; }
				return;
			}

			/// for each schema version present in the cluster, returns a list of nodes at that version.
			/// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
			/// the cluster is all on the same version if the size of the map is 1.
			public Dictionary<Utf8String, List<Utf8String>> describe_schema_versions() {
				_writer.WriteMessageBegin( "describe_schema_versions", MessageInfo.Kind.Call, _seqid );
				var args = new describe_schema_versions_args();
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Dictionary<Utf8String, List<Utf8String>> );
				}

				var result = new describe_schema_versions_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( Dictionary<Utf8String, List<Utf8String>> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Dictionary<Utf8String, List<Utf8String>> );
			}

			/// list the defined keyspaces in this cluster
			public List<KsDef> describe_keyspaces() {
				_writer.WriteMessageBegin( "describe_keyspaces", MessageInfo.Kind.Call, _seqid );
				var args = new describe_keyspaces_args();
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( List<KsDef> );
				}

				var result = new describe_keyspaces_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( List<KsDef> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( List<KsDef> );
			}

			/// get the cluster name
			public Utf8String describe_cluster_name() {
				_writer.WriteMessageBegin( "describe_cluster_name", MessageInfo.Kind.Call, _seqid );
				var args = new describe_cluster_name_args();
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Utf8String );
				}

				var result = new describe_cluster_name_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Utf8String );
			}

			/// get the thrift api version
			public Utf8String describe_version() {
				_writer.WriteMessageBegin( "describe_version", MessageInfo.Kind.Call, _seqid );
				var args = new describe_version_args();
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Utf8String );
				}

				var result = new describe_version_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Utf8String );
			}

			/// get the token ring: a map of ranges to host addresses,
			/// represented as a set of TokenRange instead of a map from range
			/// to list of endpoints, because you can't use Thrift structs as
			/// map keys:
			/// https://issues.apache.org/jira/browse/THRIFT-162
			///
			/// for the same reason, we can't return a set here, even though
			/// order is neither important nor predictable.
			///
			/// \param keyspace
			public List<TokenRange> describe_ring( Utf8String keyspace ) {
				_writer.WriteMessageBegin( "describe_ring", MessageInfo.Kind.Call, _seqid );
				var args = new describe_ring_args();
				args.Keyspace = keyspace;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( List<TokenRange> );
				}

				var result = new describe_ring_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( List<TokenRange> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( List<TokenRange> );
			}

			/// same as describe_ring, but considers only nodes in the local DC
			///
			/// \param keyspace
			public List<TokenRange> describe_local_ring( Utf8String keyspace ) {
				_writer.WriteMessageBegin( "describe_local_ring", MessageInfo.Kind.Call, _seqid );
				var args = new describe_local_ring_args();
				args.Keyspace = keyspace;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( List<TokenRange> );
				}

				var result = new describe_local_ring_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( List<TokenRange> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( List<TokenRange> );
			}

			/// get the mapping between token->node ip
			/// without taking replication into consideration
			/// https://issues.apache.org/jira/browse/CASSANDRA-4092
			public Dictionary<Utf8String, Utf8String> describe_token_map() {
				_writer.WriteMessageBegin( "describe_token_map", MessageInfo.Kind.Call, _seqid );
				var args = new describe_token_map_args();
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Dictionary<Utf8String, Utf8String> );
				}

				var result = new describe_token_map_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( Dictionary<Utf8String, Utf8String> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Dictionary<Utf8String, Utf8String> );
			}

			/// returns the partitioner used by this cluster
			public Utf8String describe_partitioner() {
				_writer.WriteMessageBegin( "describe_partitioner", MessageInfo.Kind.Call, _seqid );
				var args = new describe_partitioner_args();
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Utf8String );
				}

				var result = new describe_partitioner_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Utf8String );
			}

			/// returns the snitch used by this cluster
			public Utf8String describe_snitch() {
				_writer.WriteMessageBegin( "describe_snitch", MessageInfo.Kind.Call, _seqid );
				var args = new describe_snitch_args();
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Utf8String );
				}

				var result = new describe_snitch_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Utf8String );
			}

			/// describe specified keyspace
			///
			/// \param keyspace
			public KsDef describe_keyspace( Utf8String keyspace ) {
				_writer.WriteMessageBegin( "describe_keyspace", MessageInfo.Kind.Call, _seqid );
				var args = new describe_keyspace_args();
				args.Keyspace = keyspace;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( KsDef );
				}

				var result = new describe_keyspace_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.nfe ) { _exceptionHandler.OnException( result.Nfe ); return default( KsDef ); }
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( KsDef ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( KsDef );
			}

			/// experimental API for hadoop/parallel query support.
			/// may change violently and without warning.
			///
			/// returns list of token strings such that first subrange is (list[0], list[1]],
			/// next is (list[1], list[2]], etc.
			///
			/// \param cfName
			/// \param start_token
			/// \param end_token
			/// \param keys_per_split
			public List<Utf8String> describe_splits( Utf8String cfName, Utf8String start_token, Utf8String end_token, int keys_per_split ) {
				_writer.WriteMessageBegin( "describe_splits", MessageInfo.Kind.Call, _seqid );
				var args = new describe_splits_args();
				args.CfName = cfName;
				args.Start_token = start_token;
				args.End_token = end_token;
				args.Keys_per_split = keys_per_split;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( List<Utf8String> );
				}

				var result = new describe_splits_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( List<Utf8String> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( List<Utf8String> );
			}

			/// Enables tracing for the next query in this connection and returns the UUID for that trace session
			/// The next query will be traced idependently of trace probability and the returned UUID can be used to query the trace keyspace
			public byte[] trace_next_query() {
				_writer.WriteMessageBegin( "trace_next_query", MessageInfo.Kind.Call, _seqid );
				var args = new trace_next_query_args();
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( byte[] );
				}

				var result = new trace_next_query_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( byte[] );
			}

			public List<CfSplit> describe_splits_ex( Utf8String cfName, Utf8String start_token, Utf8String end_token, int keys_per_split ) {
				_writer.WriteMessageBegin( "describe_splits_ex", MessageInfo.Kind.Call, _seqid );
				var args = new describe_splits_ex_args();
				args.CfName = cfName;
				args.Start_token = start_token;
				args.End_token = end_token;
				args.Keys_per_split = keys_per_split;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( List<CfSplit> );
				}

				var result = new describe_splits_ex_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( List<CfSplit> ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( List<CfSplit> );
			}

			/// adds a column family. returns the new schema id.
			///
			/// \param cf_def
			public Utf8String system_add_column_family( CfDef cf_def ) {
				_writer.WriteMessageBegin( "system_add_column_family", MessageInfo.Kind.Call, _seqid );
				var args = new system_add_column_family_args();
				args.Cf_def = cf_def;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Utf8String );
				}

				var result = new system_add_column_family_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( Utf8String ); }
				if( result.__isset.sde ) { _exceptionHandler.OnException( result.Sde ); return default( Utf8String ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Utf8String );
			}

			/// drops a column family. returns the new schema id.
			///
			/// \param column_family
			public Utf8String system_drop_column_family( Utf8String column_family ) {
				_writer.WriteMessageBegin( "system_drop_column_family", MessageInfo.Kind.Call, _seqid );
				var args = new system_drop_column_family_args();
				args.Column_family = column_family;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Utf8String );
				}

				var result = new system_drop_column_family_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( Utf8String ); }
				if( result.__isset.sde ) { _exceptionHandler.OnException( result.Sde ); return default( Utf8String ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Utf8String );
			}

			/// adds a keyspace and any column families that are part of it. returns the new schema id.
			///
			/// \param ks_def
			public Utf8String system_add_keyspace( KsDef ks_def ) {
				_writer.WriteMessageBegin( "system_add_keyspace", MessageInfo.Kind.Call, _seqid );
				var args = new system_add_keyspace_args();
				args.Ks_def = ks_def;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Utf8String );
				}

				var result = new system_add_keyspace_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( Utf8String ); }
				if( result.__isset.sde ) { _exceptionHandler.OnException( result.Sde ); return default( Utf8String ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Utf8String );
			}

			/// drops a keyspace and any column families that are part of it. returns the new schema id.
			///
			/// \param keyspace
			public Utf8String system_drop_keyspace( Utf8String keyspace ) {
				_writer.WriteMessageBegin( "system_drop_keyspace", MessageInfo.Kind.Call, _seqid );
				var args = new system_drop_keyspace_args();
				args.Keyspace = keyspace;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Utf8String );
				}

				var result = new system_drop_keyspace_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( Utf8String ); }
				if( result.__isset.sde ) { _exceptionHandler.OnException( result.Sde ); return default( Utf8String ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Utf8String );
			}

			/// updates properties of a keyspace. returns the new schema id.
			///
			/// \param ks_def
			public Utf8String system_update_keyspace( KsDef ks_def ) {
				_writer.WriteMessageBegin( "system_update_keyspace", MessageInfo.Kind.Call, _seqid );
				var args = new system_update_keyspace_args();
				args.Ks_def = ks_def;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Utf8String );
				}

				var result = new system_update_keyspace_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( Utf8String ); }
				if( result.__isset.sde ) { _exceptionHandler.OnException( result.Sde ); return default( Utf8String ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Utf8String );
			}

			/// updates properties of a column family. returns the new schema id.
			///
			/// \param cf_def
			public Utf8String system_update_column_family( CfDef cf_def ) {
				_writer.WriteMessageBegin( "system_update_column_family", MessageInfo.Kind.Call, _seqid );
				var args = new system_update_column_family_args();
				args.Cf_def = cf_def;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( Utf8String );
				}

				var result = new system_update_column_family_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( Utf8String ); }
				if( result.__isset.sde ) { _exceptionHandler.OnException( result.Sde ); return default( Utf8String ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( Utf8String );
			}

			/// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
			///
			/// \param query
			/// \param compression
			public CqlResult execute_cql_query( byte[] query, Compression compression ) {
				_writer.WriteMessageBegin( "execute_cql_query", MessageInfo.Kind.Call, _seqid );
				var args = new execute_cql_query_args();
				args.Query = query;
				args.Compression = compression;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( CqlResult );
				}

				var result = new execute_cql_query_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( CqlResult ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( CqlResult ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( CqlResult ); }
				if( result.__isset.sde ) { _exceptionHandler.OnException( result.Sde ); return default( CqlResult ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( CqlResult );
			}

			/// Executes a CQL3 (Cassandra Query Language) statement and returns a
			/// CqlResult containing the results.
			///
			/// \param query
			/// \param compression
			/// \param consistency
			public CqlResult execute_cql3_query( byte[] query, Compression compression, ConsistencyLevel consistency ) {
				_writer.WriteMessageBegin( "execute_cql3_query", MessageInfo.Kind.Call, _seqid );
				var args = new execute_cql3_query_args();
				args.Query = query;
				args.Compression = compression;
				args.Consistency = consistency;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( CqlResult );
				}

				var result = new execute_cql3_query_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( CqlResult ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( CqlResult ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( CqlResult ); }
				if( result.__isset.sde ) { _exceptionHandler.OnException( result.Sde ); return default( CqlResult ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( CqlResult );
			}

			/// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
			///
			/// \param query
			/// \param compression
			public CqlPreparedResult prepare_cql_query( byte[] query, Compression compression ) {
				_writer.WriteMessageBegin( "prepare_cql_query", MessageInfo.Kind.Call, _seqid );
				var args = new prepare_cql_query_args();
				args.Query = query;
				args.Compression = compression;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( CqlPreparedResult );
				}

				var result = new prepare_cql_query_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( CqlPreparedResult ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( CqlPreparedResult );
			}

			/// Prepare a CQL3 (Cassandra Query Language) statement by compiling and returning
			/// - the type of CQL statement
			/// - an id token of the compiled CQL stored on the server side.
			/// - a count of the discovered bound markers in the statement
			///
			/// \param query
			/// \param compression
			public CqlPreparedResult prepare_cql3_query( byte[] query, Compression compression ) {
				_writer.WriteMessageBegin( "prepare_cql3_query", MessageInfo.Kind.Call, _seqid );
				var args = new prepare_cql3_query_args();
				args.Query = query;
				args.Compression = compression;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( CqlPreparedResult );
				}

				var result = new prepare_cql3_query_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( CqlPreparedResult ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( CqlPreparedResult );
			}

			/// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
			///
			/// \param itemId
			/// \param values
			public CqlResult execute_prepared_cql_query( int itemId, List<byte[]> values ) {
				_writer.WriteMessageBegin( "execute_prepared_cql_query", MessageInfo.Kind.Call, _seqid );
				var args = new execute_prepared_cql_query_args();
				args.ItemId = itemId;
				args.Values = values;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( CqlResult );
				}

				var result = new execute_prepared_cql_query_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( CqlResult ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( CqlResult ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( CqlResult ); }
				if( result.__isset.sde ) { _exceptionHandler.OnException( result.Sde ); return default( CqlResult ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( CqlResult );
			}

			/// Executes a prepared CQL3 (Cassandra Query Language) statement by passing an id token, a list of variables
			/// to bind, and the consistency level, and returns a CqlResult containing the results.
			///
			/// \param itemId
			/// \param values
			/// \param consistency
			public CqlResult execute_prepared_cql3_query( int itemId, List<byte[]> values, ConsistencyLevel consistency ) {
				_writer.WriteMessageBegin( "execute_prepared_cql3_query", MessageInfo.Kind.Call, _seqid );
				var args = new execute_prepared_cql3_query_args();
				args.ItemId = itemId;
				args.Values = values;
				args.Consistency = consistency;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return default( CqlResult );
				}

				var result = new execute_prepared_cql3_query_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.success ) return result.Success;
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return default( CqlResult ); }
				if( result.__isset.ue ) { _exceptionHandler.OnException( result.Ue ); return default( CqlResult ); }
				if( result.__isset.te ) { _exceptionHandler.OnException( result.Te ); return default( CqlResult ); }
				if( result.__isset.sde ) { _exceptionHandler.OnException( result.Sde ); return default( CqlResult ); }
				_exceptionHandler.OnException( new ServerException( ServerException.Kind.MissingResult ) );
				return default( CqlResult );
			}

			/// @deprecated This is now a no-op. Please use the CQL3 specific methods instead.
			///
			/// \param version
			public void set_cql_version( Utf8String version ) {
				_writer.WriteMessageBegin( "set_cql_version", MessageInfo.Kind.Call, _seqid );
				var args = new set_cql_version_args();
				args.Version = version;
				args.Write( _writer );
				_writer.WriteMessageEnd();

				var msg = _reader.ReadMessageBegin();
				if( msg.Type == MessageInfo.Kind.Exception ) {
					var x = ServerException.Read( _reader );
					_reader.ReadMessageEnd();
					_exceptionHandler.OnException( x );
					return;
				}

				var result = new set_cql_version_result();
				result.Read( _reader );
				_reader.ReadMessageEnd();
				if( result.__isset.ire ) { _exceptionHandler.OnException( result.Ire ); return; }
				return;
			}
		}

		public class RequestHandler : IRequestHandler {
			protected uint _pendingException = 0;
			public void OnException( ServerException exception ) { }
			public void OnException( ProtocolError exception ) { }

			public RequestHandler( IApi @delegate ) {
				_delegate = @delegate;
			}

			private IApi _delegate;

			public bool Process( ProtocolCodec reader, ProtocolCodec writer ) {
				var msg = reader.ReadMessageBegin();
				if( msg.Name == null ) return false;
				switch( msg.Name ) {
					case "add": add_Process( msg.SeqID, reader, writer ); return true;
					case "atomic_batch_mutate": atomic_batch_mutate_Process( msg.SeqID, reader, writer ); return true;
					case "batch_mutate": batch_mutate_Process( msg.SeqID, reader, writer ); return true;
					case "cas": cas_Process( msg.SeqID, reader, writer ); return true;
					case "describe_cluster_name": describe_cluster_name_Process( msg.SeqID, reader, writer ); return true;
					case "describe_keyspace": describe_keyspace_Process( msg.SeqID, reader, writer ); return true;
					case "describe_keyspaces": describe_keyspaces_Process( msg.SeqID, reader, writer ); return true;
					case "describe_local_ring": describe_local_ring_Process( msg.SeqID, reader, writer ); return true;
					case "describe_partitioner": describe_partitioner_Process( msg.SeqID, reader, writer ); return true;
					case "describe_ring": describe_ring_Process( msg.SeqID, reader, writer ); return true;
					case "describe_schema_versions": describe_schema_versions_Process( msg.SeqID, reader, writer ); return true;
					case "describe_snitch": describe_snitch_Process( msg.SeqID, reader, writer ); return true;
					case "describe_splits": describe_splits_Process( msg.SeqID, reader, writer ); return true;
					case "describe_splits_ex": describe_splits_ex_Process( msg.SeqID, reader, writer ); return true;
					case "describe_token_map": describe_token_map_Process( msg.SeqID, reader, writer ); return true;
					case "describe_version": describe_version_Process( msg.SeqID, reader, writer ); return true;
					case "execute_cql3_query": execute_cql3_query_Process( msg.SeqID, reader, writer ); return true;
					case "execute_cql_query": execute_cql_query_Process( msg.SeqID, reader, writer ); return true;
					case "execute_prepared_cql3_query": execute_prepared_cql3_query_Process( msg.SeqID, reader, writer ); return true;
					case "execute_prepared_cql_query": execute_prepared_cql_query_Process( msg.SeqID, reader, writer ); return true;
					case "get": get_Process( msg.SeqID, reader, writer ); return true;
					case "get_count": get_count_Process( msg.SeqID, reader, writer ); return true;
					case "get_indexed_slices": get_indexed_slices_Process( msg.SeqID, reader, writer ); return true;
					case "get_paged_slice": get_paged_slice_Process( msg.SeqID, reader, writer ); return true;
					case "get_range_slices": get_range_slices_Process( msg.SeqID, reader, writer ); return true;
					case "get_slice": get_slice_Process( msg.SeqID, reader, writer ); return true;
					case "insert": insert_Process( msg.SeqID, reader, writer ); return true;
					case "login": login_Process( msg.SeqID, reader, writer ); return true;
					case "multiget_count": multiget_count_Process( msg.SeqID, reader, writer ); return true;
					case "multiget_slice": multiget_slice_Process( msg.SeqID, reader, writer ); return true;
					case "prepare_cql3_query": prepare_cql3_query_Process( msg.SeqID, reader, writer ); return true;
					case "prepare_cql_query": prepare_cql_query_Process( msg.SeqID, reader, writer ); return true;
					case "remove": remove_Process( msg.SeqID, reader, writer ); return true;
					case "remove_counter": remove_counter_Process( msg.SeqID, reader, writer ); return true;
					case "set_cql_version": set_cql_version_Process( msg.SeqID, reader, writer ); return true;
					case "set_keyspace": set_keyspace_Process( msg.SeqID, reader, writer ); return true;
					case "system_add_column_family": system_add_column_family_Process( msg.SeqID, reader, writer ); return true;
					case "system_add_keyspace": system_add_keyspace_Process( msg.SeqID, reader, writer ); return true;
					case "system_drop_column_family": system_drop_column_family_Process( msg.SeqID, reader, writer ); return true;
					case "system_drop_keyspace": system_drop_keyspace_Process( msg.SeqID, reader, writer ); return true;
					case "system_update_column_family": system_update_column_family_Process( msg.SeqID, reader, writer ); return true;
					case "system_update_keyspace": system_update_keyspace_Process( msg.SeqID, reader, writer ); return true;
					case "trace_next_query": trace_next_query_Process( msg.SeqID, reader, writer ); return true;
					case "truncate": truncate_Process( msg.SeqID, reader, writer ); return true;

					default: {
							reader.Skip( TypeKind.Struct );
							reader.ReadMessageEnd();
							var x = new ServerException( ServerException.Kind.UnknownMethod, msg.Name );
							writer.WriteMessageBegin( msg.Name, MessageInfo.Kind.Exception, msg.SeqID );
							x.Write( writer );
							writer.WriteMessageEnd();
							return true;
						}
				}
			}

			protected NotFoundException _pendingNotFoundException;
			public void SendException( NotFoundException exception ) {
				_pendingException = 4;
				_pendingNotFoundException = exception;
			}

			protected InvalidRequestException _pendingInvalidRequestException;
			public void SendException( InvalidRequestException exception ) {
				_pendingException = 3;
				_pendingInvalidRequestException = exception;
			}

			protected UnavailableException _pendingUnavailableException;
			public void SendException( UnavailableException exception ) {
				_pendingException = 5;
				_pendingUnavailableException = exception;
			}

			protected TimedOutException _pendingTimedOutException;
			public void SendException( TimedOutException exception ) {
				_pendingException = 6;
				_pendingTimedOutException = exception;
			}

			protected AuthenticationException _pendingAuthenticationException;
			public void SendException( AuthenticationException exception ) {
				_pendingException = 1;
				_pendingAuthenticationException = exception;
			}

			protected AuthorizationException _pendingAuthorizationException;
			public void SendException( AuthorizationException exception ) {
				_pendingException = 2;
				_pendingAuthorizationException = exception;
			}

			protected SchemaDisagreementException _pendingSchemaDisagreementException;
			public void SendException( SchemaDisagreementException exception ) {
				_pendingException = 7;
				_pendingSchemaDisagreementException = exception;
			}

			protected void login_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new login_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new login_result();
				_delegate.login( args.Auth_request );
				switch( _pendingException ) {
					case 1: result.Authnx = _pendingAuthenticationException; break;
					case 2: result.Authzx = _pendingAuthorizationException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "login", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void set_keyspace_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new set_keyspace_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new set_keyspace_result();
				_delegate.set_keyspace( args.Keyspace );
				switch( _pendingException ) {
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "set_keyspace", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void get_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new get_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new get_result();
				var success = _delegate.get( args.Key, args.Column_path, args.Consistency_level );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 4: result.Nfe = _pendingNotFoundException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "get", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void get_slice_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new get_slice_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new get_slice_result();
				var success = _delegate.get_slice( args.Key, args.Column_parent, args.Predicate, args.Consistency_level );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "get_slice", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void get_count_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new get_count_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new get_count_result();
				var success = _delegate.get_count( args.Key, args.Column_parent, args.Predicate, args.Consistency_level );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "get_count", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void multiget_slice_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new multiget_slice_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new multiget_slice_result();
				var success = _delegate.multiget_slice( args.Keys, args.Column_parent, args.Predicate, args.Consistency_level );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "multiget_slice", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void multiget_count_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new multiget_count_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new multiget_count_result();
				var success = _delegate.multiget_count( args.Keys, args.Column_parent, args.Predicate, args.Consistency_level );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "multiget_count", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void get_range_slices_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new get_range_slices_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new get_range_slices_result();
				var success = _delegate.get_range_slices( args.Column_parent, args.Predicate, args.Range, args.Consistency_level );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "get_range_slices", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void get_paged_slice_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new get_paged_slice_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new get_paged_slice_result();
				var success = _delegate.get_paged_slice( args.Column_family, args.Range, args.Start_column, args.Consistency_level );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "get_paged_slice", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void get_indexed_slices_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new get_indexed_slices_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new get_indexed_slices_result();
				var success = _delegate.get_indexed_slices( args.Column_parent, args.Index_clause, args.Column_predicate, args.Consistency_level );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "get_indexed_slices", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void insert_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new insert_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new insert_result();
				_delegate.insert( args.Key, args.Column_parent, args.Column, args.Consistency_level );
				switch( _pendingException ) {
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "insert", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void add_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new add_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new add_result();
				_delegate.add( args.Key, args.Column_parent, args.Column, args.Consistency_level );
				switch( _pendingException ) {
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "add", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void cas_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new cas_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new cas_result();
				var success = _delegate.cas( args.Key, args.Column_family, args.Expected, args.Updates, args.Serial_consistency_level, args.Commit_consistency_level );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "cas", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void remove_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new remove_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new remove_result();
				_delegate.remove( args.Key, args.Column_path, args.Timestamp, args.Consistency_level );
				switch( _pendingException ) {
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "remove", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void remove_counter_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new remove_counter_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new remove_counter_result();
				_delegate.remove_counter( args.Key, args.Path, args.Consistency_level );
				switch( _pendingException ) {
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "remove_counter", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void batch_mutate_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new batch_mutate_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new batch_mutate_result();
				_delegate.batch_mutate( args.Mutation_map, args.Consistency_level );
				switch( _pendingException ) {
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "batch_mutate", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void atomic_batch_mutate_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new atomic_batch_mutate_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new atomic_batch_mutate_result();
				_delegate.atomic_batch_mutate( args.Mutation_map, args.Consistency_level );
				switch( _pendingException ) {
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "atomic_batch_mutate", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void truncate_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new truncate_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new truncate_result();
				_delegate.truncate( args.Cfname );
				switch( _pendingException ) {
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "truncate", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_schema_versions_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_schema_versions_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_schema_versions_result();
				var success = _delegate.describe_schema_versions();
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "describe_schema_versions", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_keyspaces_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_keyspaces_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_keyspaces_result();
				var success = _delegate.describe_keyspaces();
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "describe_keyspaces", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_cluster_name_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_cluster_name_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_cluster_name_result();
				result.Success = _delegate.describe_cluster_name();
				writer.WriteMessageBegin( "describe_cluster_name", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_version_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_version_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_version_result();
				result.Success = _delegate.describe_version();
				writer.WriteMessageBegin( "describe_version", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_ring_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_ring_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_ring_result();
				var success = _delegate.describe_ring( args.Keyspace );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "describe_ring", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_local_ring_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_local_ring_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_local_ring_result();
				var success = _delegate.describe_local_ring( args.Keyspace );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "describe_local_ring", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_token_map_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_token_map_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_token_map_result();
				var success = _delegate.describe_token_map();
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "describe_token_map", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_partitioner_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_partitioner_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_partitioner_result();
				result.Success = _delegate.describe_partitioner();
				writer.WriteMessageBegin( "describe_partitioner", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_snitch_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_snitch_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_snitch_result();
				result.Success = _delegate.describe_snitch();
				writer.WriteMessageBegin( "describe_snitch", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_keyspace_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_keyspace_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_keyspace_result();
				var success = _delegate.describe_keyspace( args.Keyspace );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 4: result.Nfe = _pendingNotFoundException; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "describe_keyspace", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_splits_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_splits_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_splits_result();
				var success = _delegate.describe_splits( args.CfName, args.Start_token, args.End_token, args.Keys_per_split );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "describe_splits", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void trace_next_query_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new trace_next_query_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new trace_next_query_result();
				result.Success = _delegate.trace_next_query();
				writer.WriteMessageBegin( "trace_next_query", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void describe_splits_ex_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new describe_splits_ex_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new describe_splits_ex_result();
				var success = _delegate.describe_splits_ex( args.CfName, args.Start_token, args.End_token, args.Keys_per_split );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "describe_splits_ex", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void system_add_column_family_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new system_add_column_family_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new system_add_column_family_result();
				var success = _delegate.system_add_column_family( args.Cf_def );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 7: result.Sde = _pendingSchemaDisagreementException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "system_add_column_family", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void system_drop_column_family_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new system_drop_column_family_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new system_drop_column_family_result();
				var success = _delegate.system_drop_column_family( args.Column_family );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 7: result.Sde = _pendingSchemaDisagreementException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "system_drop_column_family", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void system_add_keyspace_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new system_add_keyspace_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new system_add_keyspace_result();
				var success = _delegate.system_add_keyspace( args.Ks_def );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 7: result.Sde = _pendingSchemaDisagreementException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "system_add_keyspace", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void system_drop_keyspace_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new system_drop_keyspace_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new system_drop_keyspace_result();
				var success = _delegate.system_drop_keyspace( args.Keyspace );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 7: result.Sde = _pendingSchemaDisagreementException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "system_drop_keyspace", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void system_update_keyspace_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new system_update_keyspace_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new system_update_keyspace_result();
				var success = _delegate.system_update_keyspace( args.Ks_def );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 7: result.Sde = _pendingSchemaDisagreementException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "system_update_keyspace", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void system_update_column_family_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new system_update_column_family_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new system_update_column_family_result();
				var success = _delegate.system_update_column_family( args.Cf_def );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 7: result.Sde = _pendingSchemaDisagreementException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "system_update_column_family", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void execute_cql_query_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new execute_cql_query_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new execute_cql_query_result();
				var success = _delegate.execute_cql_query( args.Query, args.Compression );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
					case 7: result.Sde = _pendingSchemaDisagreementException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "execute_cql_query", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void execute_cql3_query_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new execute_cql3_query_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new execute_cql3_query_result();
				var success = _delegate.execute_cql3_query( args.Query, args.Compression, args.Consistency );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
					case 7: result.Sde = _pendingSchemaDisagreementException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "execute_cql3_query", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void prepare_cql_query_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new prepare_cql_query_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new prepare_cql_query_result();
				var success = _delegate.prepare_cql_query( args.Query, args.Compression );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "prepare_cql_query", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void prepare_cql3_query_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new prepare_cql3_query_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new prepare_cql3_query_result();
				var success = _delegate.prepare_cql3_query( args.Query, args.Compression );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "prepare_cql3_query", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void execute_prepared_cql_query_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new execute_prepared_cql_query_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new execute_prepared_cql_query_result();
				var success = _delegate.execute_prepared_cql_query( args.ItemId, args.Values );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
					case 7: result.Sde = _pendingSchemaDisagreementException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "execute_prepared_cql_query", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void execute_prepared_cql3_query_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new execute_prepared_cql3_query_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new execute_prepared_cql3_query_result();
				var success = _delegate.execute_prepared_cql3_query( args.ItemId, args.Values, args.Consistency );
				switch( _pendingException ) {
					case 0: result.Success = success; break;
					case 3: result.Ire = _pendingInvalidRequestException; break;
					case 5: result.Ue = _pendingUnavailableException; break;
					case 6: result.Te = _pendingTimedOutException; break;
					case 7: result.Sde = _pendingSchemaDisagreementException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "execute_prepared_cql3_query", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}

			protected void set_cql_version_Process( int seqid, ProtocolCodec reader, ProtocolCodec writer ) {
				var args = new set_cql_version_args();
				args.Read( reader );
				reader.ReadMessageEnd();

				var result = new set_cql_version_result();
				_delegate.set_cql_version( args.Version );
				switch( _pendingException ) {
					case 3: result.Ire = _pendingInvalidRequestException; break;
				}
				_pendingException = 0;
				writer.WriteMessageBegin( "set_cql_version", MessageInfo.Kind.Reply, seqid );
				result.Write( writer );
				writer.WriteMessageEnd();
			}
		}
		public partial struct login_args : IFormattable {
			private AuthenticationRequest _auth_request;

			public AuthenticationRequest Auth_request { get { return _auth_request; } set { __isset.auth_request = true; _auth_request = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool auth_request { get; set; }
			}

			public login_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Auth_request = new AuthenticationRequest();
								Auth_request.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "login_args" );
				if( Auth_request != null && __isset.auth_request ) {
					writer.WriteFieldBegin( "auth_request", TypeKind.Struct, 1 );
					_auth_request.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Auth_request: ", Auth_request );
			}
		}
		public partial struct login_result : IFormattable {
			private AuthenticationException _authnx;
			private AuthorizationException _authzx;

			public AuthenticationException Authnx { get { return _authnx; } set { __isset.authnx = true; _authnx = value; } }
			public AuthorizationException Authzx { get { return _authzx; } set { __isset.authzx = true; _authzx = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool authnx { get; set; }
				public bool authzx { get; set; }
			}

			public login_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Authnx = new AuthenticationException();
								Authnx.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Authzx = new AuthorizationException();
								Authzx.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "login_result" );

				if( __isset.authnx ) {
					writer.WriteFieldBegin( "Authnx", TypeKind.Struct, 1 );
					_authnx.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.authzx ) {
					writer.WriteFieldBegin( "Authzx", TypeKind.Struct, 2 );
					_authzx.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Authnx: ", Authnx, " Authzx: ", Authzx );
			}
		}
		public partial struct set_keyspace_args : IFormattable {
			private Utf8String _keyspace;

			public Utf8String Keyspace { get { return _keyspace; } set { __isset.keyspace = true; _keyspace = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool keyspace { get; set; }
			}

			public set_keyspace_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Keyspace = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "set_keyspace_args" );
				if( Keyspace != null && __isset.keyspace ) {
					writer.WriteFieldBegin( "keyspace", TypeKind.String, 1 );
					writer.WriteString( _keyspace );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Keyspace: ", Keyspace );
			}
		}
		public partial struct set_keyspace_result : IFormattable {
			private InvalidRequestException _ire;

			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool ire { get; set; }
			}

			public set_keyspace_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "set_keyspace_result" );

				if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Ire: ", Ire );
			}
		}
		public partial struct get_args : IFormattable {
			private byte[] _key;
			private ColumnPath _column_path;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public byte[] Key { get { return _key; } set { __isset.key = true; _key = value; } }
			public ColumnPath Column_path { get { return _column_path; } set { __isset.column_path = true; _column_path = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool key { get; set; }
				public bool column_path { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public get_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Key = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Column_path = new ColumnPath();
								Column_path.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_args" );
				if( Key != null && __isset.key ) {
					writer.WriteFieldBegin( "key", TypeKind.String, 1 );
					writer.WriteBinary( _key );
					writer.WriteFieldEnd();
				}
				if( Column_path != null && __isset.column_path ) {
					writer.WriteFieldBegin( "column_path", TypeKind.Struct, 2 );
					_column_path.Write( writer );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 3 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Key: ", Key, " Column_path: ", Column_path, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct get_result : IFormattable {
			private ColumnOrSuperColumn _success;
			private InvalidRequestException _ire;
			private NotFoundException _nfe;
			private UnavailableException _ue;
			private TimedOutException _te;

			public ColumnOrSuperColumn Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public NotFoundException Nfe { get { return _nfe; } set { __isset.nfe = true; _nfe = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool nfe { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public get_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Struct ) {
								Success = new ColumnOrSuperColumn();
								Success.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Nfe = new NotFoundException();
								Nfe.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Struct, 0 );
						_success.Write( writer );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.nfe ) {
					writer.WriteFieldBegin( "Nfe", TypeKind.Struct, 2 );
					_nfe.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 3 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 4 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Nfe: ", Nfe, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct get_slice_args : IFormattable {
			private byte[] _key;
			private ColumnParent _column_parent;
			private SlicePredicate _predicate;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public byte[] Key { get { return _key; } set { __isset.key = true; _key = value; } }
			public ColumnParent Column_parent { get { return _column_parent; } set { __isset.column_parent = true; _column_parent = value; } }
			public SlicePredicate Predicate { get { return _predicate; } set { __isset.predicate = true; _predicate = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool key { get; set; }
				public bool column_parent { get; set; }
				public bool predicate { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public get_slice_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Key = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Column_parent = new ColumnParent();
								Column_parent.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Predicate = new SlicePredicate();
								Predicate.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_slice_args" );
				if( Key != null && __isset.key ) {
					writer.WriteFieldBegin( "key", TypeKind.String, 1 );
					writer.WriteBinary( _key );
					writer.WriteFieldEnd();
				}
				if( Column_parent != null && __isset.column_parent ) {
					writer.WriteFieldBegin( "column_parent", TypeKind.Struct, 2 );
					_column_parent.Write( writer );
					writer.WriteFieldEnd();
				}
				if( Predicate != null && __isset.predicate ) {
					writer.WriteFieldBegin( "predicate", TypeKind.Struct, 3 );
					_predicate.Write( writer );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 4 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Key: ", Key, " Column_parent: ", Column_parent, " Predicate: ", Predicate, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct get_slice_result : IFormattable {
			private List<ColumnOrSuperColumn> _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public List<ColumnOrSuperColumn> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public get_slice_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Success = new List<ColumnOrSuperColumn>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = new ColumnOrSuperColumn();
									localElement.Read( reader );
									_success.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_slice_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.List, 0 );
						{
							writer.WriteListBegin( TypeKind.Struct, _success.Count );
							foreach( var item in _success ) {
								item.Write( writer );
							}
							writer.WriteListEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct get_count_args : IFormattable {
			private byte[] _key;
			private ColumnParent _column_parent;
			private SlicePredicate _predicate;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public byte[] Key { get { return _key; } set { __isset.key = true; _key = value; } }
			public ColumnParent Column_parent { get { return _column_parent; } set { __isset.column_parent = true; _column_parent = value; } }
			public SlicePredicate Predicate { get { return _predicate; } set { __isset.predicate = true; _predicate = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool key { get; set; }
				public bool column_parent { get; set; }
				public bool predicate { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public get_count_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Key = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Column_parent = new ColumnParent();
								Column_parent.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Predicate = new SlicePredicate();
								Predicate.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_count_args" );
				if( Key != null && __isset.key ) {
					writer.WriteFieldBegin( "key", TypeKind.String, 1 );
					writer.WriteBinary( _key );
					writer.WriteFieldEnd();
				}
				if( Column_parent != null && __isset.column_parent ) {
					writer.WriteFieldBegin( "column_parent", TypeKind.Struct, 2 );
					_column_parent.Write( writer );
					writer.WriteFieldEnd();
				}
				if( Predicate != null && __isset.predicate ) {
					writer.WriteFieldBegin( "predicate", TypeKind.Struct, 3 );
					_predicate.Write( writer );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 4 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Key: ", Key, " Column_parent: ", Column_parent, " Predicate: ", Predicate, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct get_count_result : IFormattable {
			private int _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public int Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public get_count_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Int32 ) {
								Success = reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_count_result" );

				if( __isset.success ) {
					writer.WriteFieldBegin( "Success", TypeKind.Int32, 0 );
					writer.WriteInt32( _success );
					writer.WriteFieldEnd();
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct multiget_slice_args : IFormattable {
			private List<byte[]> _keys;
			private ColumnParent _column_parent;
			private SlicePredicate _predicate;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public List<byte[]> Keys { get { return _keys; } set { __isset.keys = true; _keys = value; } }
			public ColumnParent Column_parent { get { return _column_parent; } set { __isset.column_parent = true; _column_parent = value; } }
			public SlicePredicate Predicate { get { return _predicate; } set { __isset.predicate = true; _predicate = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool keys { get; set; }
				public bool column_parent { get; set; }
				public bool predicate { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public multiget_slice_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Keys = new List<byte[]>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = reader.ReadBinary();
									_keys.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Column_parent = new ColumnParent();
								Column_parent.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Predicate = new SlicePredicate();
								Predicate.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "multiget_slice_args" );
				if( Keys != null && __isset.keys ) {
					writer.WriteFieldBegin( "keys", TypeKind.List, 1 );
					{
						writer.WriteListBegin( TypeKind.String, _keys.Count );
						foreach( var item in _keys ) {
							writer.WriteBinary( item );
						}
						writer.WriteListEnd();
					}
					writer.WriteFieldEnd();
				}
				if( Column_parent != null && __isset.column_parent ) {
					writer.WriteFieldBegin( "column_parent", TypeKind.Struct, 2 );
					_column_parent.Write( writer );
					writer.WriteFieldEnd();
				}
				if( Predicate != null && __isset.predicate ) {
					writer.WriteFieldBegin( "predicate", TypeKind.Struct, 3 );
					_predicate.Write( writer );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 4 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Keys: ", Keys, " Column_parent: ", Column_parent, " Predicate: ", Predicate, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct multiget_slice_result : IFormattable {
			private Dictionary<byte[], List<ColumnOrSuperColumn>> _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public Dictionary<byte[], List<ColumnOrSuperColumn>> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public multiget_slice_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Map ) {
								var localMap = reader.ReadMapBegin();
								Success = new Dictionary<byte[], List<ColumnOrSuperColumn>>( localMap.Count );
								for( var localCounter = 0; localCounter < localMap.Count; ++localCounter ) {
									var localKey = reader.ReadBinary();
									var localList = reader.ReadListBegin();
									var localValue = new List<ColumnOrSuperColumn>( localList.Count );
									for( var localCounter1 = 0; localCounter1 < localList.Count; ++localCounter1 ) {
										var localElement = new ColumnOrSuperColumn();
										localElement.Read( reader );
										localValue.Add( localElement );
									}
									reader.ReadListEnd();
									_success[localKey] = localValue;
								}
								reader.ReadMapEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "multiget_slice_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Map, 0 );
						{
							writer.WriteMapBegin( TypeKind.String, TypeKind.List, _success.Count );
							foreach( var item in _success ) {
								writer.WriteBinary( item.Key );
								{
									writer.WriteListBegin( TypeKind.Struct, item.Value.Count );
									foreach( var item1 in item.Value ) {
										item1.Write( writer );
									}
									writer.WriteListEnd();
								}
							}
							writer.WriteMapEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct multiget_count_args : IFormattable {
			private List<byte[]> _keys;
			private ColumnParent _column_parent;
			private SlicePredicate _predicate;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public List<byte[]> Keys { get { return _keys; } set { __isset.keys = true; _keys = value; } }
			public ColumnParent Column_parent { get { return _column_parent; } set { __isset.column_parent = true; _column_parent = value; } }
			public SlicePredicate Predicate { get { return _predicate; } set { __isset.predicate = true; _predicate = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool keys { get; set; }
				public bool column_parent { get; set; }
				public bool predicate { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public multiget_count_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Keys = new List<byte[]>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = reader.ReadBinary();
									_keys.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Column_parent = new ColumnParent();
								Column_parent.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Predicate = new SlicePredicate();
								Predicate.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "multiget_count_args" );
				if( Keys != null && __isset.keys ) {
					writer.WriteFieldBegin( "keys", TypeKind.List, 1 );
					{
						writer.WriteListBegin( TypeKind.String, _keys.Count );
						foreach( var item in _keys ) {
							writer.WriteBinary( item );
						}
						writer.WriteListEnd();
					}
					writer.WriteFieldEnd();
				}
				if( Column_parent != null && __isset.column_parent ) {
					writer.WriteFieldBegin( "column_parent", TypeKind.Struct, 2 );
					_column_parent.Write( writer );
					writer.WriteFieldEnd();
				}
				if( Predicate != null && __isset.predicate ) {
					writer.WriteFieldBegin( "predicate", TypeKind.Struct, 3 );
					_predicate.Write( writer );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 4 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Keys: ", Keys, " Column_parent: ", Column_parent, " Predicate: ", Predicate, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct multiget_count_result : IFormattable {
			private Dictionary<byte[], int> _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public Dictionary<byte[], int> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public multiget_count_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Map ) {
								var localMap = reader.ReadMapBegin();
								Success = new Dictionary<byte[], int>( localMap.Count );
								for( var localCounter = 0; localCounter < localMap.Count; ++localCounter ) {
									var localKey = reader.ReadBinary();
									var localValue = reader.ReadInt32();
									_success[localKey] = localValue;
								}
								reader.ReadMapEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "multiget_count_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Map, 0 );
						{
							writer.WriteMapBegin( TypeKind.String, TypeKind.Int32, _success.Count );
							foreach( var item in _success ) {
								writer.WriteBinary( item.Key );
								writer.WriteInt32( item.Value );
							}
							writer.WriteMapEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct get_range_slices_args : IFormattable {
			private ColumnParent _column_parent;
			private SlicePredicate _predicate;
			private KeyRange _range;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public ColumnParent Column_parent { get { return _column_parent; } set { __isset.column_parent = true; _column_parent = value; } }
			public SlicePredicate Predicate { get { return _predicate; } set { __isset.predicate = true; _predicate = value; } }
			public KeyRange Range { get { return _range; } set { __isset.range = true; _range = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool column_parent { get; set; }
				public bool predicate { get; set; }
				public bool range { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public get_range_slices_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Column_parent = new ColumnParent();
								Column_parent.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Predicate = new SlicePredicate();
								Predicate.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Range = new KeyRange();
								Range.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_range_slices_args" );
				if( Column_parent != null && __isset.column_parent ) {
					writer.WriteFieldBegin( "column_parent", TypeKind.Struct, 1 );
					_column_parent.Write( writer );
					writer.WriteFieldEnd();
				}
				if( Predicate != null && __isset.predicate ) {
					writer.WriteFieldBegin( "predicate", TypeKind.Struct, 2 );
					_predicate.Write( writer );
					writer.WriteFieldEnd();
				}
				if( Range != null && __isset.range ) {
					writer.WriteFieldBegin( "range", TypeKind.Struct, 3 );
					_range.Write( writer );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 4 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Column_parent: ", Column_parent, " Predicate: ", Predicate, " Range: ", Range, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct get_range_slices_result : IFormattable {
			private List<KeySlice> _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public List<KeySlice> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public get_range_slices_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Success = new List<KeySlice>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = new KeySlice();
									localElement.Read( reader );
									_success.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_range_slices_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.List, 0 );
						{
							writer.WriteListBegin( TypeKind.Struct, _success.Count );
							foreach( var item in _success ) {
								item.Write( writer );
							}
							writer.WriteListEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct get_paged_slice_args : IFormattable {
			private Utf8String _column_family;
			private KeyRange _range;
			private byte[] _start_column;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public Utf8String Column_family { get { return _column_family; } set { __isset.column_family = true; _column_family = value; } }
			public KeyRange Range { get { return _range; } set { __isset.range = true; _range = value; } }
			public byte[] Start_column { get { return _start_column; } set { __isset.start_column = true; _start_column = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool column_family { get; set; }
				public bool range { get; set; }
				public bool start_column { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public get_paged_slice_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Column_family = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Range = new KeyRange();
								Range.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.String ) {
								Start_column = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_paged_slice_args" );
				if( Column_family != null && __isset.column_family ) {
					writer.WriteFieldBegin( "column_family", TypeKind.String, 1 );
					writer.WriteString( _column_family );
					writer.WriteFieldEnd();
				}
				if( Range != null && __isset.range ) {
					writer.WriteFieldBegin( "range", TypeKind.Struct, 2 );
					_range.Write( writer );
					writer.WriteFieldEnd();
				}
				if( Start_column != null && __isset.start_column ) {
					writer.WriteFieldBegin( "start_column", TypeKind.String, 3 );
					writer.WriteBinary( _start_column );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 4 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Column_family: ", Column_family, " Range: ", Range, " Start_column: ", Start_column, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct get_paged_slice_result : IFormattable {
			private List<KeySlice> _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public List<KeySlice> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public get_paged_slice_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Success = new List<KeySlice>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = new KeySlice();
									localElement.Read( reader );
									_success.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_paged_slice_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.List, 0 );
						{
							writer.WriteListBegin( TypeKind.Struct, _success.Count );
							foreach( var item in _success ) {
								item.Write( writer );
							}
							writer.WriteListEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct get_indexed_slices_args : IFormattable {
			private ColumnParent _column_parent;
			private IndexClause _index_clause;
			private SlicePredicate _column_predicate;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public ColumnParent Column_parent { get { return _column_parent; } set { __isset.column_parent = true; _column_parent = value; } }
			public IndexClause Index_clause { get { return _index_clause; } set { __isset.index_clause = true; _index_clause = value; } }
			public SlicePredicate Column_predicate { get { return _column_predicate; } set { __isset.column_predicate = true; _column_predicate = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool column_parent { get; set; }
				public bool index_clause { get; set; }
				public bool column_predicate { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public get_indexed_slices_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Column_parent = new ColumnParent();
								Column_parent.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Index_clause = new IndexClause();
								Index_clause.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Column_predicate = new SlicePredicate();
								Column_predicate.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_indexed_slices_args" );
				if( Column_parent != null && __isset.column_parent ) {
					writer.WriteFieldBegin( "column_parent", TypeKind.Struct, 1 );
					_column_parent.Write( writer );
					writer.WriteFieldEnd();
				}
				if( Index_clause != null && __isset.index_clause ) {
					writer.WriteFieldBegin( "index_clause", TypeKind.Struct, 2 );
					_index_clause.Write( writer );
					writer.WriteFieldEnd();
				}
				if( Column_predicate != null && __isset.column_predicate ) {
					writer.WriteFieldBegin( "column_predicate", TypeKind.Struct, 3 );
					_column_predicate.Write( writer );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 4 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Column_parent: ", Column_parent, " Index_clause: ", Index_clause, " Column_predicate: ", Column_predicate, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct get_indexed_slices_result : IFormattable {
			private List<KeySlice> _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public List<KeySlice> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public get_indexed_slices_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Success = new List<KeySlice>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = new KeySlice();
									localElement.Read( reader );
									_success.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "get_indexed_slices_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.List, 0 );
						{
							writer.WriteListBegin( TypeKind.Struct, _success.Count );
							foreach( var item in _success ) {
								item.Write( writer );
							}
							writer.WriteListEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct insert_args : IFormattable {
			private byte[] _key;
			private ColumnParent _column_parent;
			private Column _column;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public byte[] Key { get { return _key; } set { __isset.key = true; _key = value; } }
			public ColumnParent Column_parent { get { return _column_parent; } set { __isset.column_parent = true; _column_parent = value; } }
			public Column Column { get { return _column; } set { __isset.column = true; _column = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool key { get; set; }
				public bool column_parent { get; set; }
				public bool column { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public insert_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Key = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Column_parent = new ColumnParent();
								Column_parent.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Column = new Column();
								Column.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "insert_args" );
				if( Key != null && __isset.key ) {
					writer.WriteFieldBegin( "key", TypeKind.String, 1 );
					writer.WriteBinary( _key );
					writer.WriteFieldEnd();
				}
				if( Column_parent != null && __isset.column_parent ) {
					writer.WriteFieldBegin( "column_parent", TypeKind.Struct, 2 );
					_column_parent.Write( writer );
					writer.WriteFieldEnd();
				}
				if( Column != null && __isset.column ) {
					writer.WriteFieldBegin( "column", TypeKind.Struct, 3 );
					_column.Write( writer );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 4 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Key: ", Key, " Column_parent: ", Column_parent, " Column: ", Column, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct insert_result : IFormattable {
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public insert_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "insert_result" );

				if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct add_args : IFormattable {
			private byte[] _key;
			private ColumnParent _column_parent;
			private CounterColumn _column;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public byte[] Key { get { return _key; } set { __isset.key = true; _key = value; } }
			public ColumnParent Column_parent { get { return _column_parent; } set { __isset.column_parent = true; _column_parent = value; } }
			public CounterColumn Column { get { return _column; } set { __isset.column = true; _column = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool key { get; set; }
				public bool column_parent { get; set; }
				public bool column { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public add_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Key = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Column_parent = new ColumnParent();
								Column_parent.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Column = new CounterColumn();
								Column.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "add_args" );
				if( Key != null && __isset.key ) {
					writer.WriteFieldBegin( "key", TypeKind.String, 1 );
					writer.WriteBinary( _key );
					writer.WriteFieldEnd();
				}
				if( Column_parent != null && __isset.column_parent ) {
					writer.WriteFieldBegin( "column_parent", TypeKind.Struct, 2 );
					_column_parent.Write( writer );
					writer.WriteFieldEnd();
				}
				if( Column != null && __isset.column ) {
					writer.WriteFieldBegin( "column", TypeKind.Struct, 3 );
					_column.Write( writer );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 4 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Key: ", Key, " Column_parent: ", Column_parent, " Column: ", Column, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct add_result : IFormattable {
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public add_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "add_result" );

				if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct cas_args : IFormattable {
			private byte[] _key;
			private Utf8String _column_family;
			private List<Column> _expected;
			private List<Column> _updates;
			private ConsistencyLevel _serial_consistency_level = ConsistencyLevel.SERIAL;
			private ConsistencyLevel _commit_consistency_level = ConsistencyLevel.QUORUM;

			public byte[] Key { get { return _key; } set { __isset.key = true; _key = value; } }
			public Utf8String Column_family { get { return _column_family; } set { __isset.column_family = true; _column_family = value; } }
			public List<Column> Expected { get { return _expected; } set { __isset.expected = true; _expected = value; } }
			public List<Column> Updates { get { return _updates; } set { __isset.updates = true; _updates = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Serial_consistency_level { get { return _serial_consistency_level; } set { __isset.serial_consistency_level = true; _serial_consistency_level = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Commit_consistency_level { get { return _commit_consistency_level; } set { __isset.commit_consistency_level = true; _commit_consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool key { get; set; }
				public bool column_family { get; set; }
				public bool expected { get; set; }
				public bool updates { get; set; }
				public bool serial_consistency_level { get; set; } = true;
				public bool commit_consistency_level { get; set; } = true;
			}

			public cas_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Key = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.String ) {
								Column_family = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Expected = new List<Column>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = new Column();
									localElement.Read( reader );
									_expected.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.List ) {
								var localList1 = reader.ReadListBegin();
								Updates = new List<Column>( localList1.Count );
								for( var localCounter1 = 0; localCounter1 < localList1.Count; ++localCounter1 ) {
									var localElement1 = new Column();
									localElement1.Read( reader );
									_updates.Add( localElement1 );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 5:
							if( field.Type == TypeKind.Int32 ) {
								Serial_consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						case 6:
							if( field.Type == TypeKind.Int32 ) {
								Commit_consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "cas_args" );
				if( Key != null && __isset.key ) {
					writer.WriteFieldBegin( "key", TypeKind.String, 1 );
					writer.WriteBinary( _key );
					writer.WriteFieldEnd();
				}
				if( Column_family != null && __isset.column_family ) {
					writer.WriteFieldBegin( "column_family", TypeKind.String, 2 );
					writer.WriteString( _column_family );
					writer.WriteFieldEnd();
				}
				if( Expected != null && __isset.expected ) {
					writer.WriteFieldBegin( "expected", TypeKind.List, 3 );
					{
						writer.WriteListBegin( TypeKind.Struct, _expected.Count );
						foreach( var item in _expected ) {
							item.Write( writer );
						}
						writer.WriteListEnd();
					}
					writer.WriteFieldEnd();
				}
				if( Updates != null && __isset.updates ) {
					writer.WriteFieldBegin( "updates", TypeKind.List, 4 );
					{
						writer.WriteListBegin( TypeKind.Struct, _updates.Count );
						foreach( var item in _updates ) {
							item.Write( writer );
						}
						writer.WriteListEnd();
					}
					writer.WriteFieldEnd();
				}
				if( __isset.serial_consistency_level ) {
					writer.WriteFieldBegin( "serial_consistency_level", TypeKind.Int32, 5 );
					writer.WriteInt32( ( int ) _serial_consistency_level );
					writer.WriteFieldEnd();
				}
				if( __isset.commit_consistency_level ) {
					writer.WriteFieldBegin( "commit_consistency_level", TypeKind.Int32, 6 );
					writer.WriteInt32( ( int ) _commit_consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Key: ", Key, " Column_family: ", Column_family, " Expected: ", Expected, " Updates: ", Updates, " Serial_consistency_level: ", Serial_consistency_level, " Commit_consistency_level: ", Commit_consistency_level );
			}
		}
		public partial struct cas_result : IFormattable {
			private CASResult _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public CASResult Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public cas_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Struct ) {
								Success = new CASResult();
								Success.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "cas_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Struct, 0 );
						_success.Write( writer );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct remove_args : IFormattable {
			private byte[] _key;
			private ColumnPath _column_path;
			private long _timestamp;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public byte[] Key { get { return _key; } set { __isset.key = true; _key = value; } }
			public ColumnPath Column_path { get { return _column_path; } set { __isset.column_path = true; _column_path = value; } }
			public long Timestamp { get { return _timestamp; } set { __isset.timestamp = true; _timestamp = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool key { get; set; }
				public bool column_path { get; set; }
				public bool timestamp { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public remove_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Key = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Column_path = new ColumnPath();
								Column_path.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Int64 ) {
								Timestamp = reader.ReadInt64();
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "remove_args" );
				if( Key != null && __isset.key ) {
					writer.WriteFieldBegin( "key", TypeKind.String, 1 );
					writer.WriteBinary( _key );
					writer.WriteFieldEnd();
				}
				if( Column_path != null && __isset.column_path ) {
					writer.WriteFieldBegin( "column_path", TypeKind.Struct, 2 );
					_column_path.Write( writer );
					writer.WriteFieldEnd();
				}
				if( __isset.timestamp ) {
					writer.WriteFieldBegin( "timestamp", TypeKind.Int64, 3 );
					writer.WriteInt64( _timestamp );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 4 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Key: ", Key, " Column_path: ", Column_path, " Timestamp: ", Timestamp, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct remove_result : IFormattable {
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public remove_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "remove_result" );

				if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct remove_counter_args : IFormattable {
			private byte[] _key;
			private ColumnPath _path;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public byte[] Key { get { return _key; } set { __isset.key = true; _key = value; } }
			public ColumnPath Path { get { return _path; } set { __isset.path = true; _path = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool key { get; set; }
				public bool path { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public remove_counter_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Key = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Path = new ColumnPath();
								Path.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "remove_counter_args" );
				if( Key != null && __isset.key ) {
					writer.WriteFieldBegin( "key", TypeKind.String, 1 );
					writer.WriteBinary( _key );
					writer.WriteFieldEnd();
				}
				if( Path != null && __isset.path ) {
					writer.WriteFieldBegin( "path", TypeKind.Struct, 2 );
					_path.Write( writer );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 3 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Key: ", Key, " Path: ", Path, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct remove_counter_result : IFormattable {
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public remove_counter_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "remove_counter_result" );

				if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct batch_mutate_args : IFormattable {
			private Dictionary<byte[], Dictionary<Utf8String, List<Mutation>>> _mutation_map;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public Dictionary<byte[], Dictionary<Utf8String, List<Mutation>>> Mutation_map { get { return _mutation_map; } set { __isset.mutation_map = true; _mutation_map = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool mutation_map { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public batch_mutate_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Map ) {
								var localMap = reader.ReadMapBegin();
								Mutation_map = new Dictionary<byte[], Dictionary<Utf8String, List<Mutation>>>( localMap.Count );
								for( var localCounter = 0; localCounter < localMap.Count; ++localCounter ) {
									var localKey = reader.ReadBinary();
									var localMap1 = reader.ReadMapBegin();
									var localValue = new Dictionary<Utf8String, List<Mutation>>( localMap1.Count );
									for( var localCounter1 = 0; localCounter1 < localMap1.Count; ++localCounter1 ) {
										var localKey1 = reader.ReadString();
										var localList = reader.ReadListBegin();
										var localValue1 = new List<Mutation>( localList.Count );
										for( var localCounter2 = 0; localCounter2 < localList.Count; ++localCounter2 ) {
											var localElement = new Mutation();
											localElement.Read( reader );
											localValue1.Add( localElement );
										}
										reader.ReadListEnd();
										localValue[localKey1] = localValue1;
									}
									reader.ReadMapEnd();
									_mutation_map[localKey] = localValue;
								}
								reader.ReadMapEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "batch_mutate_args" );
				if( Mutation_map != null && __isset.mutation_map ) {
					writer.WriteFieldBegin( "mutation_map", TypeKind.Map, 1 );
					{
						writer.WriteMapBegin( TypeKind.String, TypeKind.Map, _mutation_map.Count );
						foreach( var item in _mutation_map ) {
							writer.WriteBinary( item.Key );
							{
								writer.WriteMapBegin( TypeKind.String, TypeKind.List, item.Value.Count );
								foreach( var item1 in item.Value ) {
									writer.WriteString( item1.Key );
									{
										writer.WriteListBegin( TypeKind.Struct, item1.Value.Count );
										foreach( var item2 in item1.Value ) {
											item2.Write( writer );
										}
										writer.WriteListEnd();
									}
								}
								writer.WriteMapEnd();
							}
						}
						writer.WriteMapEnd();
					}
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 2 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Mutation_map: ", Mutation_map, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct batch_mutate_result : IFormattable {
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public batch_mutate_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "batch_mutate_result" );

				if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct atomic_batch_mutate_args : IFormattable {
			private Dictionary<byte[], Dictionary<Utf8String, List<Mutation>>> _mutation_map;
			private ConsistencyLevel _consistency_level = ConsistencyLevel.ONE;

			public Dictionary<byte[], Dictionary<Utf8String, List<Mutation>>> Mutation_map { get { return _mutation_map; } set { __isset.mutation_map = true; _mutation_map = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency_level { get { return _consistency_level; } set { __isset.consistency_level = true; _consistency_level = value; } }

			public Isset __isset = new Isset();
			public struct Isset {
				public Isset() { }

				public bool mutation_map { get; set; }
				public bool consistency_level { get; set; } = true;
			}

			public atomic_batch_mutate_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Map ) {
								var localMap = reader.ReadMapBegin();
								Mutation_map = new Dictionary<byte[], Dictionary<Utf8String, List<Mutation>>>( localMap.Count );
								for( var localCounter = 0; localCounter < localMap.Count; ++localCounter ) {
									var localKey = reader.ReadBinary();
									var localMap1 = reader.ReadMapBegin();
									var localValue = new Dictionary<Utf8String, List<Mutation>>( localMap1.Count );
									for( var localCounter1 = 0; localCounter1 < localMap1.Count; ++localCounter1 ) {
										var localKey1 = reader.ReadString();
										var localList = reader.ReadListBegin();
										var localValue1 = new List<Mutation>( localList.Count );
										for( var localCounter2 = 0; localCounter2 < localList.Count; ++localCounter2 ) {
											var localElement = new Mutation();
											localElement.Read( reader );
											localValue1.Add( localElement );
										}
										reader.ReadListEnd();
										localValue[localKey1] = localValue1;
									}
									reader.ReadMapEnd();
									_mutation_map[localKey] = localValue;
								}
								reader.ReadMapEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Int32 ) {
								Consistency_level = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "atomic_batch_mutate_args" );
				if( Mutation_map != null && __isset.mutation_map ) {
					writer.WriteFieldBegin( "mutation_map", TypeKind.Map, 1 );
					{
						writer.WriteMapBegin( TypeKind.String, TypeKind.Map, _mutation_map.Count );
						foreach( var item in _mutation_map ) {
							writer.WriteBinary( item.Key );
							{
								writer.WriteMapBegin( TypeKind.String, TypeKind.List, item.Value.Count );
								foreach( var item1 in item.Value ) {
									writer.WriteString( item1.Key );
									{
										writer.WriteListBegin( TypeKind.Struct, item1.Value.Count );
										foreach( var item2 in item1.Value ) {
											item2.Write( writer );
										}
										writer.WriteListEnd();
									}
								}
								writer.WriteMapEnd();
							}
						}
						writer.WriteMapEnd();
					}
					writer.WriteFieldEnd();
				}
				if( __isset.consistency_level ) {
					writer.WriteFieldBegin( "consistency_level", TypeKind.Int32, 2 );
					writer.WriteInt32( ( int ) _consistency_level );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Mutation_map: ", Mutation_map, " Consistency_level: ", Consistency_level );
			}
		}
		public partial struct atomic_batch_mutate_result : IFormattable {
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public atomic_batch_mutate_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "atomic_batch_mutate_result" );

				if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct truncate_args : IFormattable {
			private Utf8String _cfname;

			public Utf8String Cfname { get { return _cfname; } set { __isset.cfname = true; _cfname = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool cfname { get; set; }
			}

			public truncate_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Cfname = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "truncate_args" );
				if( Cfname != null && __isset.cfname ) {
					writer.WriteFieldBegin( "cfname", TypeKind.String, 1 );
					writer.WriteString( _cfname );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Cfname: ", Cfname );
			}
		}
		public partial struct truncate_result : IFormattable {
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;

			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
			}

			public truncate_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "truncate_result" );

				if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Ire: ", Ire, " Ue: ", Ue, " Te: ", Te );
			}
		}
		public partial struct describe_schema_versions_args : IFormattable {
			public describe_schema_versions_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_schema_versions_args" );
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
			}
		}
		public partial struct describe_schema_versions_result : IFormattable {
			private Dictionary<Utf8String, List<Utf8String>> _success;
			private InvalidRequestException _ire;

			public Dictionary<Utf8String, List<Utf8String>> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
			}

			public describe_schema_versions_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Map ) {
								var localMap = reader.ReadMapBegin();
								Success = new Dictionary<Utf8String, List<Utf8String>>( localMap.Count );
								for( var localCounter = 0; localCounter < localMap.Count; ++localCounter ) {
									var localKey = reader.ReadString();
									var localList = reader.ReadListBegin();
									var localValue = new List<Utf8String>( localList.Count );
									for( var localCounter1 = 0; localCounter1 < localList.Count; ++localCounter1 ) {
										var localElement = reader.ReadString();
										localValue.Add( localElement );
									}
									reader.ReadListEnd();
									_success[localKey] = localValue;
								}
								reader.ReadMapEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_schema_versions_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Map, 0 );
						{
							writer.WriteMapBegin( TypeKind.String, TypeKind.List, _success.Count );
							foreach( var item in _success ) {
								writer.WriteString( item.Key );
								{
									writer.WriteListBegin( TypeKind.String, item.Value.Count );
									foreach( var item1 in item.Value ) {
										writer.WriteString( item1 );
									}
									writer.WriteListEnd();
								}
							}
							writer.WriteMapEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire );
			}
		}
		public partial struct describe_keyspaces_args : IFormattable {
			public describe_keyspaces_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_keyspaces_args" );
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
			}
		}
		public partial struct describe_keyspaces_result : IFormattable {
			private List<KsDef> _success;
			private InvalidRequestException _ire;

			public List<KsDef> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
			}

			public describe_keyspaces_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Success = new List<KsDef>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = new KsDef();
									localElement.Read( reader );
									_success.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_keyspaces_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.List, 0 );
						{
							writer.WriteListBegin( TypeKind.Struct, _success.Count );
							foreach( var item in _success ) {
								item.Write( writer );
							}
							writer.WriteListEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire );
			}
		}
		public partial struct describe_cluster_name_args : IFormattable {
			public describe_cluster_name_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_cluster_name_args" );
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
			}
		}
		public partial struct describe_cluster_name_result : IFormattable {
			private Utf8String _success;

			public Utf8String Success { get { return _success; } set { __isset.success = true; _success = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
			}

			public describe_cluster_name_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.String ) {
								Success = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_cluster_name_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.String, 0 );
						writer.WriteString( _success );
						writer.WriteFieldEnd();
					}
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success );
			}
		}
		public partial struct describe_version_args : IFormattable {
			public describe_version_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_version_args" );
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
			}
		}
		public partial struct describe_version_result : IFormattable {
			private Utf8String _success;

			public Utf8String Success { get { return _success; } set { __isset.success = true; _success = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
			}

			public describe_version_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.String ) {
								Success = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_version_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.String, 0 );
						writer.WriteString( _success );
						writer.WriteFieldEnd();
					}
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success );
			}
		}
		public partial struct describe_ring_args : IFormattable {
			private Utf8String _keyspace;

			public Utf8String Keyspace { get { return _keyspace; } set { __isset.keyspace = true; _keyspace = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool keyspace { get; set; }
			}

			public describe_ring_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Keyspace = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_ring_args" );
				if( Keyspace != null && __isset.keyspace ) {
					writer.WriteFieldBegin( "keyspace", TypeKind.String, 1 );
					writer.WriteString( _keyspace );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Keyspace: ", Keyspace );
			}
		}
		public partial struct describe_ring_result : IFormattable {
			private List<TokenRange> _success;
			private InvalidRequestException _ire;

			public List<TokenRange> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
			}

			public describe_ring_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Success = new List<TokenRange>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = new TokenRange();
									localElement.Read( reader );
									_success.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_ring_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.List, 0 );
						{
							writer.WriteListBegin( TypeKind.Struct, _success.Count );
							foreach( var item in _success ) {
								item.Write( writer );
							}
							writer.WriteListEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire );
			}
		}
		public partial struct describe_local_ring_args : IFormattable {
			private Utf8String _keyspace;

			public Utf8String Keyspace { get { return _keyspace; } set { __isset.keyspace = true; _keyspace = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool keyspace { get; set; }
			}

			public describe_local_ring_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Keyspace = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_local_ring_args" );
				if( Keyspace != null && __isset.keyspace ) {
					writer.WriteFieldBegin( "keyspace", TypeKind.String, 1 );
					writer.WriteString( _keyspace );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Keyspace: ", Keyspace );
			}
		}
		public partial struct describe_local_ring_result : IFormattable {
			private List<TokenRange> _success;
			private InvalidRequestException _ire;

			public List<TokenRange> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
			}

			public describe_local_ring_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Success = new List<TokenRange>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = new TokenRange();
									localElement.Read( reader );
									_success.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_local_ring_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.List, 0 );
						{
							writer.WriteListBegin( TypeKind.Struct, _success.Count );
							foreach( var item in _success ) {
								item.Write( writer );
							}
							writer.WriteListEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire );
			}
		}
		public partial struct describe_token_map_args : IFormattable {
			public describe_token_map_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_token_map_args" );
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
			}
		}
		public partial struct describe_token_map_result : IFormattable {
			private Dictionary<Utf8String, Utf8String> _success;
			private InvalidRequestException _ire;

			public Dictionary<Utf8String, Utf8String> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
			}

			public describe_token_map_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Map ) {
								var localMap = reader.ReadMapBegin();
								Success = new Dictionary<Utf8String, Utf8String>( localMap.Count );
								for( var localCounter = 0; localCounter < localMap.Count; ++localCounter ) {
									var localKey = reader.ReadString();
									var localValue = reader.ReadString();
									_success[localKey] = localValue;
								}
								reader.ReadMapEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_token_map_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Map, 0 );
						{
							writer.WriteMapBegin( TypeKind.String, TypeKind.String, _success.Count );
							foreach( var item in _success ) {
								writer.WriteString( item.Key );
								writer.WriteString( item.Value );
							}
							writer.WriteMapEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire );
			}
		}
		public partial struct describe_partitioner_args : IFormattable {
			public describe_partitioner_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_partitioner_args" );
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
			}
		}
		public partial struct describe_partitioner_result : IFormattable {
			private Utf8String _success;

			public Utf8String Success { get { return _success; } set { __isset.success = true; _success = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
			}

			public describe_partitioner_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.String ) {
								Success = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_partitioner_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.String, 0 );
						writer.WriteString( _success );
						writer.WriteFieldEnd();
					}
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success );
			}
		}
		public partial struct describe_snitch_args : IFormattable {
			public describe_snitch_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_snitch_args" );
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
			}
		}
		public partial struct describe_snitch_result : IFormattable {
			private Utf8String _success;

			public Utf8String Success { get { return _success; } set { __isset.success = true; _success = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
			}

			public describe_snitch_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.String ) {
								Success = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_snitch_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.String, 0 );
						writer.WriteString( _success );
						writer.WriteFieldEnd();
					}
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success );
			}
		}
		public partial struct describe_keyspace_args : IFormattable {
			private Utf8String _keyspace;

			public Utf8String Keyspace { get { return _keyspace; } set { __isset.keyspace = true; _keyspace = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool keyspace { get; set; }
			}

			public describe_keyspace_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Keyspace = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_keyspace_args" );
				if( Keyspace != null && __isset.keyspace ) {
					writer.WriteFieldBegin( "keyspace", TypeKind.String, 1 );
					writer.WriteString( _keyspace );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Keyspace: ", Keyspace );
			}
		}
		public partial struct describe_keyspace_result : IFormattable {
			private KsDef _success;
			private NotFoundException _nfe;
			private InvalidRequestException _ire;

			public KsDef Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public NotFoundException Nfe { get { return _nfe; } set { __isset.nfe = true; _nfe = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool nfe { get; set; }
				public bool ire { get; set; }
			}

			public describe_keyspace_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Struct ) {
								Success = new KsDef();
								Success.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Nfe = new NotFoundException();
								Nfe.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_keyspace_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Struct, 0 );
						_success.Write( writer );
						writer.WriteFieldEnd();
					}
				} else if( __isset.nfe ) {
					writer.WriteFieldBegin( "Nfe", TypeKind.Struct, 1 );
					_nfe.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 2 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Nfe: ", Nfe, " Ire: ", Ire );
			}
		}
		public partial struct describe_splits_args : IFormattable {
			private Utf8String _cfName;
			private Utf8String _start_token;
			private Utf8String _end_token;
			private int _keys_per_split;

			public Utf8String CfName { get { return _cfName; } set { __isset.cfName = true; _cfName = value; } }
			public Utf8String Start_token { get { return _start_token; } set { __isset.start_token = true; _start_token = value; } }
			public Utf8String End_token { get { return _end_token; } set { __isset.end_token = true; _end_token = value; } }
			public int Keys_per_split { get { return _keys_per_split; } set { __isset.keys_per_split = true; _keys_per_split = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool cfName { get; set; }
				public bool start_token { get; set; }
				public bool end_token { get; set; }
				public bool keys_per_split { get; set; }
			}

			public describe_splits_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								CfName = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.String ) {
								Start_token = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.String ) {
								End_token = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Keys_per_split = reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_splits_args" );
				if( CfName != null && __isset.cfName ) {
					writer.WriteFieldBegin( "cfName", TypeKind.String, 1 );
					writer.WriteString( _cfName );
					writer.WriteFieldEnd();
				}
				if( Start_token != null && __isset.start_token ) {
					writer.WriteFieldBegin( "start_token", TypeKind.String, 2 );
					writer.WriteString( _start_token );
					writer.WriteFieldEnd();
				}
				if( End_token != null && __isset.end_token ) {
					writer.WriteFieldBegin( "end_token", TypeKind.String, 3 );
					writer.WriteString( _end_token );
					writer.WriteFieldEnd();
				}
				if( __isset.keys_per_split ) {
					writer.WriteFieldBegin( "keys_per_split", TypeKind.Int32, 4 );
					writer.WriteInt32( _keys_per_split );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "CfName: ", CfName, " Start_token: ", Start_token, " End_token: ", End_token, " Keys_per_split: ", Keys_per_split );
			}
		}
		public partial struct describe_splits_result : IFormattable {
			private List<Utf8String> _success;
			private InvalidRequestException _ire;

			public List<Utf8String> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
			}

			public describe_splits_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Success = new List<Utf8String>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = reader.ReadString();
									_success.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_splits_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.List, 0 );
						{
							writer.WriteListBegin( TypeKind.String, _success.Count );
							foreach( var item in _success ) {
								writer.WriteString( item );
							}
							writer.WriteListEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire );
			}
		}
		public partial struct trace_next_query_args : IFormattable {
			public trace_next_query_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "trace_next_query_args" );
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
			}
		}
		public partial struct trace_next_query_result : IFormattable {
			private byte[] _success;

			public byte[] Success { get { return _success; } set { __isset.success = true; _success = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
			}

			public trace_next_query_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.String ) {
								Success = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "trace_next_query_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.String, 0 );
						writer.WriteBinary( _success );
						writer.WriteFieldEnd();
					}
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success );
			}
		}
		public partial struct describe_splits_ex_args : IFormattable {
			private Utf8String _cfName;
			private Utf8String _start_token;
			private Utf8String _end_token;
			private int _keys_per_split;

			public Utf8String CfName { get { return _cfName; } set { __isset.cfName = true; _cfName = value; } }
			public Utf8String Start_token { get { return _start_token; } set { __isset.start_token = true; _start_token = value; } }
			public Utf8String End_token { get { return _end_token; } set { __isset.end_token = true; _end_token = value; } }
			public int Keys_per_split { get { return _keys_per_split; } set { __isset.keys_per_split = true; _keys_per_split = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool cfName { get; set; }
				public bool start_token { get; set; }
				public bool end_token { get; set; }
				public bool keys_per_split { get; set; }
			}

			public describe_splits_ex_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								CfName = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.String ) {
								Start_token = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.String ) {
								End_token = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Int32 ) {
								Keys_per_split = reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_splits_ex_args" );
				if( CfName != null && __isset.cfName ) {
					writer.WriteFieldBegin( "cfName", TypeKind.String, 1 );
					writer.WriteString( _cfName );
					writer.WriteFieldEnd();
				}
				if( Start_token != null && __isset.start_token ) {
					writer.WriteFieldBegin( "start_token", TypeKind.String, 2 );
					writer.WriteString( _start_token );
					writer.WriteFieldEnd();
				}
				if( End_token != null && __isset.end_token ) {
					writer.WriteFieldBegin( "end_token", TypeKind.String, 3 );
					writer.WriteString( _end_token );
					writer.WriteFieldEnd();
				}
				if( __isset.keys_per_split ) {
					writer.WriteFieldBegin( "keys_per_split", TypeKind.Int32, 4 );
					writer.WriteInt32( _keys_per_split );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "CfName: ", CfName, " Start_token: ", Start_token, " End_token: ", End_token, " Keys_per_split: ", Keys_per_split );
			}
		}
		public partial struct describe_splits_ex_result : IFormattable {
			private List<CfSplit> _success;
			private InvalidRequestException _ire;

			public List<CfSplit> Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
			}

			public describe_splits_ex_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Success = new List<CfSplit>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = new CfSplit();
									localElement.Read( reader );
									_success.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "describe_splits_ex_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.List, 0 );
						{
							writer.WriteListBegin( TypeKind.Struct, _success.Count );
							foreach( var item in _success ) {
								item.Write( writer );
							}
							writer.WriteListEnd();
						}
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire );
			}
		}
		public partial struct system_add_column_family_args : IFormattable {
			private CfDef _cf_def;

			public CfDef Cf_def { get { return _cf_def; } set { __isset.cf_def = true; _cf_def = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool cf_def { get; set; }
			}

			public system_add_column_family_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Cf_def = new CfDef();
								Cf_def.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_add_column_family_args" );
				if( Cf_def != null && __isset.cf_def ) {
					writer.WriteFieldBegin( "cf_def", TypeKind.Struct, 1 );
					_cf_def.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Cf_def: ", Cf_def );
			}
		}
		public partial struct system_add_column_family_result : IFormattable {
			private Utf8String _success;
			private InvalidRequestException _ire;
			private SchemaDisagreementException _sde;

			public Utf8String Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public SchemaDisagreementException Sde { get { return _sde; } set { __isset.sde = true; _sde = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool sde { get; set; }
			}

			public system_add_column_family_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.String ) {
								Success = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Sde = new SchemaDisagreementException();
								Sde.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_add_column_family_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.String, 0 );
						writer.WriteString( _success );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.sde ) {
					writer.WriteFieldBegin( "Sde", TypeKind.Struct, 2 );
					_sde.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Sde: ", Sde );
			}
		}
		public partial struct system_drop_column_family_args : IFormattable {
			private Utf8String _column_family;

			public Utf8String Column_family { get { return _column_family; } set { __isset.column_family = true; _column_family = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool column_family { get; set; }
			}

			public system_drop_column_family_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Column_family = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_drop_column_family_args" );
				if( Column_family != null && __isset.column_family ) {
					writer.WriteFieldBegin( "column_family", TypeKind.String, 1 );
					writer.WriteString( _column_family );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Column_family: ", Column_family );
			}
		}
		public partial struct system_drop_column_family_result : IFormattable {
			private Utf8String _success;
			private InvalidRequestException _ire;
			private SchemaDisagreementException _sde;

			public Utf8String Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public SchemaDisagreementException Sde { get { return _sde; } set { __isset.sde = true; _sde = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool sde { get; set; }
			}

			public system_drop_column_family_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.String ) {
								Success = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Sde = new SchemaDisagreementException();
								Sde.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_drop_column_family_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.String, 0 );
						writer.WriteString( _success );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.sde ) {
					writer.WriteFieldBegin( "Sde", TypeKind.Struct, 2 );
					_sde.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Sde: ", Sde );
			}
		}
		public partial struct system_add_keyspace_args : IFormattable {
			private KsDef _ks_def;

			public KsDef Ks_def { get { return _ks_def; } set { __isset.ks_def = true; _ks_def = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool ks_def { get; set; }
			}

			public system_add_keyspace_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ks_def = new KsDef();
								Ks_def.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_add_keyspace_args" );
				if( Ks_def != null && __isset.ks_def ) {
					writer.WriteFieldBegin( "ks_def", TypeKind.Struct, 1 );
					_ks_def.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Ks_def: ", Ks_def );
			}
		}
		public partial struct system_add_keyspace_result : IFormattable {
			private Utf8String _success;
			private InvalidRequestException _ire;
			private SchemaDisagreementException _sde;

			public Utf8String Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public SchemaDisagreementException Sde { get { return _sde; } set { __isset.sde = true; _sde = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool sde { get; set; }
			}

			public system_add_keyspace_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.String ) {
								Success = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Sde = new SchemaDisagreementException();
								Sde.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_add_keyspace_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.String, 0 );
						writer.WriteString( _success );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.sde ) {
					writer.WriteFieldBegin( "Sde", TypeKind.Struct, 2 );
					_sde.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Sde: ", Sde );
			}
		}
		public partial struct system_drop_keyspace_args : IFormattable {
			private Utf8String _keyspace;

			public Utf8String Keyspace { get { return _keyspace; } set { __isset.keyspace = true; _keyspace = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool keyspace { get; set; }
			}

			public system_drop_keyspace_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Keyspace = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_drop_keyspace_args" );
				if( Keyspace != null && __isset.keyspace ) {
					writer.WriteFieldBegin( "keyspace", TypeKind.String, 1 );
					writer.WriteString( _keyspace );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Keyspace: ", Keyspace );
			}
		}
		public partial struct system_drop_keyspace_result : IFormattable {
			private Utf8String _success;
			private InvalidRequestException _ire;
			private SchemaDisagreementException _sde;

			public Utf8String Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public SchemaDisagreementException Sde { get { return _sde; } set { __isset.sde = true; _sde = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool sde { get; set; }
			}

			public system_drop_keyspace_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.String ) {
								Success = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Sde = new SchemaDisagreementException();
								Sde.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_drop_keyspace_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.String, 0 );
						writer.WriteString( _success );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.sde ) {
					writer.WriteFieldBegin( "Sde", TypeKind.Struct, 2 );
					_sde.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Sde: ", Sde );
			}
		}
		public partial struct system_update_keyspace_args : IFormattable {
			private KsDef _ks_def;

			public KsDef Ks_def { get { return _ks_def; } set { __isset.ks_def = true; _ks_def = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool ks_def { get; set; }
			}

			public system_update_keyspace_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ks_def = new KsDef();
								Ks_def.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_update_keyspace_args" );
				if( Ks_def != null && __isset.ks_def ) {
					writer.WriteFieldBegin( "ks_def", TypeKind.Struct, 1 );
					_ks_def.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Ks_def: ", Ks_def );
			}
		}
		public partial struct system_update_keyspace_result : IFormattable {
			private Utf8String _success;
			private InvalidRequestException _ire;
			private SchemaDisagreementException _sde;

			public Utf8String Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public SchemaDisagreementException Sde { get { return _sde; } set { __isset.sde = true; _sde = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool sde { get; set; }
			}

			public system_update_keyspace_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.String ) {
								Success = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Sde = new SchemaDisagreementException();
								Sde.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_update_keyspace_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.String, 0 );
						writer.WriteString( _success );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.sde ) {
					writer.WriteFieldBegin( "Sde", TypeKind.Struct, 2 );
					_sde.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Sde: ", Sde );
			}
		}
		public partial struct system_update_column_family_args : IFormattable {
			private CfDef _cf_def;

			public CfDef Cf_def { get { return _cf_def; } set { __isset.cf_def = true; _cf_def = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool cf_def { get; set; }
			}

			public system_update_column_family_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Cf_def = new CfDef();
								Cf_def.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_update_column_family_args" );
				if( Cf_def != null && __isset.cf_def ) {
					writer.WriteFieldBegin( "cf_def", TypeKind.Struct, 1 );
					_cf_def.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Cf_def: ", Cf_def );
			}
		}
		public partial struct system_update_column_family_result : IFormattable {
			private Utf8String _success;
			private InvalidRequestException _ire;
			private SchemaDisagreementException _sde;

			public Utf8String Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public SchemaDisagreementException Sde { get { return _sde; } set { __isset.sde = true; _sde = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool sde { get; set; }
			}

			public system_update_column_family_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.String ) {
								Success = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Sde = new SchemaDisagreementException();
								Sde.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "system_update_column_family_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.String, 0 );
						writer.WriteString( _success );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.sde ) {
					writer.WriteFieldBegin( "Sde", TypeKind.Struct, 2 );
					_sde.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Sde: ", Sde );
			}
		}
		public partial struct execute_cql_query_args : IFormattable {
			private byte[] _query;
			private Compression _compression;

			public byte[] Query { get { return _query; } set { __isset.query = true; _query = value; } }
			/// <summary>
			///
			/// <seealso cref="Compression"/>
			/// </summary>
			public Compression Compression { get { return _compression; } set { __isset.compression = true; _compression = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool query { get; set; }
				public bool compression { get; set; }
			}

			public execute_cql_query_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Query = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Int32 ) {
								Compression = ( Compression ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "execute_cql_query_args" );
				if( Query != null && __isset.query ) {
					writer.WriteFieldBegin( "query", TypeKind.String, 1 );
					writer.WriteBinary( _query );
					writer.WriteFieldEnd();
				}
				if( __isset.compression ) {
					writer.WriteFieldBegin( "compression", TypeKind.Int32, 2 );
					writer.WriteInt32( ( int ) _compression );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Query: ", Query, " Compression: ", Compression );
			}
		}
		public partial struct execute_cql_query_result : IFormattable {
			private CqlResult _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;
			private SchemaDisagreementException _sde;

			public CqlResult Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }
			public SchemaDisagreementException Sde { get { return _sde; } set { __isset.sde = true; _sde = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
				public bool sde { get; set; }
			}

			public execute_cql_query_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Struct ) {
								Success = new CqlResult();
								Success.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Struct ) {
								Sde = new SchemaDisagreementException();
								Sde.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "execute_cql_query_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Struct, 0 );
						_success.Write( writer );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.sde ) {
					writer.WriteFieldBegin( "Sde", TypeKind.Struct, 4 );
					_sde.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te, " Sde: ", Sde );
			}
		}
		public partial struct execute_cql3_query_args : IFormattable {
			private byte[] _query;
			private Compression _compression;
			private ConsistencyLevel _consistency;

			public byte[] Query { get { return _query; } set { __isset.query = true; _query = value; } }
			/// <summary>
			///
			/// <seealso cref="Compression"/>
			/// </summary>
			public Compression Compression { get { return _compression; } set { __isset.compression = true; _compression = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency { get { return _consistency; } set { __isset.consistency = true; _consistency = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool query { get; set; }
				public bool compression { get; set; }
				public bool consistency { get; set; }
			}

			public execute_cql3_query_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Query = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Int32 ) {
								Compression = ( Compression ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Int32 ) {
								Consistency = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "execute_cql3_query_args" );
				if( Query != null && __isset.query ) {
					writer.WriteFieldBegin( "query", TypeKind.String, 1 );
					writer.WriteBinary( _query );
					writer.WriteFieldEnd();
				}
				if( __isset.compression ) {
					writer.WriteFieldBegin( "compression", TypeKind.Int32, 2 );
					writer.WriteInt32( ( int ) _compression );
					writer.WriteFieldEnd();
				}
				if( __isset.consistency ) {
					writer.WriteFieldBegin( "consistency", TypeKind.Int32, 3 );
					writer.WriteInt32( ( int ) _consistency );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Query: ", Query, " Compression: ", Compression, " Consistency: ", Consistency );
			}
		}
		public partial struct execute_cql3_query_result : IFormattable {
			private CqlResult _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;
			private SchemaDisagreementException _sde;

			public CqlResult Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }
			public SchemaDisagreementException Sde { get { return _sde; } set { __isset.sde = true; _sde = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
				public bool sde { get; set; }
			}

			public execute_cql3_query_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Struct ) {
								Success = new CqlResult();
								Success.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Struct ) {
								Sde = new SchemaDisagreementException();
								Sde.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "execute_cql3_query_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Struct, 0 );
						_success.Write( writer );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.sde ) {
					writer.WriteFieldBegin( "Sde", TypeKind.Struct, 4 );
					_sde.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te, " Sde: ", Sde );
			}
		}
		public partial struct prepare_cql_query_args : IFormattable {
			private byte[] _query;
			private Compression _compression;

			public byte[] Query { get { return _query; } set { __isset.query = true; _query = value; } }
			/// <summary>
			///
			/// <seealso cref="Compression"/>
			/// </summary>
			public Compression Compression { get { return _compression; } set { __isset.compression = true; _compression = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool query { get; set; }
				public bool compression { get; set; }
			}

			public prepare_cql_query_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Query = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Int32 ) {
								Compression = ( Compression ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "prepare_cql_query_args" );
				if( Query != null && __isset.query ) {
					writer.WriteFieldBegin( "query", TypeKind.String, 1 );
					writer.WriteBinary( _query );
					writer.WriteFieldEnd();
				}
				if( __isset.compression ) {
					writer.WriteFieldBegin( "compression", TypeKind.Int32, 2 );
					writer.WriteInt32( ( int ) _compression );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Query: ", Query, " Compression: ", Compression );
			}
		}
		public partial struct prepare_cql_query_result : IFormattable {
			private CqlPreparedResult _success;
			private InvalidRequestException _ire;

			public CqlPreparedResult Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
			}

			public prepare_cql_query_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Struct ) {
								Success = new CqlPreparedResult();
								Success.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "prepare_cql_query_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Struct, 0 );
						_success.Write( writer );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire );
			}
		}
		public partial struct prepare_cql3_query_args : IFormattable {
			private byte[] _query;
			private Compression _compression;

			public byte[] Query { get { return _query; } set { __isset.query = true; _query = value; } }
			/// <summary>
			///
			/// <seealso cref="Compression"/>
			/// </summary>
			public Compression Compression { get { return _compression; } set { __isset.compression = true; _compression = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool query { get; set; }
				public bool compression { get; set; }
			}

			public prepare_cql3_query_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Query = reader.ReadBinary();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Int32 ) {
								Compression = ( Compression ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "prepare_cql3_query_args" );
				if( Query != null && __isset.query ) {
					writer.WriteFieldBegin( "query", TypeKind.String, 1 );
					writer.WriteBinary( _query );
					writer.WriteFieldEnd();
				}
				if( __isset.compression ) {
					writer.WriteFieldBegin( "compression", TypeKind.Int32, 2 );
					writer.WriteInt32( ( int ) _compression );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Query: ", Query, " Compression: ", Compression );
			}
		}
		public partial struct prepare_cql3_query_result : IFormattable {
			private CqlPreparedResult _success;
			private InvalidRequestException _ire;

			public CqlPreparedResult Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
			}

			public prepare_cql3_query_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Struct ) {
								Success = new CqlPreparedResult();
								Success.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "prepare_cql3_query_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Struct, 0 );
						_success.Write( writer );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire );
			}
		}
		public partial struct execute_prepared_cql_query_args : IFormattable {
			private int _itemId;
			private List<byte[]> _values;

			public int ItemId { get { return _itemId; } set { __isset.itemId = true; _itemId = value; } }
			public List<byte[]> Values { get { return _values; } set { __isset.values = true; _values = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool itemId { get; set; }
				public bool values { get; set; }
			}

			public execute_prepared_cql_query_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Int32 ) {
								ItemId = reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Values = new List<byte[]>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = reader.ReadBinary();
									_values.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "execute_prepared_cql_query_args" );
				if( __isset.itemId ) {
					writer.WriteFieldBegin( "itemId", TypeKind.Int32, 1 );
					writer.WriteInt32( _itemId );
					writer.WriteFieldEnd();
				}
				if( Values != null && __isset.values ) {
					writer.WriteFieldBegin( "values", TypeKind.List, 2 );
					{
						writer.WriteListBegin( TypeKind.String, _values.Count );
						foreach( var item in _values ) {
							writer.WriteBinary( item );
						}
						writer.WriteListEnd();
					}
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "ItemId: ", ItemId, " Values: ", Values );
			}
		}
		public partial struct execute_prepared_cql_query_result : IFormattable {
			private CqlResult _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;
			private SchemaDisagreementException _sde;

			public CqlResult Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }
			public SchemaDisagreementException Sde { get { return _sde; } set { __isset.sde = true; _sde = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
				public bool sde { get; set; }
			}

			public execute_prepared_cql_query_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Struct ) {
								Success = new CqlResult();
								Success.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Struct ) {
								Sde = new SchemaDisagreementException();
								Sde.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "execute_prepared_cql_query_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Struct, 0 );
						_success.Write( writer );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.sde ) {
					writer.WriteFieldBegin( "Sde", TypeKind.Struct, 4 );
					_sde.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te, " Sde: ", Sde );
			}
		}
		public partial struct execute_prepared_cql3_query_args : IFormattable {
			private int _itemId;
			private List<byte[]> _values;
			private ConsistencyLevel _consistency;

			public int ItemId { get { return _itemId; } set { __isset.itemId = true; _itemId = value; } }
			public List<byte[]> Values { get { return _values; } set { __isset.values = true; _values = value; } }
			/// <summary>
			///
			/// <seealso cref="ConsistencyLevel"/>
			/// </summary>
			public ConsistencyLevel Consistency { get { return _consistency; } set { __isset.consistency = true; _consistency = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool itemId { get; set; }
				public bool values { get; set; }
				public bool consistency { get; set; }
			}

			public execute_prepared_cql3_query_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Int32 ) {
								ItemId = reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.List ) {
								var localList = reader.ReadListBegin();
								Values = new List<byte[]>( localList.Count );
								for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
									var localElement = reader.ReadBinary();
									_values.Add( localElement );
								}
								reader.ReadListEnd();
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Int32 ) {
								Consistency = ( ConsistencyLevel ) reader.ReadInt32();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "execute_prepared_cql3_query_args" );
				if( __isset.itemId ) {
					writer.WriteFieldBegin( "itemId", TypeKind.Int32, 1 );
					writer.WriteInt32( _itemId );
					writer.WriteFieldEnd();
				}
				if( Values != null && __isset.values ) {
					writer.WriteFieldBegin( "values", TypeKind.List, 2 );
					{
						writer.WriteListBegin( TypeKind.String, _values.Count );
						foreach( var item in _values ) {
							writer.WriteBinary( item );
						}
						writer.WriteListEnd();
					}
					writer.WriteFieldEnd();
				}
				if( __isset.consistency ) {
					writer.WriteFieldBegin( "consistency", TypeKind.Int32, 3 );
					writer.WriteInt32( ( int ) _consistency );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "ItemId: ", ItemId, " Values: ", Values, " Consistency: ", Consistency );
			}
		}
		public partial struct execute_prepared_cql3_query_result : IFormattable {
			private CqlResult _success;
			private InvalidRequestException _ire;
			private UnavailableException _ue;
			private TimedOutException _te;
			private SchemaDisagreementException _sde;

			public CqlResult Success { get { return _success; } set { __isset.success = true; _success = value; } }
			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }
			public UnavailableException Ue { get { return _ue; } set { __isset.ue = true; _ue = value; } }
			public TimedOutException Te { get { return _te; } set { __isset.te = true; _te = value; } }
			public SchemaDisagreementException Sde { get { return _sde; } set { __isset.sde = true; _sde = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool success { get; set; }
				public bool ire { get; set; }
				public bool ue { get; set; }
				public bool te { get; set; }
				public bool sde { get; set; }
			}

			public execute_prepared_cql3_query_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 0:
							if( field.Type == TypeKind.Struct ) {
								Success = new CqlResult();
								Success.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 2:
							if( field.Type == TypeKind.Struct ) {
								Ue = new UnavailableException();
								Ue.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 3:
							if( field.Type == TypeKind.Struct ) {
								Te = new TimedOutException();
								Te.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						case 4:
							if( field.Type == TypeKind.Struct ) {
								Sde = new SchemaDisagreementException();
								Sde.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "execute_prepared_cql3_query_result" );

				if( __isset.success ) {
					if( Success != null ) {
						writer.WriteFieldBegin( "Success", TypeKind.Struct, 0 );
						_success.Write( writer );
						writer.WriteFieldEnd();
					}
				} else if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.ue ) {
					writer.WriteFieldBegin( "Ue", TypeKind.Struct, 2 );
					_ue.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.te ) {
					writer.WriteFieldBegin( "Te", TypeKind.Struct, 3 );
					_te.Write( writer );
					writer.WriteFieldEnd();
				} else if( __isset.sde ) {
					writer.WriteFieldBegin( "Sde", TypeKind.Struct, 4 );
					_sde.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Success: ", Success, " Ire: ", Ire, " Ue: ", Ue, " Te: ", Te, " Sde: ", Sde );
			}
		}
		public partial struct set_cql_version_args : IFormattable {
			private Utf8String _version;

			public Utf8String Version { get { return _version; } set { __isset.version = true; _version = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool version { get; set; }
			}

			public set_cql_version_args() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.String ) {
								Version = reader.ReadString();
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "set_cql_version_args" );
				if( Version != null && __isset.version ) {
					writer.WriteFieldBegin( "version", TypeKind.String, 1 );
					writer.WriteString( _version );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Version: ", Version );
			}
		}
		public partial struct set_cql_version_result : IFormattable {
			private InvalidRequestException _ire;

			public InvalidRequestException Ire { get { return _ire; } set { __isset.ire = true; _ire = value; } }

			public Isset __isset = default( Isset );
			public struct Isset {
				public bool ire { get; set; }
			}

			public set_cql_version_result() {
			}

			public void Read( ProtocolCodec reader ) {
				reader.ReadStructBegin();
				while( true ) {
					var field = reader.ReadFieldBegin();
					if( field.Type == TypeKind.Stop ) break;

					switch( field.ID ) {
						case 1:
							if( field.Type == TypeKind.Struct ) {
								Ire = new InvalidRequestException();
								Ire.Read( reader );
							}
							else reader.Skip( field.Type );
							break;

						default:
							reader.Skip( field.Type );
							break;
					}
					reader.ReadFieldEnd();
				}
				reader.ReadStructEnd();
			}

			public void Write( ProtocolCodec writer ) {
				writer.WriteStructBegin( "set_cql_version_result" );

				if( __isset.ire ) {
					writer.WriteFieldBegin( "Ire", TypeKind.Struct, 1 );
					_ire.Write( writer );
					writer.WriteFieldEnd();
				}
				writer.WriteFieldStop();
				writer.WriteStructEnd();
			}

			public void ToString( StringBuilder builder, string format ) {
				builder.Concat( "Ire: ", Ire );
			}
		}
	}
}