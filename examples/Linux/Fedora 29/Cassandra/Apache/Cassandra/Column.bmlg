//
// Autogenerated by Thrift Compiler ( 0.9.0-dev ). Do not edit
//

using System;
using System.Serialization.Thrift;

namespace Apache.Cassandra {
	/// <summary>
	/// Basic unit of data within a ColumnFamily.
	/// @param name, the name by which this column is set and retrieved.  Maximum 64KB long.
	/// @param value. The data associated with the name.  Maximum 2GB long, but in practice you should limit it to small numbers of MB (since Thrift must read the full value into memory to operate on it).
	/// @param timestamp. The timestamp is used for conflict detection/resolution when two columns with same name need to be compared.
	/// @param ttl. An optional, positive delay (in seconds) after which the column will be automatically deleted.
	/// </summary>
	public partial class Column : IFormattable {
		private byte[] _name;
		private byte[] _value;
		private long _timestamp;
		private int _ttl;

		public byte[] Name { get { return _name; } set { __isset.name = true; _name = value; } }
		public byte[] Value { get { return _value; } set { __isset.value = true; _value = value; } }
		public long Timestamp { get { return _timestamp; } set { __isset.timestamp = true; _timestamp = value; } }
		public int Ttl { get { return _ttl; } set { __isset.ttl = true; _ttl = value; } }

		public Isset __isset = default( Isset );
		public struct Isset {
			public bool name { get; set; }
			public bool value { get; set; }
			public bool timestamp { get; set; }
			public bool ttl { get; set; }
		}

		public Column() {
		}

		public void Read( ProtocolCodec reader ) {
			reader.ReadStructBegin();
			while( true ) {
				var field = reader.ReadFieldBegin();
				if( field.Type == TypeKind.Stop ) break;

				switch( field.ID ) {
					case 1:
						if( field.Type == TypeKind.String ) {
							Name = reader.ReadBinary();
						}
						else reader.Skip( field.Type );
						break;

					case 2:
						if( field.Type == TypeKind.String ) {
							Value = reader.ReadBinary();
						}
						else reader.Skip( field.Type );
						break;

					case 3:
						if( field.Type == TypeKind.Int64 ) {
							Timestamp = reader.ReadInt64();
						}
						else reader.Skip( field.Type );
						break;

					case 4:
						if( field.Type == TypeKind.Int32 ) {
							Ttl = reader.ReadInt32();
						}
						else reader.Skip( field.Type );
						break;

					default:
						reader.Skip( field.Type );
						break;
				}
				reader.ReadFieldEnd();
			}
			reader.ReadStructEnd();
		}

		public void Write( ProtocolCodec writer ) {
			writer.WriteStructBegin( "Column" );
			if( Name != null && __isset.name ) {
				writer.WriteFieldBegin( "name", TypeKind.String, 1 );
				writer.WriteBinary( _name );
				writer.WriteFieldEnd();
			}
			if( Value != null && __isset.value ) {
				writer.WriteFieldBegin( "value", TypeKind.String, 2 );
				writer.WriteBinary( _value );
				writer.WriteFieldEnd();
			}
			if( __isset.timestamp ) {
				writer.WriteFieldBegin( "timestamp", TypeKind.Int64, 3 );
				writer.WriteInt64( _timestamp );
				writer.WriteFieldEnd();
			}
			if( __isset.ttl ) {
				writer.WriteFieldBegin( "ttl", TypeKind.Int32, 4 );
				writer.WriteInt32( _ttl );
				writer.WriteFieldEnd();
			}
			writer.WriteFieldStop();
			writer.WriteStructEnd();
		}

		public void ToString( StringBuilder builder, string format ) {
			builder.Concat( "Name: ", Name, " Value: ", Value, " Timestamp: ", Timestamp, " Ttl: ", Ttl );
		}
	}
}