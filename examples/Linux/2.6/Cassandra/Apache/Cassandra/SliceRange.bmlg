//
// Autogenerated by Thrift Compiler ( 0.9.0-dev ). Do not edit
//

using System;
using System.Serialization.Thrift;

namespace Apache.Cassandra {
	/// <summary>
	/// A slice range is a structure that stores basic range, ordering and limit information for a query that will return
	/// multiple columns. It could be thought of as Cassandra's version of LIMIT and ORDER BY
	///
	/// @param start. The column name to start the slice with. This attribute is not required, though there is no default value,
	///               and can be safely set to '', i.e., an empty byte array, to start with the first column name. Otherwise, it
	///               must a valid value under the rules of the Comparator defined for the given ColumnFamily.
	/// @param finish. The column name to stop the slice at. This attribute is not required, though there is no default value,
	///                and can be safely set to an empty byte array to not stop until 'count' results are seen. Otherwise, it
	///                must also be a valid value to the ColumnFamily Comparator.
	/// @param reversed. Whether the results should be ordered in reversed order. Similar to ORDER BY blah DESC in SQL.
	/// @param count. How many columns to return. Similar to LIMIT in SQL. May be arbitrarily large, but Thrift will
	///               materialize the whole result into memory before returning it to the client, so be aware that you may
	///               be better served by iterating through slices by passing the last value of one call in as the 'start'
	///               of the next instead of increasing 'count' arbitrarily large.
	/// </summary>
	public partial class SliceRange : IFormattable {
		private byte[] _start;
		private byte[] _finish;
		private bool _reversed;
		private int _count;

		public byte[] Start { get { return _start; } set { __isset.start = true; _start = value; } }
		public byte[] Finish { get { return _finish; } set { __isset.finish = true; _finish = value; } }
		public bool Reversed { get { return _reversed; } set { __isset.reversed = true; _reversed = value; } }
		public int Count { get { return _count; } set { __isset.count = true; _count = value; } }

		public Isset __isset = default( Isset );
		public struct Isset {
			public bool start { get; set; }
			public bool finish { get; set; }
			public bool reversed { get; set; }
			public bool count { get; set; }
		}

		public SliceRange() {
			_reversed = false;
			_count = 100;
		}

		public void Read( ProtocolCodec reader ) {
			reader.ReadStructBegin();
			while( true ) {
				var field = reader.ReadFieldBegin();
				if( field.Type == TypeKind.Stop ) break;

				switch( field.ID ) {
					case 1:
						if( field.Type == TypeKind.String ) {
							Start = reader.ReadBinary();
						}
						else reader.Skip( field.Type );
						break;

					case 2:
						if( field.Type == TypeKind.String ) {
							Finish = reader.ReadBinary();
						}
						else reader.Skip( field.Type );
						break;

					case 3:
						if( field.Type == TypeKind.Bool ) {
							Reversed = reader.ReadBool();
						}
						else reader.Skip( field.Type );
						break;

					case 4:
						if( field.Type == TypeKind.Int32 ) {
							Count = reader.ReadInt32();
						}
						else reader.Skip( field.Type );
						break;

					default:
						reader.Skip( field.Type );
						break;
				}
				reader.ReadFieldEnd();
			}
			reader.ReadStructEnd();
		}

		public void Write( ProtocolCodec writer ) {
			writer.WriteStructBegin( "SliceRange" );
			if( Start != null && __isset.start ) {
				writer.WriteFieldBegin( "start", TypeKind.String, 1 );
				writer.WriteBinary( _start );
				writer.WriteFieldEnd();
			}
			if( Finish != null && __isset.finish ) {
				writer.WriteFieldBegin( "finish", TypeKind.String, 2 );
				writer.WriteBinary( _finish );
				writer.WriteFieldEnd();
			}
			if( __isset.reversed ) {
				writer.WriteFieldBegin( "reversed", TypeKind.Bool, 3 );
				writer.WriteBool( _reversed );
				writer.WriteFieldEnd();
			}
			if( __isset.count ) {
				writer.WriteFieldBegin( "count", TypeKind.Int32, 4 );
				writer.WriteInt32( _count );
				writer.WriteFieldEnd();
			}
			writer.WriteFieldStop();
			writer.WriteStructEnd();
		}

		public void ToString( StringBuilder builder, string format ) {
			builder.Concat( "Start: ", Start, " Finish: ", Finish, " Reversed: ", Reversed, " Count: ", Count );
		}
	}
}