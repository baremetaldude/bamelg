//
// Autogenerated by Thrift Compiler ( 0.9.0-dev ). Do not edit
//

using System;
using System.Collections;
using System.Serialization.Thrift;

namespace Apache.Cassandra {
	public partial class CqlResult : IFormattable {
		private CqlResultType _type;
		private List<CqlRow> _rows;
		private int _num;
		private CqlMetadata _schema;

		/// <summary>
		///
		/// <seealso cref="CqlResultType"/>
		/// </summary>
		public CqlResultType Type { get { return _type; } set { __isset.type = true; _type = value; } }
		public List<CqlRow> Rows { get { return _rows; } set { __isset.rows = true; _rows = value; } }
		public int Num { get { return _num; } set { __isset.num = true; _num = value; } }
		public CqlMetadata Schema { get { return _schema; } set { __isset.schema = true; _schema = value; } }

		public Isset __isset = default( Isset );
		public struct Isset {
			public bool type { get; set; }
			public bool rows { get; set; }
			public bool num { get; set; }
			public bool schema { get; set; }
		}

		public CqlResult() {
		}

		public void Read( ProtocolCodec reader ) {
			reader.ReadStructBegin();
			while( true ) {
				var field = reader.ReadFieldBegin();
				if( field.Type == TypeKind.Stop ) break;

				switch( field.ID ) {
					case 1:
						if( field.Type == TypeKind.Int32 ) {
							Type = ( CqlResultType ) reader.ReadInt32();
						}
						else reader.Skip( field.Type );
						break;

					case 2:
						if( field.Type == TypeKind.List ) {
							var localList = reader.ReadListBegin();
							Rows = new List<CqlRow>( localList.Count );
							for( var localCounter = 0; localCounter < localList.Count; ++localCounter ) {
								var localElement = new CqlRow();
								localElement.Read( reader );
								_rows.Add( localElement );
							}
							reader.ReadListEnd();
						}
						else reader.Skip( field.Type );
						break;

					case 3:
						if( field.Type == TypeKind.Int32 ) {
							Num = reader.ReadInt32();
						}
						else reader.Skip( field.Type );
						break;

					case 4:
						if( field.Type == TypeKind.Struct ) {
							Schema = new CqlMetadata();
							Schema.Read( reader );
						}
						else reader.Skip( field.Type );
						break;

					default:
						reader.Skip( field.Type );
						break;
				}
				reader.ReadFieldEnd();
			}
			reader.ReadStructEnd();
		}

		public void Write( ProtocolCodec writer ) {
			writer.WriteStructBegin( "CqlResult" );
			if( __isset.type ) {
				writer.WriteFieldBegin( "type", TypeKind.Int32, 1 );
				writer.WriteInt32( ( int ) _type );
				writer.WriteFieldEnd();
			}
			if( Rows != null && __isset.rows ) {
				writer.WriteFieldBegin( "rows", TypeKind.List, 2 );
				{
					writer.WriteListBegin( TypeKind.Struct, _rows.Count );
					foreach( var item in _rows ) {
						item.Write( writer );
					}
					writer.WriteListEnd();
				}
				writer.WriteFieldEnd();
			}
			if( __isset.num ) {
				writer.WriteFieldBegin( "num", TypeKind.Int32, 3 );
				writer.WriteInt32( _num );
				writer.WriteFieldEnd();
			}
			if( Schema != null && __isset.schema ) {
				writer.WriteFieldBegin( "schema", TypeKind.Struct, 4 );
				_schema.Write( writer );
				writer.WriteFieldEnd();
			}
			writer.WriteFieldStop();
			writer.WriteStructEnd();
		}

		public void ToString( StringBuilder builder, string format ) {
			builder.Concat( "Type: ", Type, " Rows: ", Rows, " Num: ", Num, " Schema: ", Schema );
		}
	}
}