//
// Autogenerated by Thrift Compiler ( 0.9.0-dev ). Do not edit
//

using System;
using System.Collections;
using System.Serialization.Thrift;

namespace Apache.Cassandra {
	/// <summary>
	/// The semantics of start keys and tokens are slightly different.
	/// Keys are start-inclusive; tokens are start-exclusive.  Token
	/// ranges may also wrap -- that is, the end token may be less
	/// than the start one.  Thus, a range from keyX to keyX is a
	/// one-element range, but a range from tokenY to tokenY is the
	/// full ring.
	/// </summary>
	public partial class KeyRange : IFormattable {
		private byte[] _start_key;
		private byte[] _end_key;
		private Utf8String _start_token;
		private Utf8String _end_token;
		private List<IndexExpression> _row_filter;
		private int _count;

		public byte[] Start_key { get { return _start_key; } set { __isset.start_key = true; _start_key = value; } }
		public byte[] End_key { get { return _end_key; } set { __isset.end_key = true; _end_key = value; } }
		public Utf8String Start_token { get { return _start_token; } set { __isset.start_token = true; _start_token = value; } }
		public Utf8String End_token { get { return _end_token; } set { __isset.end_token = true; _end_token = value; } }
		public List<IndexExpression> Row_filter { get { return _row_filter; } set { __isset.row_filter = true; _row_filter = value; } }
		public int Count { get { return _count; } set { __isset.count = true; _count = value; } }

		public Isset __isset = default( Isset );
		public struct Isset {
			public bool start_key { get; set; }
			public bool end_key { get; set; }
			public bool start_token { get; set; }
			public bool end_token { get; set; }
			public bool row_filter { get; set; }
			public bool count { get; set; }
		}

		public KeyRange() {
			_count = 100;
		}

		public void Read( ProtocolCodec reader ) {
			reader.ReadStructBegin();
			while( true ) {
				var field = reader.ReadFieldBegin();
				if( field.Type == TypeKind.Stop ) break;

				switch( field.ID ) {
					case 1:
						if( field.Type == TypeKind.String ) {
							Start_key = reader.ReadBinary();
						}
						else reader.Skip( field.Type );
						break;

					case 2:
						if( field.Type == TypeKind.String ) {
							End_key = reader.ReadBinary();
						}
						else reader.Skip( field.Type );
						break;

					case 3:
						if( field.Type == TypeKind.String ) {
							Start_token = reader.ReadString();
						}
						else reader.Skip( field.Type );
						break;

					case 4:
						if( field.Type == TypeKind.String ) {
							End_token = reader.ReadString();
						}
						else reader.Skip( field.Type );
						break;

					case 6:
						if( field.Type == TypeKind.List ) {
							var _list12 = reader.ReadListBegin();
							Row_filter = new List<IndexExpression>( _list12.Count );
							for( var _i13 = 0; _i13 < _list12.Count; ++_i13 ) {
								var _elem14 = new IndexExpression();
								_elem14.Read( reader );
								Row_filter.Add( _elem14 );
							}
							reader.ReadListEnd();
						}
						else reader.Skip( field.Type );
						break;

					case 5:
						if( field.Type == TypeKind.Int32 ) {
							Count = reader.ReadInt32();
						}
						else reader.Skip( field.Type );
						break;

					default:
						reader.Skip( field.Type );
						break;
				}
				reader.ReadFieldEnd();
			}
			reader.ReadStructEnd();
		}

		public void Write( ProtocolCodec writer ) {
			writer.WriteStructBegin( "KeyRange" );
			if( Start_key != null && __isset.start_key ) {
				writer.WriteFieldBegin( "start_key", TypeKind.String, 1 );
				writer.WriteBinary( _start_key );
				writer.WriteFieldEnd();
			}
			if( End_key != null && __isset.end_key ) {
				writer.WriteFieldBegin( "end_key", TypeKind.String, 2 );
				writer.WriteBinary( _end_key );
				writer.WriteFieldEnd();
			}
			if( Start_token != null && __isset.start_token ) {
				writer.WriteFieldBegin( "start_token", TypeKind.String, 3 );
				writer.WriteString( _start_token );
				writer.WriteFieldEnd();
			}
			if( End_token != null && __isset.end_token ) {
				writer.WriteFieldBegin( "end_token", TypeKind.String, 4 );
				writer.WriteString( _end_token );
				writer.WriteFieldEnd();
			}
			if( __isset.count ) {
				writer.WriteFieldBegin( "count", TypeKind.Int32, 5 );
				writer.WriteInt32( _count );
				writer.WriteFieldEnd();
			}
			if( Row_filter != null && __isset.row_filter ) {
				writer.WriteFieldBegin( "row_filter", TypeKind.List, 6 );
				{
					writer.WriteListBegin( TypeKind.Struct, _row_filter.Count );
					foreach( var item in _row_filter ) {
						item.Write( writer );
					}
					writer.WriteListEnd();
				}
				writer.WriteFieldEnd();
			}
			writer.WriteFieldStop();
			writer.WriteStructEnd();
		}

		public void ToString( StringBuilder builder, string format ) {
			builder.Concat( "Start_key: ", Start_key, " End_key: ", End_key, " Start_token: ", Start_token, " End_token: ", End_token, " Row_filter: ", Row_filter, " Count: ", Count );
		}
	}
}